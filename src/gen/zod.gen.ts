// This file is auto-generated by @hey-api/openapi-ts

import { z } from 'zod';
import { __zodAugmentApplied } from '../zod-augment';
void __zodAugmentApplied; // ensure module retained for prototype patch // branding-plugin zod augmentation

/**
 * Zeebe Engine resource key (Java long serialized as string)
 */
export const zLongKey = z.string().min(1).max(25).regex(/^-?[0-9]+$/).register(z.globalRegistry, {
    description: 'Zeebe Engine resource key (Java long serialized as string)'
});

/**
 * The start cursor in a search query result set.
 */
export const zStartCursor = z.string().min(2).max(300).regex(/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}(?:==)?|[A-Za-z0-9+/]{3}=)?$/).register(z.globalRegistry, {
    description: 'The start cursor in a search query result set.'
});

/**
 * The end cursor in a search query result set.
 */
export const zEndCursor = z.string().min(2).max(300).regex(/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}(?:==)?|[A-Za-z0-9+/]{3}=)?$/).register(z.globalRegistry, {
    description: 'The end cursor in a search query result set.'
});

/**
 * System-generated key for a process instance.
 */
export const zProcessInstanceKey = zLongKey;

/**
 * Key for a deployment.
 */
export const zDeploymentKey = zLongKey;

/**
 * System-generated key for a user task.
 */
export const zUserTaskKey = zLongKey;

/**
 * System-generated key for a deployed process definition.
 */
export const zProcessDefinitionKey = zLongKey;

/**
 * Id of a process definition, from the model. Only ids of process definitions that are deployed are useful.
 */
export const zProcessDefinitionId = z.string().min(1).regex(/^[a-zA-Z_][a-zA-Z0-9_\-\.]*$/).register(z.globalRegistry, {
    description: 'Id of a process definition, from the model. Only ids of process definitions that are deployed are useful.'
});

/**
 * System-generated key for a element instance.
 */
export const zElementInstanceKey = zLongKey;

/**
 * The model-defined id of an element.
 */
export const zElementId = z.string().register(z.globalRegistry, {
    description: 'The model-defined id of an element.'
});

/**
 * System-generated key for a deployed form.
 */
export const zFormKey = zLongKey;

/**
 * The user-defined id for the form
 */
export const zFormId = z.string().register(z.globalRegistry, {
    description: 'The user-defined id for the form'
});

/**
 * System-generated key for a variable.
 */
export const zVariableKey = zLongKey;

/**
 * System-generated key for a deployed decision requirements definition.
 */
export const zDecisionRequirementsKey = zLongKey;

/**
 * System-generated key for a decision definition.
 */
export const zDecisionDefinitionKey = zLongKey;

/**
 * The system-assigned key for this resource.
 */
export const zResourceKey = z.union([
    zProcessDefinitionKey,
    zDecisionRequirementsKey,
    zFormKey,
    zDecisionDefinitionKey
]);

/**
 * System-generated key for a scope.
 */
export const zScopeKey = zLongKey;

/**
 * System-generated key for a incident.
 */
export const zIncidentKey = zLongKey;

/**
 * System-generated key for a job.
 */
export const zJobKey = zLongKey;

/**
 * System-generated key for a message subscription.
 */
export const zMessageSubscriptionKey = zLongKey;

/**
 * System-generated key for a message correlation.
 */
export const zMessageCorrelationKey = zLongKey;

/**
 * Id of a decision definition, from the model. Only ids of decision definitions that are deployed are useful.
 */
export const zDecisionDefinitionId = z.string().min(1).max(256).regex(/^[A-Za-z0-9_@.+-]+$/).register(z.globalRegistry, {
    description: 'Id of a decision definition, from the model. Only ids of decision definitions that are deployed are useful.'
});

/**
 * System-generated key for a decision evaluation instance.
 */
export const zDecisionEvaluationInstanceKey = zLongKey;

/**
 * System-generated key for a decision evaluation.
 */
export const zDecisionEvaluationKey = zLongKey;

/**
 * System-generated key for an authorization.
 */
export const zAuthorizationKey = zLongKey;

/**
 * System-generated key for an message.
 */
export const zMessageKey = zLongKey;

/**
 * System-generated key for a deployed decision instance.
 */
export const zDecisionInstanceKey = zLongKey;

/**
 * System-generated key for an signal.
 */
export const zSignalKey = zLongKey;

/**
 * System-generated key for an batch operation.
 */
export const zBatchOperationKey = z.string().register(z.globalRegistry, {
    description: 'System-generated key for an batch operation.'
});

export const zTenantCreateRequest = z.object({
    tenantId: z.string().min(1).max(256).regex(/^[A-Za-z0-9_@.+-]+$/).register(z.globalRegistry, {
        description: 'The unique ID for the tenant. Must be 255 characters or less. Can contain letters, numbers, [`_`, `-`, `+`, `.`, `@`].'
    }),
    name: z.string().register(z.globalRegistry, {
        description: 'The name of the tenant.'
    }),
    description: z.optional(z.string().register(z.globalRegistry, {
        description: 'The description of the tenant.'
    }))
});

/**
 * The unique identifier of the tenant.
 */
export const zTenantId = z.string().min(1).max(256).regex(/^(<default>|[A-Za-z0-9_@.+-]+)$/).register(z.globalRegistry, {
    description: 'The unique identifier of the tenant.'
});

export const zTenantCreateResult = z.object({
    tenantId: z.optional(zTenantId),
    name: z.optional(z.string().register(z.globalRegistry, {
        description: 'The name of the tenant.'
    })),
    description: z.optional(z.string().register(z.globalRegistry, {
        description: 'The description of the tenant.'
    }))
});

export const zTenantUpdateRequest = z.object({
    name: z.string().register(z.globalRegistry, {
        description: 'The new name of the tenant.'
    }),
    description: z.string().register(z.globalRegistry, {
        description: 'The new description of the tenant.'
    })
});

export const zTenantUpdateResult = z.object({
    tenantId: z.optional(zTenantId),
    name: z.optional(z.string().register(z.globalRegistry, {
        description: 'The name of the tenant.'
    })),
    description: z.optional(z.string().register(z.globalRegistry, {
        description: 'The description of the tenant.'
    }))
});

/**
 * Tenant search response item.
 */
export const zTenantResult = z.object({
    name: z.optional(z.string().register(z.globalRegistry, {
        description: 'The tenant name.'
    })),
    tenantId: z.optional(zTenantId),
    description: z.optional(z.string().register(z.globalRegistry, {
        description: 'The tenant description.'
    }))
}).register(z.globalRegistry, {
    description: 'Tenant search response item.'
});

/**
 * The order in which to sort the related field.
 */
export const zSortOrderEnum = z.enum([
    'ASC',
    'DESC'
]).register(z.globalRegistry, {
    description: 'The order in which to sort the related field.'
});

export const zTenantSearchQuerySortRequest = z.object({
    field: z.enum([
        'key',
        'name',
        'tenantId'
    ]).register(z.globalRegistry, {
        description: 'The field to sort by.'
    }),
    order: z.optional(zSortOrderEnum)
});

/**
 * Offset-based pagination
 */
export const zOffsetPagination = z.object({
    from: z.optional(z.int().gte(0).register(z.globalRegistry, {
        description: 'The index of items to start searching from.'
    })).default(0),
    limit: z.optional(z.int().gte(1).register(z.globalRegistry, {
        description: 'The maximum number of items to return in one request.'
    })).default(100)
});

/**
 * Cursor-based forward pagination
 */
export const zCursorForwardPagination = z.object({
    after: zEndCursor,
    limit: z.optional(z.int().register(z.globalRegistry, {
        description: 'The maximum number of items to return in one request.'
    })).default(100)
});

/**
 * Cursor-based backward pagination
 */
export const zCursorBackwardPagination = z.object({
    before: zStartCursor,
    limit: z.optional(z.int().register(z.globalRegistry, {
        description: 'The maximum number of items to return in one request.'
    })).default(100)
});

/**
 * Pagination criteria. Can use offset-based pagination (from/limit) OR cursor-based pagination (after/before + limit), but not both.
 */
export const zSearchQueryPageRequest = z.union([
    zOffsetPagination,
    zCursorForwardPagination,
    zCursorBackwardPagination
]);

export const zSearchQueryRequest = z.object({
    page: z.optional(zSearchQueryPageRequest)
});

/**
 * Tenant filter request
 */
export const zTenantFilter = z.object({
    tenantId: z.optional(zTenantId),
    name: z.optional(z.string().register(z.globalRegistry, {
        description: 'The name of the tenant.'
    }))
}).register(z.globalRegistry, {
    description: 'Tenant filter request'
});

/**
 * Tenant search request
 */
export const zTenantSearchQueryRequest = zSearchQueryRequest.and(z.object({
    sort: z.optional(z.array(zTenantSearchQuerySortRequest).register(z.globalRegistry, {
        description: 'Sort field criteria.'
    })),
    filter: z.optional(zTenantFilter)
}).register(z.globalRegistry, {
    description: 'Tenant search request'
}));

/**
 * Pagination information about the search results.
 */
export const zSearchQueryPageResponse = z.object({
    totalItems: z.coerce.bigint().register(z.globalRegistry, {
        description: 'Total items matching the criteria.'
    }),
    hasMoreTotalItems: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Indicates if more results exist beyond the reported totalItems value. Due to system limitations, the totalItems value can be capped.\n'
    })),
    startCursor: z.optional(zStartCursor),
    endCursor: z.optional(zEndCursor)
}).register(z.globalRegistry, {
    description: 'Pagination information about the search results.'
});

export const zSearchQueryResponse = z.object({
    page: zSearchQueryPageResponse
});

/**
 * Tenant search response.
 */
export const zTenantSearchQueryResult = zSearchQueryResponse.and(z.object({
    items: z.optional(z.array(zTenantResult).register(z.globalRegistry, {
        description: 'The matching tenants.'
    }))
}).register(z.globalRegistry, {
    description: 'Tenant search response.'
}));

export const zUserTaskSearchQuerySortRequest = z.object({
    field: z.enum([
        'creationDate',
        'completionDate',
        'followUpDate',
        'dueDate',
        'priority',
        'name'
    ]).register(z.globalRegistry, {
        description: 'The field to sort by.'
    }),
    order: z.optional(zSortOrderEnum)
});

/**
 * The state of the user task.
 */
export const zUserTaskStateEnum = z.enum([
    'CREATING',
    'CREATED',
    'ASSIGNING',
    'UPDATING',
    'COMPLETING',
    'COMPLETED',
    'CANCELING',
    'CANCELED',
    'FAILED'
]).register(z.globalRegistry, {
    description: 'The state of the user task.'
});

/**
 * Checks if the property matches the provided like value.
 *
 * Supported wildcard characters are:
 *
 * * `*`: matches zero, one, or multiple characters.
 * * `?`: matches one, single character.
 *
 * Wildcard characters can be escaped with backslash, for instance: `\*`.
 *
 */
export const zLikeFilter = z.string().register(z.globalRegistry, {
    description: 'Checks if the property matches the provided like value.\n\nSupported wildcard characters are:\n\n* `*`: matches zero, one, or multiple characters.\n* `?`: matches one, single character.\n\nWildcard characters can be escaped with backslash, for instance: `\\*`.\n'
});

/**
 * Advanced filter
 * Advanced UserTaskStateEnum filter.
 */
export const zAdvancedUserTaskStateFilter = z.object({
    '$eq': z.optional(zUserTaskStateEnum),
    '$neq': z.optional(zUserTaskStateEnum),
    '$exists': z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Checks if the current property exists.'
    })),
    '$in': z.optional(z.array(zUserTaskStateEnum).register(z.globalRegistry, {
        description: 'Checks if the property matches any of the provided values.'
    })),
    '$like': z.optional(zLikeFilter)
}).register(z.globalRegistry, {
    description: 'Advanced UserTaskStateEnum filter.'
});

/**
 * UserTaskStateEnum property with full advanced search capabilities.
 */
export const zUserTaskStateFilterProperty = z.union([
    zUserTaskStateEnum,
    zAdvancedUserTaskStateFilter
]);

/**
 * Advanced filter
 * Basic advanced string filter.
 */
export const zBasicStringFilter = z.object({
    '$eq': z.optional(z.string().register(z.globalRegistry, {
        description: 'Checks for equality with the provided value.'
    })),
    '$neq': z.optional(z.string().register(z.globalRegistry, {
        description: 'Checks for inequality with the provided value.'
    })),
    '$exists': z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Checks if the current property exists.'
    })),
    '$in': z.optional(z.array(z.string()).register(z.globalRegistry, {
        description: 'Checks if the property matches any of the provided values.'
    })),
    '$notIn': z.optional(z.array(z.string()).register(z.globalRegistry, {
        description: 'Checks if the property matches none of the provided values.'
    }))
}).register(z.globalRegistry, {
    description: 'Basic advanced string filter.'
});

/**
 * Advanced filter
 * Advanced string filter.
 */
export const zAdvancedStringFilter = zBasicStringFilter.and(z.object({
    '$like': z.optional(zLikeFilter)
}));

/**
 * String property with full advanced search capabilities.
 */
export const zStringFilterProperty = z.union([
    z.string().register(z.globalRegistry, {
        description: 'Matches the value exactly.'
    }),
    zAdvancedStringFilter
]);

/**
 * Advanced filter
 * Advanced integer (int32) filter.
 */
export const zAdvancedIntegerFilter = z.object({
    '$eq': z.optional(z.int().register(z.globalRegistry, {
        description: 'Checks for equality with the provided value.'
    })),
    '$neq': z.optional(z.int().register(z.globalRegistry, {
        description: 'Checks for inequality with the provided value.'
    })),
    '$exists': z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Checks if the current property exists.'
    })),
    '$gt': z.optional(z.int().register(z.globalRegistry, {
        description: 'Greater than comparison with the provided value.'
    })),
    '$gte': z.optional(z.int().register(z.globalRegistry, {
        description: 'Greater than or equal comparison with the provided value.'
    })),
    '$lt': z.optional(z.int().register(z.globalRegistry, {
        description: 'Lower than comparison with the provided value.'
    })),
    '$lte': z.optional(z.int().register(z.globalRegistry, {
        description: 'Lower than or equal comparison with the provided value.'
    })),
    '$in': z.optional(z.array(z.int()).register(z.globalRegistry, {
        description: 'Checks if the property matches any of the provided values.'
    }))
}).register(z.globalRegistry, {
    description: 'Advanced integer (int32) filter.'
});

/**
 * Integer property with advanced search capabilities.
 */
export const zIntegerFilterProperty = z.union([
    z.int().register(z.globalRegistry, {
        description: 'Matches the value exactly.'
    }),
    zAdvancedIntegerFilter
]);

/**
 * Advanced filter
 * Advanced date-time filter.
 */
export const zAdvancedDateTimeFilter = z.object({
    '$eq': z.optional(z.iso.datetime().register(z.globalRegistry, {
        description: 'Checks for equality with the provided value.'
    })),
    '$neq': z.optional(z.iso.datetime().register(z.globalRegistry, {
        description: 'Checks for inequality with the provided value.'
    })),
    '$exists': z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Checks if the current property exists.'
    })),
    '$gt': z.optional(z.iso.datetime().register(z.globalRegistry, {
        description: 'Greater than comparison with the provided value.'
    })),
    '$gte': z.optional(z.iso.datetime().register(z.globalRegistry, {
        description: 'Greater than or equal comparison with the provided value.'
    })),
    '$lt': z.optional(z.iso.datetime().register(z.globalRegistry, {
        description: 'Lower than comparison with the provided value.'
    })),
    '$lte': z.optional(z.iso.datetime().register(z.globalRegistry, {
        description: 'Lower than or equal comparison with the provided value.'
    })),
    '$in': z.optional(z.array(z.iso.datetime()).register(z.globalRegistry, {
        description: 'Checks if the property matches any of the provided values.'
    }))
}).register(z.globalRegistry, {
    description: 'Advanced date-time filter.'
});

/**
 * Date-time property with full advanced search capabilities.
 */
export const zDateTimeFilterProperty = z.union([
    z.iso.datetime().register(z.globalRegistry, {
        description: 'Matches the value exactly.'
    }),
    zAdvancedDateTimeFilter
]);

export const zVariableValueFilterProperty = z.object({
    name: z.string().register(z.globalRegistry, {
        description: 'Name of the variable.'
    }),
    value: zStringFilterProperty
});

/**
 * User task filter request.
 */
export const zUserTaskFilter = z.object({
    state: z.optional(zUserTaskStateFilterProperty),
    assignee: z.optional(zStringFilterProperty),
    priority: z.optional(zIntegerFilterProperty),
    elementId: z.optional(zElementId),
    name: z.optional(z.string().register(z.globalRegistry, {
        description: "The task name. This only works for data created with 8.8 and onwards. Instances from prior versions don't contain this data and cannot be found.\n"
    })),
    candidateGroup: z.optional(zStringFilterProperty),
    candidateUser: z.optional(zStringFilterProperty),
    tenantId: z.optional(zStringFilterProperty),
    processDefinitionId: z.optional(zProcessDefinitionId),
    creationDate: z.optional(zDateTimeFilterProperty),
    completionDate: z.optional(zDateTimeFilterProperty),
    followUpDate: z.optional(zDateTimeFilterProperty),
    dueDate: z.optional(zDateTimeFilterProperty),
    processInstanceVariables: z.optional(z.array(zVariableValueFilterProperty).register(z.globalRegistry, {
        description: 'Process instance variables associated with the user task.'
    })),
    localVariables: z.optional(z.array(zVariableValueFilterProperty).register(z.globalRegistry, {
        description: 'Local variables associated with the user task.'
    })),
    userTaskKey: z.optional(zUserTaskKey),
    processDefinitionKey: z.optional(zProcessDefinitionKey),
    processInstanceKey: z.optional(zProcessInstanceKey),
    elementInstanceKey: z.optional(zElementInstanceKey)
}).register(z.globalRegistry, {
    description: 'User task filter request.'
});

/**
 * User task search query request.
 */
export const zUserTaskSearchQuery = zSearchQueryRequest.and(z.object({
    sort: z.optional(z.array(zUserTaskSearchQuerySortRequest).register(z.globalRegistry, {
        description: 'Sort field criteria.'
    })),
    filter: z.optional(zUserTaskFilter)
}).register(z.globalRegistry, {
    description: 'User task search query request.'
}));

export const zUserTaskVariableSearchQuerySortRequest = z.object({
    field: z.enum([
        'value',
        'name',
        'tenantId',
        'variableKey',
        'scopeKey',
        'processInstanceKey'
    ]).register(z.globalRegistry, {
        description: 'The field to sort by.'
    }),
    order: z.optional(zSortOrderEnum)
});

/**
 * The user task variable search filters.
 */
export const zUserTaskVariableFilter = z.object({
    name: z.optional(zStringFilterProperty)
}).register(z.globalRegistry, {
    description: 'The user task variable search filters.'
});

/**
 * User task search query request.
 */
export const zUserTaskVariableSearchQueryRequest = zSearchQueryRequest.and(z.object({
    sort: z.optional(z.array(zUserTaskVariableSearchQuerySortRequest).register(z.globalRegistry, {
        description: 'Sort field criteria.'
    })),
    filter: z.optional(zUserTaskVariableFilter)
}).register(z.globalRegistry, {
    description: 'User task search query request.'
}));

export const zUserTaskResult = z.object({
    name: z.optional(z.string().register(z.globalRegistry, {
        description: 'The name for this user task.'
    })),
    state: z.optional(zUserTaskStateEnum),
    assignee: z.optional(z.string().register(z.globalRegistry, {
        description: 'The assignee of the user task.'
    })),
    elementId: z.optional(zElementId),
    candidateGroups: z.optional(z.array(z.string()).register(z.globalRegistry, {
        description: 'The candidate groups for this user task.'
    })),
    candidateUsers: z.optional(z.array(z.string()).register(z.globalRegistry, {
        description: 'The candidate users for this user task.'
    })),
    processDefinitionId: z.optional(zProcessDefinitionId),
    creationDate: z.optional(z.iso.datetime().register(z.globalRegistry, {
        description: 'The creation date of a user task.'
    })),
    completionDate: z.optional(z.iso.datetime().register(z.globalRegistry, {
        description: 'The completion date of a user task.'
    })),
    followUpDate: z.optional(z.iso.datetime().register(z.globalRegistry, {
        description: 'The follow date of a user task.'
    })),
    dueDate: z.optional(z.iso.datetime().register(z.globalRegistry, {
        description: 'The due date of a user task.'
    })),
    tenantId: z.optional(zTenantId),
    externalFormReference: z.optional(z.string().register(z.globalRegistry, {
        description: 'The external form reference.'
    })),
    processDefinitionVersion: z.optional(z.int().register(z.globalRegistry, {
        description: 'The version of the process definition.'
    })),
    customHeaders: z.optional(z.record(z.string(), z.string()).register(z.globalRegistry, {
        description: 'Custom headers for the user task.'
    })),
    priority: z.optional(z.int().gte(0).lte(100).register(z.globalRegistry, {
        description: 'The priority of a user task. The higher the value the higher the priority.'
    })).default(50),
    userTaskKey: z.optional(zUserTaskKey),
    elementInstanceKey: z.optional(zElementInstanceKey),
    processName: z.optional(z.string().register(z.globalRegistry, {
        description: 'The name of the process definition.'
    })),
    processDefinitionKey: z.optional(zProcessDefinitionKey),
    processInstanceKey: z.optional(zProcessInstanceKey),
    formKey: z.optional(zFormKey)
});

/**
 * User task search query response.
 */
export const zUserTaskSearchQueryResult = zSearchQueryResponse.and(z.object({
    items: z.optional(z.array(zUserTaskResult).register(z.globalRegistry, {
        description: 'The matching user tasks.'
    }))
}).register(z.globalRegistry, {
    description: 'User task search query response.'
}));

export const zVariableSearchQuerySortRequest = z.object({
    field: z.enum([
        'value',
        'name',
        'tenantId',
        'variableKey',
        'scopeKey',
        'processInstanceKey'
    ]).register(z.globalRegistry, {
        description: 'The field to sort by.'
    }),
    order: z.optional(zSortOrderEnum)
});

/**
 * Advanced filter
 * Advanced VariableKey filter.
 */
export const zAdvancedVariableKeyFilter = z.object({
    '$eq': z.optional(zVariableKey),
    '$neq': z.optional(zVariableKey),
    '$exists': z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Checks if the current property exists.'
    })),
    '$in': z.optional(z.array(zVariableKey).register(z.globalRegistry, {
        description: 'Checks if the property matches any of the provided values.'
    })),
    '$notIn': z.optional(z.array(zVariableKey).register(z.globalRegistry, {
        description: 'Checks if the property matches none of the provided values.'
    }))
}).register(z.globalRegistry, {
    description: 'Advanced VariableKey filter.'
});

/**
 * VariableKey property with full advanced search capabilities.
 */
export const zVariableKeyFilterProperty = z.union([
    zVariableKey,
    zAdvancedVariableKeyFilter
]);

/**
 * Advanced filter
 * Advanced ScopeKey filter.
 */
export const zAdvancedScopeKeyFilter = z.object({
    '$eq': z.optional(zScopeKey),
    '$neq': z.optional(zScopeKey),
    '$exists': z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Checks if the current property exists.'
    })),
    '$in': z.optional(z.array(zScopeKey).register(z.globalRegistry, {
        description: 'Checks if the property matches any of the provided values.'
    })),
    '$notIn': z.optional(z.array(zScopeKey).register(z.globalRegistry, {
        description: 'Checks if the property matches none of the provided values.'
    }))
}).register(z.globalRegistry, {
    description: 'Advanced ScopeKey filter.'
});

/**
 * ScopeKey property with full advanced search capabilities.
 */
export const zScopeKeyFilterProperty = z.union([
    zScopeKey,
    zAdvancedScopeKeyFilter
]);

/**
 * Advanced filter
 * Advanced ProcessInstanceKey filter.
 */
export const zAdvancedProcessInstanceKeyFilter = z.object({
    '$eq': z.optional(zProcessInstanceKey),
    '$neq': z.optional(zProcessInstanceKey),
    '$exists': z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Checks if the current property exists.'
    })),
    '$in': z.optional(z.array(zProcessInstanceKey).register(z.globalRegistry, {
        description: 'Checks if the property matches any of the provided values.'
    })),
    '$notIn': z.optional(z.array(zProcessInstanceKey).register(z.globalRegistry, {
        description: 'Checks if the property matches none of the provided values.'
    }))
}).register(z.globalRegistry, {
    description: 'Advanced ProcessInstanceKey filter.'
});

/**
 * ProcessInstanceKey property with full advanced search capabilities.
 */
export const zProcessInstanceKeyFilterProperty = z.union([
    zProcessInstanceKey,
    zAdvancedProcessInstanceKeyFilter
]);

/**
 * Variable filter request.
 */
export const zVariableFilter = z.object({
    name: z.optional(zStringFilterProperty),
    value: z.optional(zStringFilterProperty),
    tenantId: z.optional(zTenantId),
    isTruncated: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Whether the value is truncated or not.'
    })),
    variableKey: z.optional(zVariableKeyFilterProperty),
    scopeKey: z.optional(zScopeKeyFilterProperty),
    processInstanceKey: z.optional(zProcessInstanceKeyFilterProperty)
}).register(z.globalRegistry, {
    description: 'Variable filter request.'
});

/**
 * Variable search query request.
 */
export const zVariableSearchQuery = zSearchQueryRequest.and(z.object({
    sort: z.optional(z.array(zVariableSearchQuerySortRequest).register(z.globalRegistry, {
        description: 'Sort field criteria.'
    })),
    filter: z.optional(zVariableFilter)
}).register(z.globalRegistry, {
    description: 'Variable search query request.'
}));

/**
 * Variable response item.
 */
export const zVariableResultBase = z.object({
    name: z.optional(z.string().register(z.globalRegistry, {
        description: 'Name of this variable.'
    })),
    tenantId: z.optional(zTenantId),
    variableKey: z.optional(zVariableKey),
    scopeKey: z.optional(zScopeKey),
    processInstanceKey: z.optional(zProcessInstanceKey)
}).register(z.globalRegistry, {
    description: 'Variable response item.'
});

/**
 * Variable search response item.
 */
export const zVariableSearchResult = zVariableResultBase.and(z.object({
    value: z.optional(z.string().register(z.globalRegistry, {
        description: 'Value of this variable. Can be truncated.'
    })),
    isTruncated: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Whether the value is truncated or not.'
    }))
}).register(z.globalRegistry, {
    description: 'Variable search response item.'
}));

/**
 * Variable search query response.
 */
export const zVariableSearchQueryResult = zSearchQueryResponse.and(z.object({
    items: z.optional(z.array(zVariableSearchResult).register(z.globalRegistry, {
        description: 'The matching variables.'
    }))
}).register(z.globalRegistry, {
    description: 'Variable search query response.'
}));

/**
 * Variable search response item.
 */
export const zVariableResult = zVariableResultBase.and(z.object({
    value: z.optional(z.string().register(z.globalRegistry, {
        description: 'Full value of this variable.'
    }))
}).register(z.globalRegistry, {
    description: 'Variable search response item.'
}));

export const zProcessDefinitionSearchQuerySortRequest = z.object({
    field: z.enum([
        'processDefinitionKey',
        'name',
        'resourceName',
        'version',
        'versionTag',
        'processDefinitionId',
        'tenantId'
    ]).register(z.globalRegistry, {
        description: 'The field to sort by.'
    }),
    order: z.optional(zSortOrderEnum)
});

/**
 * Process definition search filter.
 */
export const zProcessDefinitionFilter = z.object({
    name: z.optional(zStringFilterProperty),
    isLatestVersion: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Whether to only return the latest version of each process definition.\nWhen using this filter, pagination functionality is limited, you can only paginate forward using `after` and `limit`.\nThe response contains no `startCursor` in the `page`, and requests ignore the `from` and `before` in the `page`.\n'
    })),
    resourceName: z.optional(z.string().register(z.globalRegistry, {
        description: 'Resource name of this process definition.'
    })),
    version: z.optional(z.int().register(z.globalRegistry, {
        description: 'Version of this process definition.'
    })),
    versionTag: z.optional(z.string().register(z.globalRegistry, {
        description: 'Version tag of this process definition.'
    })),
    processDefinitionId: z.optional(zStringFilterProperty),
    tenantId: z.optional(zTenantId),
    processDefinitionKey: z.optional(zProcessDefinitionKey),
    hasStartForm: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Indicates whether the start event of the process has an associated Form Key.'
    }))
}).register(z.globalRegistry, {
    description: 'Process definition search filter.'
});

export const zProcessDefinitionSearchQuery = zSearchQueryRequest.and(z.object({
    sort: z.optional(z.array(zProcessDefinitionSearchQuerySortRequest).register(z.globalRegistry, {
        description: 'Sort field criteria.'
    })),
    filter: z.optional(zProcessDefinitionFilter)
}));

export const zProcessDefinitionResult = z.object({
    name: z.optional(z.string().register(z.globalRegistry, {
        description: 'Name of this process definition.'
    })),
    resourceName: z.optional(z.string().register(z.globalRegistry, {
        description: 'Resource name for this process definition.'
    })),
    version: z.optional(z.int().register(z.globalRegistry, {
        description: 'Version of this process definition.'
    })),
    versionTag: z.optional(z.string().register(z.globalRegistry, {
        description: 'Version tag of this process definition.'
    })),
    processDefinitionId: z.optional(zProcessDefinitionId),
    tenantId: z.optional(zTenantId),
    processDefinitionKey: z.optional(zProcessDefinitionKey),
    hasStartForm: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Indicates whether the start event of the process has an associated Form Key.'
    }))
});

export const zProcessDefinitionSearchQueryResult = zSearchQueryResponse.and(z.object({
    items: z.optional(z.array(zProcessDefinitionResult).register(z.globalRegistry, {
        description: 'The matching process definitions.'
    }))
}));

export const zProcessInstanceSearchQuerySortRequest = z.object({
    field: z.enum([
        'processInstanceKey',
        'processDefinitionId',
        'processDefinitionName',
        'processDefinitionVersion',
        'processDefinitionVersionTag',
        'processDefinitionKey',
        'parentProcessInstanceKey',
        'parentElementInstanceKey',
        'startDate',
        'endDate',
        'state',
        'hasIncident',
        'tenantId'
    ]).register(z.globalRegistry, {
        description: 'The field to sort by.'
    }),
    order: z.optional(zSortOrderEnum)
});

/**
 * Process instance states
 */
export const zProcessInstanceStateEnum = z.enum([
    'ACTIVE',
    'COMPLETED',
    'TERMINATED'
]).register(z.globalRegistry, {
    description: 'Process instance states'
});

/**
 * Advanced filter
 * Advanced ProcessInstanceStateEnum filter.
 */
export const zAdvancedProcessInstanceStateFilter = z.object({
    '$eq': z.optional(zProcessInstanceStateEnum),
    '$neq': z.optional(zProcessInstanceStateEnum),
    '$exists': z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Checks if the current property exists.'
    })),
    '$in': z.optional(z.array(zProcessInstanceStateEnum).register(z.globalRegistry, {
        description: 'Checks if the property matches any of the provided values.'
    })),
    '$like': z.optional(zLikeFilter)
}).register(z.globalRegistry, {
    description: 'Advanced ProcessInstanceStateEnum filter.'
});

/**
 * ProcessInstanceStateEnum property with full advanced search capabilities.
 */
export const zProcessInstanceStateFilterProperty = z.union([
    zProcessInstanceStateEnum,
    zAdvancedProcessInstanceStateFilter
]);

/**
 * Advanced filter
 * Advanced ElementInstanceKey filter.
 */
export const zAdvancedElementInstanceKeyFilter = z.object({
    '$eq': z.optional(zElementInstanceKey),
    '$neq': z.optional(zElementInstanceKey),
    '$exists': z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Checks if the current property exists.'
    })),
    '$in': z.optional(z.array(zElementInstanceKey).register(z.globalRegistry, {
        description: 'Checks if the property matches any of the provided values.'
    })),
    '$notIn': z.optional(z.array(zElementInstanceKey).register(z.globalRegistry, {
        description: 'Checks if the property matches none of the provided values.'
    }))
}).register(z.globalRegistry, {
    description: 'Advanced ElementInstanceKey filter.'
});

/**
 * ElementInstanceKey property with full advanced search capabilities.
 */
export const zElementInstanceKeyFilterProperty = z.union([
    zElementInstanceKey,
    zAdvancedElementInstanceKeyFilter
]);

/**
 * Element states
 */
export const zElementInstanceStateEnum = z.enum([
    'ACTIVE',
    'COMPLETED',
    'TERMINATED'
]).register(z.globalRegistry, {
    description: 'Element states'
});

/**
 * Advanced filter
 * Advanced ElementInstanceStateEnum filter.
 */
export const zAdvancedElementInstanceStateFilter = z.object({
    '$eq': z.optional(zElementInstanceStateEnum),
    '$neq': z.optional(zElementInstanceStateEnum),
    '$exists': z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Checks if the current property exists.'
    })),
    '$in': z.optional(z.array(zElementInstanceStateEnum).register(z.globalRegistry, {
        description: 'Checks if the property matches any of the provided values.'
    })),
    '$like': z.optional(zLikeFilter)
}).register(z.globalRegistry, {
    description: 'Advanced ElementInstanceStateEnum filter.'
});

/**
 * ElementInstanceStateEnum property with full advanced search capabilities.
 */
export const zElementInstanceStateFilterProperty = z.union([
    zElementInstanceStateEnum,
    zAdvancedElementInstanceStateFilter
]);

/**
 * A tag. Needs to start with a letter; then alphanumerics, `_`, `-`, `:`, or `.`; length ≤ 100.
 */
export const zTag = z.string().min(1).max(100).regex(/^[A-Za-z][A-Za-z0-9_\-:.]{0,99}$/).register(z.globalRegistry, {
    description: 'A tag. Needs to start with a letter; then alphanumerics, `_`, `-`, `:`, or `.`; length ≤ 100.'
});

/**
 * List of tags. Tags need to start with a letter; then alphanumerics, `_`, `-`, `:`, or `.`; length ≤ 100.
 */
export const zTagSet = z.array(zTag).max(10).register(z.globalRegistry, {
    description: 'List of tags. Tags need to start with a letter; then alphanumerics, `_`, `-`, `:`, or `.`; length ≤ 100.'
});

/**
 * Base process instance search filter.
 */
export const zBaseProcessInstanceFilterFields = z.object({
    startDate: z.optional(zDateTimeFilterProperty),
    endDate: z.optional(zDateTimeFilterProperty),
    state: z.optional(zProcessInstanceStateFilterProperty),
    hasIncident: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Whether this process instance has a related incident or not.'
    })),
    tenantId: z.optional(zStringFilterProperty),
    variables: z.optional(z.array(zVariableValueFilterProperty).register(z.globalRegistry, {
        description: 'The process instance variables.'
    })),
    processInstanceKey: z.optional(zProcessInstanceKeyFilterProperty),
    parentProcessInstanceKey: z.optional(zProcessInstanceKeyFilterProperty),
    parentElementInstanceKey: z.optional(zElementInstanceKeyFilterProperty),
    batchOperationId: z.optional(zStringFilterProperty),
    errorMessage: z.optional(zStringFilterProperty),
    hasRetriesLeft: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Whether the process has failed jobs with retries left.'
    })),
    elementInstanceState: z.optional(zElementInstanceStateFilterProperty),
    elementId: z.optional(zStringFilterProperty),
    hasElementInstanceIncident: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Whether the element instance has an incident or not.'
    })),
    incidentErrorHashCode: z.optional(zIntegerFilterProperty),
    tags: z.optional(zTagSet)
}).register(z.globalRegistry, {
    description: 'Base process instance search filter.'
});

/**
 * Advanced filter
 * Advanced ProcessDefinitionKey filter.
 */
export const zAdvancedProcessDefinitionKeyFilter = z.object({
    '$eq': z.optional(zProcessDefinitionKey),
    '$neq': z.optional(zProcessDefinitionKey),
    '$exists': z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Checks if the current property exists.'
    })),
    '$in': z.optional(z.array(zProcessDefinitionKey).register(z.globalRegistry, {
        description: 'Checks if the property matches any of the provided values.'
    })),
    '$notIn': z.optional(z.array(zProcessDefinitionKey).register(z.globalRegistry, {
        description: 'Checks if the property matches none of the provided values.'
    }))
}).register(z.globalRegistry, {
    description: 'Advanced ProcessDefinitionKey filter.'
});

/**
 * ProcessDefinitionKey property with full advanced search capabilities.
 */
export const zProcessDefinitionKeyFilterProperty = z.union([
    zProcessDefinitionKey,
    zAdvancedProcessDefinitionKeyFilter
]);

/**
 * Process instance search filter.
 */
export const zProcessInstanceFilterFields = zBaseProcessInstanceFilterFields.and(z.object({
    processDefinitionId: z.optional(zStringFilterProperty),
    processDefinitionName: z.optional(zStringFilterProperty),
    processDefinitionVersion: z.optional(zIntegerFilterProperty),
    processDefinitionVersionTag: z.optional(zStringFilterProperty),
    processDefinitionKey: z.optional(zProcessDefinitionKeyFilterProperty)
}).register(z.globalRegistry, {
    description: 'Process instance search filter.'
}));

/**
 * Process instance search filter.
 */
export const zProcessInstanceFilter = zProcessInstanceFilterFields.and(z.object({
    '$or': z.optional(z.array(zProcessInstanceFilterFields).register(z.globalRegistry, {
        description: 'Defines a list of alternative filter groups combined using OR logic. Each object in the array is evaluated independently, and the filter matches if any one of them is satisfied.\n\nTop-level fields and the `$or` clause are combined using AND logic — meaning: (top-level filters) AND (any of the `$or` filters) must match.\n<br>\n<em>Example:</em>\n\n```json\n{\n  "state": "ACTIVE",\n  "tenantId": 123,\n  "$or": [\n    { "processDefinitionId": "process_v1" },\n    { "processDefinitionId": "process_v2", "hasIncident": true }\n  ]\n}\n```\nThis matches process instances that:\n\n<ul style="padding-left: 20px; margin-left: 20px;">\n  <li style="list-style-type: disc;">are in <em>ACTIVE</em> state</li>\n  <li style="list-style-type: disc;">have tenant ID equal to <em>123</em></li>\n  <li style="list-style-type: disc;">and match either:\n    <ul style="padding-left: 20px; margin-left: 20px;">\n      <li style="list-style-type: circle;"><code>processDefinitionId</code> is <em>process_v1</em>, or</li>\n      <li style="list-style-type: circle;"><code>processDefinitionId</code> is <em>process_v2</em> and <code>hasIncident</code> is <em>true</em></li>\n    </ul>\n  </li>\n</ul>\n<br>\n<p>Note: Using complex <code>$or</code> conditions may impact performance, use with caution in high-volume environments.\n'
    }))
}));

/**
 * Process instance search request.
 */
export const zProcessInstanceSearchQuery = zSearchQueryRequest.and(z.object({
    sort: z.optional(z.array(zProcessInstanceSearchQuerySortRequest).register(z.globalRegistry, {
        description: 'Sort field criteria.'
    })),
    filter: z.optional(zProcessInstanceFilter)
}).register(z.globalRegistry, {
    description: 'Process instance search request.'
}));

export const zIncidentSearchQuerySortRequest = z.object({
    field: z.enum([
        'incidentKey',
        'processDefinitionKey',
        'processDefinitionId',
        'processInstanceKey',
        'errorType',
        'errorMessage',
        'elementId',
        'elementInstanceKey',
        'creationTime',
        'state',
        'jobKey',
        'tenantId'
    ]).register(z.globalRegistry, {
        description: 'The field to sort by.'
    }),
    order: z.optional(zSortOrderEnum)
});

export const zProcessInstanceIncidentSearchQuery = zSearchQueryRequest.and(z.object({
    sort: z.optional(z.array(zIncidentSearchQuerySortRequest).register(z.globalRegistry, {
        description: 'Sort field criteria.'
    }))
}));

/**
 * Advanced filter
 * Advanced DecisionDefinitionKey filter.
 */
export const zAdvancedDecisionDefinitionKeyFilter = z.object({
    '$eq': z.optional(zDecisionDefinitionKey),
    '$neq': z.optional(zDecisionDefinitionKey),
    '$exists': z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Checks if the current property exists.'
    })),
    '$in': z.optional(z.array(zDecisionDefinitionKey).register(z.globalRegistry, {
        description: 'Checks if the property matches any of the provided values.'
    })),
    '$notIn': z.optional(z.array(zDecisionDefinitionKey).register(z.globalRegistry, {
        description: 'Checks if the property matches none of the provided values.'
    }))
}).register(z.globalRegistry, {
    description: 'Advanced DecisionDefinitionKey filter.'
});

/**
 * DecisionDefinitionKey property with full advanced search capabilities.
 */
export const zDecisionDefinitionKeyFilterProperty = z.union([
    zDecisionDefinitionKey,
    zAdvancedDecisionDefinitionKeyFilter
]);

/**
 * String property with basic advanced search capabilities.
 */
export const zBasicStringFilterProperty = z.union([
    z.string().register(z.globalRegistry, {
        description: 'Matches the value exactly.'
    }),
    zBasicStringFilter
]);

/**
 * Advanced filter
 * Advanced MessageSubscriptionKey filter.
 */
export const zAdvancedMessageSubscriptionKeyFilter = z.object({
    '$eq': z.optional(zMessageSubscriptionKey),
    '$neq': z.optional(zMessageSubscriptionKey),
    '$exists': z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Checks if the current property exists.'
    })),
    '$in': z.optional(z.array(zMessageSubscriptionKey).register(z.globalRegistry, {
        description: 'Checks if the property matches any of the provided values.'
    })),
    '$notIn': z.optional(z.array(zMessageSubscriptionKey).register(z.globalRegistry, {
        description: 'Checks if the property matches none of the provided values.'
    }))
}).register(z.globalRegistry, {
    description: 'Advanced MessageSubscriptionKey filter.'
});

/**
 * MessageSubscriptionKey property with full advanced search capabilities.
 */
export const zMessageSubscriptionKeyFilterProperty = z.union([
    zMessageSubscriptionKey,
    zAdvancedMessageSubscriptionKeyFilter
]);

/**
 * Advanced filter
 * Advanced JobKey filter.
 */
export const zAdvancedJobKeyFilter = z.object({
    '$eq': z.optional(zJobKey),
    '$neq': z.optional(zJobKey),
    '$exists': z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Checks if the current property exists.'
    })),
    '$in': z.optional(z.array(zJobKey).register(z.globalRegistry, {
        description: 'Checks if the property matches any of the provided values.'
    })),
    '$notIn': z.optional(z.array(zJobKey).register(z.globalRegistry, {
        description: 'Checks if the property matches none of the provided values.'
    }))
}).register(z.globalRegistry, {
    description: 'Advanced JobKey filter.'
});

/**
 * JobKey property with full advanced search capabilities.
 */
export const zJobKeyFilterProperty = z.union([
    zJobKey,
    zAdvancedJobKeyFilter
]);

/**
 * Process definition statistics search filter.
 */
export const zProcessDefinitionStatisticsFilter = zBaseProcessInstanceFilterFields.and(z.object({
    '$or': z.optional(z.array(zBaseProcessInstanceFilterFields).register(z.globalRegistry, {
        description: 'Defines a list of alternative filter groups combined using OR logic. Each object in the array is evaluated independently, and the filter matches if any one of them is satisfied.\n\nTop-level fields and the `$or` clause are combined using AND logic — meaning: (top-level filters) AND (any of the `$or` filters) must match.\n<br>\n<em>Example:</em>\n\n```json\n{\n  "state": "ACTIVE",\n  "tenantId": 123,\n  "$or": [\n    { "processDefinitionId": "process_v1" },\n    { "processDefinitionId": "process_v2", "hasIncident": true }\n  ]\n}\n```\nThis matches process instances that:\n\n<ul style="padding-left: 20px; margin-left: 20px;">\n  <li style="list-style-type: disc;">are in <em>ACTIVE</em> state</li>\n  <li style="list-style-type: disc;">have tenant ID equal to <em>123</em></li>\n  <li style="list-style-type: disc;">and match either:\n    <ul style="padding-left: 20px; margin-left: 20px;">\n      <li style="list-style-type: circle;"><code>processDefinitionId</code> is <em>process_v1</em>, or</li>\n      <li style="list-style-type: circle;"><code>processDefinitionId</code> is <em>process_v2</em> and <code>hasIncident</code> is <em>true</em></li>\n    </ul>\n  </li>\n</ul>\n<br>\n<p>Note: Using complex <code>$or</code> conditions may impact performance, use with caution in high-volume environments.\n'
    }))
}));

/**
 * Process instance search response item.
 */
export const zProcessInstanceResult = z.object({
    processDefinitionId: zProcessDefinitionId,
    processDefinitionName: z.string().register(z.globalRegistry, {
        description: 'The process definition name.'
    }),
    processDefinitionVersion: z.int().register(z.globalRegistry, {
        description: 'The process definition version.'
    }),
    processDefinitionVersionTag: z.optional(z.string().register(z.globalRegistry, {
        description: 'The process definition version tag.'
    })),
    startDate: z.iso.datetime().register(z.globalRegistry, {
        description: 'The start date.'
    }),
    endDate: z.optional(z.iso.datetime().register(z.globalRegistry, {
        description: 'The end date.'
    })),
    state: zProcessInstanceStateEnum,
    hasIncident: z.boolean().register(z.globalRegistry, {
        description: 'Whether this process instance has a related incident or not.'
    }),
    tenantId: zTenantId,
    processInstanceKey: zProcessInstanceKey,
    processDefinitionKey: zProcessDefinitionKey,
    parentProcessInstanceKey: z.optional(zProcessInstanceKey),
    parentElementInstanceKey: z.optional(zElementInstanceKey),
    tags: z.optional(zTagSet)
}).register(z.globalRegistry, {
    description: 'Process instance search response item.'
});

/**
 * Process instance search response.
 */
export const zProcessInstanceSearchQueryResult = zSearchQueryResponse.and(z.object({
    items: z.array(zProcessInstanceResult).register(z.globalRegistry, {
        description: 'The matching process instances.'
    })
}).register(z.globalRegistry, {
    description: 'Process instance search response.'
}));

export const zProcessInstanceCallHierarchyEntry = z.object({
    processInstanceKey: zProcessInstanceKey,
    processDefinitionKey: zProcessDefinitionKey,
    processDefinitionName: z.string().register(z.globalRegistry, {
        description: 'The name of the process definition (fall backs to the process definition ID if not available).'
    })
});

/**
 * Process instance sequence flow result.
 */
export const zProcessInstanceSequenceFlowResult = z.object({
    sequenceFlowId: z.optional(z.string().register(z.globalRegistry, {
        description: 'The sequence flow ID.'
    })),
    processInstanceKey: z.optional(zProcessInstanceKey),
    processDefinitionKey: z.optional(zProcessDefinitionKey),
    processDefinitionId: z.optional(zProcessDefinitionId),
    elementId: z.optional(zElementId),
    tenantId: z.optional(zTenantId)
}).register(z.globalRegistry, {
    description: 'Process instance sequence flow result.'
});

/**
 * Process instance sequence flows query response.
 */
export const zProcessInstanceSequenceFlowsQueryResult = z.object({
    items: z.optional(z.array(zProcessInstanceSequenceFlowResult).register(z.globalRegistry, {
        description: 'The sequence flows.'
    }))
}).register(z.globalRegistry, {
    description: 'Process instance sequence flows query response.'
});

/**
 * Process definition element statistics request.
 */
export const zProcessDefinitionElementStatisticsQuery = z.object({
    filter: z.optional(zProcessDefinitionStatisticsFilter)
}).register(z.globalRegistry, {
    description: 'Process definition element statistics request.'
});

/**
 * Process element statistics response.
 */
export const zProcessElementStatisticsResult = z.object({
    elementId: z.optional(zElementId),
    active: z.optional(z.coerce.bigint().register(z.globalRegistry, {
        description: 'The total number of active instances of the element.'
    })),
    canceled: z.optional(z.coerce.bigint().register(z.globalRegistry, {
        description: 'The total number of canceled instances of the element.'
    })),
    incidents: z.optional(z.coerce.bigint().register(z.globalRegistry, {
        description: 'The total number of incidents for the element.'
    })),
    completed: z.optional(z.coerce.bigint().register(z.globalRegistry, {
        description: 'The total number of completed instances of the element.'
    }))
}).register(z.globalRegistry, {
    description: 'Process element statistics response.'
});

/**
 * Process definition element statistics query response.
 */
export const zProcessDefinitionElementStatisticsQueryResult = z.object({
    items: z.optional(z.array(zProcessElementStatisticsResult).register(z.globalRegistry, {
        description: 'The element statistics.'
    }))
}).register(z.globalRegistry, {
    description: 'Process definition element statistics query response.'
});

/**
 * Process instance element statistics query response.
 */
export const zProcessInstanceElementStatisticsQueryResult = z.object({
    items: z.optional(z.array(zProcessElementStatisticsResult).register(z.globalRegistry, {
        description: 'The element statistics.'
    }))
}).register(z.globalRegistry, {
    description: 'Process instance element statistics query response.'
});

/**
 * A reference key chosen by the user that will be part of all records resulting from this operation.
 * Must be > 0 if provided.
 *
 */
export const zOperationReference = z.coerce.bigint().gte(BigInt(1)).register(z.globalRegistry, {
    description: 'A reference key chosen by the user that will be part of all records resulting from this operation.\nMust be > 0 if provided.\n'
});

export const zCancelProcessInstanceRequest = z.union([
    z.object({
        operationReference: z.optional(zOperationReference)
    }),
    z.null()
]);

export const zElementInstanceSearchQuerySortRequest = z.object({
    field: z.enum([
        'elementInstanceKey',
        'processInstanceKey',
        'processDefinitionKey',
        'processDefinitionId',
        'startDate',
        'endDate',
        'elementId',
        'elementName',
        'type',
        'state',
        'incidentKey',
        'tenantId'
    ]).register(z.globalRegistry, {
        description: 'The field to sort by.'
    }),
    order: z.optional(zSortOrderEnum)
});

/**
 * Element instance filter.
 */
export const zElementInstanceFilter = z.object({
    processDefinitionId: z.optional(zProcessDefinitionId),
    state: z.optional(zElementInstanceStateFilterProperty),
    type: z.optional(z.enum([
        'UNSPECIFIED',
        'PROCESS',
        'SUB_PROCESS',
        'EVENT_SUB_PROCESS',
        'AD_HOC_SUB_PROCESS',
        'AD_HOC_SUB_PROCESS_INNER_INSTANCE',
        'START_EVENT',
        'INTERMEDIATE_CATCH_EVENT',
        'INTERMEDIATE_THROW_EVENT',
        'BOUNDARY_EVENT',
        'END_EVENT',
        'SERVICE_TASK',
        'RECEIVE_TASK',
        'USER_TASK',
        'MANUAL_TASK',
        'TASK',
        'EXCLUSIVE_GATEWAY',
        'INCLUSIVE_GATEWAY',
        'PARALLEL_GATEWAY',
        'EVENT_BASED_GATEWAY',
        'SEQUENCE_FLOW',
        'MULTI_INSTANCE_BODY',
        'CALL_ACTIVITY',
        'BUSINESS_RULE_TASK',
        'SCRIPT_TASK',
        'SEND_TASK',
        'UNKNOWN'
    ]).register(z.globalRegistry, {
        description: 'Type of element as defined set of values.'
    })),
    elementId: z.optional(zElementId),
    elementName: z.optional(z.string().register(z.globalRegistry, {
        description: "The element name. This only works for data created with 8.8 and onwards. Instances from prior versions don't contain this data and cannot be found.\n"
    })),
    hasIncident: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Shows whether this element instance has an incident related to.'
    })),
    tenantId: z.optional(zTenantId),
    elementInstanceKey: z.optional(zElementInstanceKey),
    processInstanceKey: z.optional(zProcessInstanceKey),
    processDefinitionKey: z.optional(zProcessDefinitionKey),
    incidentKey: z.optional(zIncidentKey),
    startDate: z.optional(zDateTimeFilterProperty),
    endDate: z.optional(zDateTimeFilterProperty),
    elementInstanceScopeKey: z.optional(z.union([
        zElementInstanceKey,
        zProcessInstanceKey
    ]))
}).register(z.globalRegistry, {
    description: 'Element instance filter.'
});

/**
 * Element instance search request.
 */
export const zElementInstanceSearchQuery = zSearchQueryRequest.and(z.object({
    sort: z.optional(z.array(zElementInstanceSearchQuerySortRequest).register(z.globalRegistry, {
        description: 'Sort field criteria.'
    })),
    filter: z.optional(zElementInstanceFilter)
}).register(z.globalRegistry, {
    description: 'Element instance search request.'
}));

export const zElementInstanceResult = z.object({
    processDefinitionId: zProcessDefinitionId,
    startDate: z.iso.datetime().register(z.globalRegistry, {
        description: 'Date when element instance started.'
    }),
    endDate: z.optional(z.iso.datetime().register(z.globalRegistry, {
        description: 'Date when element instance finished.'
    })),
    elementId: zElementId,
    elementName: z.string().register(z.globalRegistry, {
        description: 'The element name for this element instance.'
    }),
    type: z.enum([
        'UNSPECIFIED',
        'PROCESS',
        'SUB_PROCESS',
        'EVENT_SUB_PROCESS',
        'AD_HOC_SUB_PROCESS',
        'AD_HOC_SUB_PROCESS_INNER_INSTANCE',
        'START_EVENT',
        'INTERMEDIATE_CATCH_EVENT',
        'INTERMEDIATE_THROW_EVENT',
        'BOUNDARY_EVENT',
        'END_EVENT',
        'SERVICE_TASK',
        'RECEIVE_TASK',
        'USER_TASK',
        'MANUAL_TASK',
        'TASK',
        'EXCLUSIVE_GATEWAY',
        'INCLUSIVE_GATEWAY',
        'PARALLEL_GATEWAY',
        'EVENT_BASED_GATEWAY',
        'SEQUENCE_FLOW',
        'MULTI_INSTANCE_BODY',
        'CALL_ACTIVITY',
        'BUSINESS_RULE_TASK',
        'SCRIPT_TASK',
        'SEND_TASK',
        'UNKNOWN'
    ]).register(z.globalRegistry, {
        description: 'Type of element as defined set of values.'
    }),
    state: zElementInstanceStateEnum,
    hasIncident: z.boolean().register(z.globalRegistry, {
        description: 'Shows whether this element instance has an incident. If true also an incidentKey is provided.'
    }),
    tenantId: zTenantId,
    elementInstanceKey: zElementInstanceKey,
    processInstanceKey: zProcessInstanceKey,
    processDefinitionKey: zProcessDefinitionKey,
    incidentKey: z.optional(zIncidentKey)
});

export const zElementInstanceSearchQueryResult = zSearchQueryResponse.and(z.object({
    items: z.optional(z.array(zElementInstanceResult).register(z.globalRegistry, {
        description: 'The matching element instances.'
    }))
}));

export const zAdHocSubProcessActivateActivityReference = z.object({
    elementId: zElementId,
    variables: z.optional(z.record(z.string(), z.unknown()).register(z.globalRegistry, {
        description: 'Variables to be set when activating the element.'
    }))
});

export const zAdHocSubProcessActivateActivitiesInstruction = z.object({
    elements: z.array(zAdHocSubProcessActivateActivityReference).register(z.globalRegistry, {
        description: 'Activities to activate.'
    }),
    cancelRemainingInstances: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Whether to cancel remaining instances of the ad-hoc sub-process.'
    })).default(false)
});

export const zDecisionDefinitionSearchQuerySortRequest = z.object({
    field: z.enum([
        'decisionDefinitionKey',
        'decisionDefinitionId',
        'name',
        'version',
        'decisionRequirementsId',
        'decisionRequirementsKey',
        'tenantId'
    ]).register(z.globalRegistry, {
        description: 'The field to sort by.'
    }),
    order: z.optional(zSortOrderEnum)
});

/**
 * Decision definition search filter.
 */
export const zDecisionDefinitionFilter = z.object({
    decisionDefinitionId: z.optional(zDecisionDefinitionId),
    name: z.optional(z.string().register(z.globalRegistry, {
        description: 'The DMN name of the decision definition.'
    })),
    version: z.optional(z.int().register(z.globalRegistry, {
        description: 'The assigned version of the decision definition.'
    })),
    decisionRequirementsId: z.optional(z.string().register(z.globalRegistry, {
        description: 'the DMN ID of the decision requirements graph that the decision definition is part of.'
    })),
    tenantId: z.optional(zTenantId),
    decisionDefinitionKey: z.optional(zDecisionDefinitionKey),
    decisionRequirementsKey: z.optional(zDecisionRequirementsKey)
}).register(z.globalRegistry, {
    description: 'Decision definition search filter.'
});

export const zDecisionDefinitionSearchQuery = zSearchQueryRequest.and(z.object({
    sort: z.optional(z.array(zDecisionDefinitionSearchQuerySortRequest).register(z.globalRegistry, {
        description: 'Sort field criteria.'
    })),
    filter: z.optional(zDecisionDefinitionFilter)
}));

/**
 * Incident search filter.
 */
export const zIncidentFilter = z.object({
    processDefinitionId: z.optional(zProcessDefinitionId),
    errorType: z.optional(z.enum([
        'UNSPECIFIED',
        'UNKNOWN',
        'IO_MAPPING_ERROR',
        'JOB_NO_RETRIES',
        'EXECUTION_LISTENER_NO_RETRIES',
        'TASK_LISTENER_NO_RETRIES',
        'AD_HOC_SUB_PROCESS_NO_RETRIES',
        'CONDITION_ERROR',
        'EXTRACT_VALUE_ERROR',
        'CALLED_ELEMENT_ERROR',
        'UNHANDLED_ERROR_EVENT',
        'MESSAGE_SIZE_EXCEEDED',
        'CALLED_DECISION_ERROR',
        'DECISION_EVALUATION_ERROR',
        'FORM_NOT_FOUND',
        'RESOURCE_NOT_FOUND'
    ]).register(z.globalRegistry, {
        description: 'Incident error type with a defined set of values.'
    })),
    errorMessage: z.optional(z.string().register(z.globalRegistry, {
        description: 'Error message which describes the error in more detail.'
    })),
    elementId: z.optional(zElementId),
    creationTime: z.optional(z.iso.datetime().register(z.globalRegistry, {
        description: 'Date of incident creation.'
    })),
    state: z.optional(z.enum([
        'ACTIVE',
        'MIGRATED',
        'RESOLVED',
        'PENDING'
    ]).register(z.globalRegistry, {
        description: 'State of this incident with a defined set of values.'
    })),
    tenantId: z.optional(zTenantId),
    incidentKey: z.optional(zIncidentKey),
    processDefinitionKey: z.optional(zProcessDefinitionKey),
    processInstanceKey: z.optional(zProcessInstanceKey),
    elementInstanceKey: z.optional(zElementInstanceKey),
    jobKey: z.optional(zJobKey)
}).register(z.globalRegistry, {
    description: 'Incident search filter.'
});

export const zIncidentSearchQuery = zSearchQueryRequest.and(z.object({
    sort: z.optional(z.array(zIncidentSearchQuerySortRequest).register(z.globalRegistry, {
        description: 'Sort field criteria.'
    })),
    filter: z.optional(zIncidentFilter)
}));

export const zIncidentResult = z.object({
    processDefinitionId: z.optional(zProcessDefinitionId),
    errorType: z.optional(z.enum([
        'UNSPECIFIED',
        'UNKNOWN',
        'IO_MAPPING_ERROR',
        'JOB_NO_RETRIES',
        'EXECUTION_LISTENER_NO_RETRIES',
        'TASK_LISTENER_NO_RETRIES',
        'AD_HOC_SUB_PROCESS_NO_RETRIES',
        'CONDITION_ERROR',
        'EXTRACT_VALUE_ERROR',
        'CALLED_ELEMENT_ERROR',
        'UNHANDLED_ERROR_EVENT',
        'MESSAGE_SIZE_EXCEEDED',
        'CALLED_DECISION_ERROR',
        'DECISION_EVALUATION_ERROR',
        'FORM_NOT_FOUND',
        'RESOURCE_NOT_FOUND'
    ]).register(z.globalRegistry, {
        description: 'Incident error type with a defined set of values.'
    })),
    errorMessage: z.optional(z.string().register(z.globalRegistry, {
        description: 'Error message which describes the error in more detail.'
    })),
    elementId: z.optional(zElementId),
    creationTime: z.optional(z.iso.datetime().register(z.globalRegistry, {
        description: 'Date of incident creation.'
    })),
    state: z.optional(z.enum([
        'ACTIVE',
        'MIGRATED',
        'RESOLVED',
        'PENDING'
    ]).register(z.globalRegistry, {
        description: 'State of this incident with a defined set of values.'
    })),
    tenantId: z.optional(zTenantId),
    incidentKey: z.optional(zIncidentKey),
    processDefinitionKey: z.optional(zProcessDefinitionKey),
    processInstanceKey: z.optional(zProcessInstanceKey),
    elementInstanceKey: z.optional(zElementInstanceKey),
    jobKey: z.optional(zJobKey)
});

export const zIncidentSearchQueryResult = zSearchQueryResponse.and(z.object({
    items: z.optional(z.array(zIncidentResult).register(z.globalRegistry, {
        description: 'The matching incidents.'
    }))
}));

export const zCorrelatedMessageSubscriptionResult = z.object({
    correlationKey: z.string().register(z.globalRegistry, {
        description: 'The correlation key of the message.'
    }),
    correlationTime: z.iso.datetime().register(z.globalRegistry, {
        description: 'The time when the message was correlated.'
    }),
    elementId: z.string().register(z.globalRegistry, {
        description: 'The element ID that received the message.'
    }),
    elementInstanceKey: z.optional(zElementInstanceKey),
    messageKey: zMessageKey,
    messageName: z.string().register(z.globalRegistry, {
        description: 'The name of the message.'
    }),
    partitionId: z.int().register(z.globalRegistry, {
        description: 'The partition ID that correlated the message.'
    }),
    processDefinitionId: zProcessDefinitionId,
    processDefinitionKey: z.optional(zProcessDefinitionKey),
    processInstanceKey: zProcessInstanceKey,
    subscriptionKey: zMessageSubscriptionKey,
    tenantId: zTenantId
});

export const zCorrelatedMessageSubscriptionSearchQueryResult = zSearchQueryResponse.and(z.object({
    items: z.optional(z.array(zCorrelatedMessageSubscriptionResult).register(z.globalRegistry, {
        description: 'The matching correlated message subscriptions.'
    }))
}));

export const zCorrelatedMessageSubscriptionSearchQuerySortRequest = z.object({
    field: z.enum([
        'correlationKey',
        'correlationTime',
        'elementId',
        'elementInstanceKey',
        'messageKey',
        'messageName',
        'partitionId',
        'processDefinitionId',
        'processDefinitionKey',
        'processInstanceKey',
        'subscriptionKey',
        'tenantId'
    ]).register(z.globalRegistry, {
        description: 'The field to sort by.'
    }),
    order: z.optional(zSortOrderEnum)
});

/**
 * Correlated message subscriptions search filter.
 */
export const zCorrelatedMessageSubscriptionFilter = z.object({
    correlationKey: z.optional(zStringFilterProperty),
    correlationTime: z.optional(zDateTimeFilterProperty),
    elementId: z.optional(zStringFilterProperty),
    elementInstanceKey: z.optional(zElementInstanceKeyFilterProperty),
    messageKey: z.optional(zBasicStringFilterProperty),
    messageName: z.optional(zStringFilterProperty),
    partitionId: z.optional(zIntegerFilterProperty),
    processDefinitionId: z.optional(zStringFilterProperty),
    processDefinitionKey: z.optional(zBasicStringFilterProperty),
    processInstanceKey: z.optional(zBasicStringFilterProperty),
    subscriptionKey: z.optional(zBasicStringFilterProperty),
    tenantId: z.optional(zStringFilterProperty)
}).register(z.globalRegistry, {
    description: 'Correlated message subscriptions search filter.'
});

export const zCorrelatedMessageSubscriptionSearchQuery = zSearchQueryRequest.and(z.object({
    sort: z.optional(z.array(zCorrelatedMessageSubscriptionSearchQuerySortRequest).register(z.globalRegistry, {
        description: 'Sort field criteria.'
    })),
    filter: z.optional(zCorrelatedMessageSubscriptionFilter)
}));

/**
 * The state of message subscription.
 */
export const zMessageSubscriptionStateEnum = z.enum([
    'CORRELATED',
    'CREATED',
    'DELETED',
    'MIGRATED'
]).register(z.globalRegistry, {
    description: 'The state of message subscription.'
});

export const zMessageSubscriptionResult = z.object({
    messageSubscriptionKey: z.optional(zMessageSubscriptionKey),
    processDefinitionId: z.optional(zProcessDefinitionId),
    processDefinitionKey: z.optional(zProcessDefinitionKey),
    processInstanceKey: z.optional(zProcessInstanceKey),
    elementId: z.optional(zElementId),
    elementInstanceKey: z.optional(zElementInstanceKey),
    messageSubscriptionState: z.optional(zMessageSubscriptionStateEnum),
    lastUpdatedDate: z.optional(z.iso.datetime().register(z.globalRegistry, {
        description: 'The last updated date of the message subscription.'
    })),
    messageName: z.optional(z.string().register(z.globalRegistry, {
        description: 'The name of the message associated with the message subscription.'
    })),
    correlationKey: z.optional(zMessageCorrelationKey),
    tenantId: z.optional(zTenantId)
});

export const zMessageSubscriptionSearchQueryResult = zSearchQueryResponse.and(z.object({
    items: z.optional(z.array(zMessageSubscriptionResult).register(z.globalRegistry, {
        description: 'The matching message subscriptions.'
    }))
}));

export const zMessageSubscriptionSearchQuerySortRequest = z.object({
    field: z.enum([
        'messageSubscriptionKey',
        'processDefinitionId',
        'processInstanceKey',
        'elementId',
        'elementInstanceKey',
        'messageSubscriptionState',
        'lastUpdatedDate',
        'messageName',
        'correlationKey',
        'tenantId'
    ]).register(z.globalRegistry, {
        description: 'The field to sort by.'
    }),
    order: z.optional(zSortOrderEnum)
});

/**
 * Advanced filter
 * Advanced MessageSubscriptionStateEnum filter
 */
export const zAdvancedMessageSubscriptionStateFilter = z.object({
    '$eq': z.optional(zMessageSubscriptionStateEnum),
    '$neq': z.optional(zMessageSubscriptionStateEnum),
    '$exists': z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Checks if the current property exists.'
    })),
    '$in': z.optional(z.array(zMessageSubscriptionStateEnum).register(z.globalRegistry, {
        description: 'Checks if the property matches any of the provided values.'
    })),
    '$like': z.optional(zLikeFilter)
}).register(z.globalRegistry, {
    description: 'Advanced MessageSubscriptionStateEnum filter'
});

/**
 * MessageSubscriptionStateEnum with full advanced search capabilities.
 */
export const zMessageSubscriptionStateFilterProperty = z.union([
    zMessageSubscriptionStateEnum,
    zAdvancedMessageSubscriptionStateFilter
]);

/**
 * Message subscription search filter.
 */
export const zMessageSubscriptionFilter = z.object({
    messageSubscriptionKey: z.optional(zMessageSubscriptionKeyFilterProperty),
    processDefinitionId: z.optional(zStringFilterProperty),
    processInstanceKey: z.optional(zProcessInstanceKeyFilterProperty),
    elementId: z.optional(zStringFilterProperty),
    elementInstanceKey: z.optional(zElementInstanceKeyFilterProperty),
    messageSubscriptionState: z.optional(zMessageSubscriptionStateFilterProperty),
    lastUpdatedDate: z.optional(zDateTimeFilterProperty),
    messageName: z.optional(zStringFilterProperty),
    correlationKey: z.optional(zStringFilterProperty),
    tenantId: z.optional(zStringFilterProperty)
}).register(z.globalRegistry, {
    description: 'Message subscription search filter.'
});

export const zMessageSubscriptionSearchQuery = zSearchQueryRequest.and(z.object({
    sort: z.optional(z.array(zMessageSubscriptionSearchQuerySortRequest).register(z.globalRegistry, {
        description: 'Sort field criteria.'
    })),
    filter: z.optional(zMessageSubscriptionFilter)
}));

export const zDecisionDefinitionResult = z.object({
    decisionDefinitionId: z.optional(zDecisionDefinitionId),
    name: z.optional(z.string().register(z.globalRegistry, {
        description: 'The DMN name of the decision definition.'
    })),
    version: z.optional(z.int().register(z.globalRegistry, {
        description: 'The assigned version of the decision definition.'
    })),
    decisionRequirementsId: z.optional(z.string().register(z.globalRegistry, {
        description: 'the DMN ID of the decision requirements graph that the decision definition is part of.'
    })),
    tenantId: z.optional(zTenantId),
    decisionDefinitionKey: z.optional(zDecisionDefinitionKey),
    decisionRequirementsKey: z.optional(zDecisionRequirementsKey)
});

export const zDecisionDefinitionSearchQueryResult = zSearchQueryResponse.and(z.object({
    items: z.optional(z.array(zDecisionDefinitionResult).register(z.globalRegistry, {
        description: 'The matching decision definitions.'
    }))
}));

export const zUsageMetricsResponseItem = z.object({
    processInstances: z.optional(z.coerce.bigint().register(z.globalRegistry, {
        description: 'The amount of created root process instances.'
    })),
    decisionInstances: z.optional(z.coerce.bigint().register(z.globalRegistry, {
        description: 'The amount of executed decision instances.'
    })),
    assignees: z.optional(z.coerce.bigint().register(z.globalRegistry, {
        description: 'The amount of unique active task users.'
    }))
});

export const zUsageMetricsResponse = zUsageMetricsResponseItem.and(z.object({
    activeTenants: z.optional(z.coerce.bigint().register(z.globalRegistry, {
        description: 'The amount of active tenants.'
    })),
    tenants: z.optional(z.record(z.string(), zUsageMetricsResponseItem).register(z.globalRegistry, {
        description: 'The usage metrics by tenants. Only available if request `withTenants` query parameter was `true`.'
    }))
}));

/**
 * Specifies the type of permissions.
 */
export const zPermissionTypeEnum = z.enum([
    'ACCESS',
    'CREATE',
    'CREATE_BATCH_OPERATION_CANCEL_PROCESS_INSTANCE',
    'CREATE_BATCH_OPERATION_DELETE_PROCESS_INSTANCE',
    'CREATE_BATCH_OPERATION_MIGRATE_PROCESS_INSTANCE',
    'CREATE_BATCH_OPERATION_MODIFY_PROCESS_INSTANCE',
    'CREATE_BATCH_OPERATION_RESOLVE_INCIDENT',
    'CREATE_BATCH_OPERATION_DELETE_DECISION_INSTANCE',
    'CREATE_BATCH_OPERATION_DELETE_DECISION_DEFINITION',
    'CREATE_BATCH_OPERATION_DELETE_PROCESS_DEFINITION',
    'CREATE_PROCESS_INSTANCE',
    'CREATE_DECISION_INSTANCE',
    'READ',
    'READ_PROCESS_INSTANCE',
    'READ_USER_TASK',
    'READ_DECISION_INSTANCE',
    'READ_PROCESS_DEFINITION',
    'READ_DECISION_DEFINITION',
    'READ_USAGE_METRIC',
    'UPDATE',
    'UPDATE_PROCESS_INSTANCE',
    'UPDATE_USER_TASK',
    'CANCEL_PROCESS_INSTANCE',
    'MODIFY_PROCESS_INSTANCE',
    'DELETE',
    'DELETE_PROCESS',
    'DELETE_DRD',
    'DELETE_FORM',
    'DELETE_RESOURCE',
    'DELETE_PROCESS_INSTANCE',
    'DELETE_DECISION_INSTANCE'
]).register(z.globalRegistry, {
    description: 'Specifies the type of permissions.'
});

/**
 * The type of resource to add/remove permissions to/from.
 */
export const zResourceTypeEnum = z.enum([
    'AUTHORIZATION',
    'MAPPING_RULE',
    'MESSAGE',
    'BATCH',
    'COMPONENT',
    'SYSTEM',
    'TENANT',
    'RESOURCE',
    'PROCESS_DEFINITION',
    'DECISION_REQUIREMENTS_DEFINITION',
    'DECISION_DEFINITION',
    'GROUP',
    'USER',
    'ROLE',
    'DOCUMENT'
]).register(z.globalRegistry, {
    description: 'The type of resource to add/remove permissions to/from.'
});

/**
 * The type of the owner of permissions.
 */
export const zOwnerTypeEnum = z.enum([
    'USER',
    'CLIENT',
    'ROLE',
    'GROUP',
    'MAPPING_RULE',
    'UNSPECIFIED'
]).register(z.globalRegistry, {
    description: 'The type of the owner of permissions.'
});

export const zAuthorizationRequest = z.object({
    ownerId: z.string().register(z.globalRegistry, {
        description: 'The ID of the owner of the permissions.'
    }),
    ownerType: zOwnerTypeEnum,
    resourceId: z.string().register(z.globalRegistry, {
        description: 'The ID of the resource to add permissions to.'
    }),
    resourceType: zResourceTypeEnum,
    permissionTypes: z.array(zPermissionTypeEnum).register(z.globalRegistry, {
        description: 'The permission types to add.'
    })
});

export const zAuthorizationCreateResult = z.object({
    authorizationKey: z.optional(zAuthorizationKey)
});

export const zAuthorizationSearchQuerySortRequest = z.object({
    field: z.enum([
        'ownerId',
        'ownerType',
        'resourceId',
        'resourceType'
    ]).register(z.globalRegistry, {
        description: 'The field to sort by.'
    }),
    order: z.optional(zSortOrderEnum)
});

/**
 * Authorization search filter.
 */
export const zAuthorizationFilter = z.object({
    ownerId: z.optional(z.string().register(z.globalRegistry, {
        description: 'The ID of the owner of permissions.'
    })),
    ownerType: z.optional(zOwnerTypeEnum),
    resourceIds: z.optional(z.array(z.string()).register(z.globalRegistry, {
        description: 'The IDs of the resource to search permissions for.'
    })),
    resourceType: z.optional(zResourceTypeEnum)
}).register(z.globalRegistry, {
    description: 'Authorization search filter.'
});

export const zAuthorizationSearchQuery = zSearchQueryRequest.and(z.object({
    sort: z.optional(z.array(zAuthorizationSearchQuerySortRequest).register(z.globalRegistry, {
        description: 'Sort field criteria.'
    })),
    filter: z.optional(zAuthorizationFilter)
}));

export const zAuthorizationResult = z.object({
    ownerId: z.optional(z.string().register(z.globalRegistry, {
        description: 'The ID of the owner of permissions.'
    })),
    ownerType: z.optional(zOwnerTypeEnum),
    resourceType: z.optional(zResourceTypeEnum),
    resourceId: z.optional(z.string().register(z.globalRegistry, {
        description: 'ID of the resource the permission relates to.'
    })),
    permissionTypes: z.optional(z.array(zPermissionTypeEnum).register(z.globalRegistry, {
        description: 'Specifies the types of the permissions.'
    })),
    authorizationKey: z.optional(zAuthorizationKey)
});

export const zAuthorizationSearchResult = zSearchQueryResponse.and(z.object({
    items: z.optional(z.array(zAuthorizationResult).register(z.globalRegistry, {
        description: 'The matching authorizations.'
    }))
}));

export const zUserRequest = z.object({
    password: z.string().register(z.globalRegistry, {
        description: 'The password of the user.'
    }),
    username: z.string().register(z.globalRegistry, {
        description: 'The username of the user.'
    }),
    name: z.optional(z.string().register(z.globalRegistry, {
        description: 'The name of the user.'
    })),
    email: z.optional(z.string().register(z.globalRegistry, {
        description: 'The email of the user.'
    }))
});

/**
 * The unique name of a user.
 */
export const zUsername = z.string().min(1).max(256).regex(/^(<default>|[A-Za-z0-9_@.+-]+)$/).register(z.globalRegistry, {
    description: 'The unique name of a user.'
});

export const zUserCreateResult = z.object({
    username: z.optional(zUsername),
    name: z.optional(z.string().register(z.globalRegistry, {
        description: 'The name of the user.'
    })),
    email: z.optional(z.string().register(z.globalRegistry, {
        description: 'The email of the user.'
    }))
});

export const zUserUpdateResult = z.object({
    username: z.optional(zUsername),
    name: z.optional(z.string().register(z.globalRegistry, {
        description: 'The name of the user.'
    })),
    email: z.optional(z.string().register(z.globalRegistry, {
        description: 'The email of the user.'
    }))
});

export const zUserSearchQuerySortRequest = z.object({
    field: z.enum([
        'username',
        'name',
        'email'
    ]).register(z.globalRegistry, {
        description: 'The field to sort by.'
    }),
    order: z.optional(zSortOrderEnum)
});

/**
 * User search filter.
 */
export const zUserFilter = z.object({
    username: z.optional(zStringFilterProperty),
    name: z.optional(zStringFilterProperty),
    email: z.optional(zStringFilterProperty)
}).register(z.globalRegistry, {
    description: 'User search filter.'
});

export const zUserSearchQueryRequest = zSearchQueryRequest.and(z.object({
    sort: z.optional(z.array(zUserSearchQuerySortRequest).register(z.globalRegistry, {
        description: 'Sort field criteria.'
    })),
    filter: z.optional(zUserFilter)
}));

export const zMappingRuleSearchQuerySortRequest = z.object({
    field: z.enum([
        'mappingRuleId',
        'claimName',
        'claimValue',
        'name'
    ]).register(z.globalRegistry, {
        description: 'The field to sort by.'
    }),
    order: z.optional(zSortOrderEnum)
});

/**
 * Mapping rule search filter.
 */
export const zMappingRuleFilter = z.object({
    claimName: z.optional(z.string().register(z.globalRegistry, {
        description: 'The claim name to match against a token.'
    })),
    claimValue: z.optional(z.string().register(z.globalRegistry, {
        description: 'The value of the claim to match.'
    })),
    name: z.optional(z.string().register(z.globalRegistry, {
        description: 'The name of the mapping rule.'
    })),
    mappingRuleId: z.optional(z.string().register(z.globalRegistry, {
        description: 'The ID of the mapping rule.'
    }))
}).register(z.globalRegistry, {
    description: 'Mapping rule search filter.'
});

export const zMappingRuleSearchQueryRequest = zSearchQueryRequest.and(z.object({
    sort: z.optional(z.array(zMappingRuleSearchQuerySortRequest).register(z.globalRegistry, {
        description: 'Sort field criteria.'
    })),
    filter: z.optional(zMappingRuleFilter)
}));

export const zCamundaUserResult = z.object({
    username: z.optional(z.union([
        zUsername,
        z.null()
    ])),
    displayName: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    email: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    authorizedComponents: z.optional(z.array(z.string()).register(z.globalRegistry, {
        description: 'The web components the user is authorized to use.'
    })),
    tenants: z.array(zTenantResult).register(z.globalRegistry, {
        description: 'The tenants the user is a member of.'
    }),
    groups: z.array(z.string()).register(z.globalRegistry, {
        description: 'The groups assigned to the user.'
    }),
    roles: z.array(z.string()).register(z.globalRegistry, {
        description: 'The roles assigned to the user.'
    }),
    salesPlanType: z.string().register(z.globalRegistry, {
        description: 'The plan of the user.'
    }),
    c8Links: z.record(z.string(), z.string()).register(z.globalRegistry, {
        description: 'The links to the components in the C8 stack.'
    }),
    canLogout: z.boolean().register(z.globalRegistry, {
        description: 'Flag for understanding if the user is able to perform logout.'
    })
});

export const zUserResult = z.object({
    username: z.optional(zUsername),
    name: z.optional(z.string().register(z.globalRegistry, {
        description: 'The name of the user.'
    })),
    email: z.optional(z.string().register(z.globalRegistry, {
        description: 'The email of the user.'
    }))
});

export const zUserSearchResult = zSearchQueryResponse.and(z.object({
    items: z.array(zUserResult).register(z.globalRegistry, {
        description: 'The matching users.'
    })
}));

export const zUserUpdateRequest = z.object({
    password: z.optional(z.string().register(z.globalRegistry, {
        description: 'The password of the user. If blank, the password is unchanged.'
    })),
    name: z.optional(z.string().register(z.globalRegistry, {
        description: 'The name of the user.'
    })),
    email: z.optional(z.string().register(z.globalRegistry, {
        description: 'The email of the user.'
    }))
});

export const zTenantClientResult = z.object({
    clientId: z.optional(z.string().register(z.globalRegistry, {
        description: 'The ID of the client.'
    }))
});

export const zTenantClientSearchResult = zSearchQueryResponse.and(z.object({
    items: z.optional(z.array(zTenantClientResult).register(z.globalRegistry, {
        description: 'The matching clients.'
    }))
}));

export const zTenantClientSearchQuerySortRequest = z.object({
    field: z.enum([
        'clientId'
    ]).register(z.globalRegistry, {
        description: 'The field to sort by.'
    }),
    order: z.optional(zSortOrderEnum)
});

export const zTenantClientSearchQueryRequest = zSearchQueryRequest.and(z.object({
    sort: z.optional(z.array(zTenantClientSearchQuerySortRequest).register(z.globalRegistry, {
        description: 'Sort field criteria.'
    }))
}));

export const zTenantUserResult = z.object({
    username: z.optional(zUsername)
});

export const zTenantUserSearchResult = zSearchQueryResponse.and(z.object({
    items: z.optional(z.array(zTenantUserResult).register(z.globalRegistry, {
        description: 'The matching users.'
    }))
}));

export const zTenantUserSearchQuerySortRequest = z.object({
    field: z.enum([
        'username'
    ]).register(z.globalRegistry, {
        description: 'The field to sort by.'
    }),
    order: z.optional(zSortOrderEnum)
});

export const zTenantUserSearchQueryRequest = zSearchQueryRequest.and(z.object({
    sort: z.optional(z.array(zTenantUserSearchQuerySortRequest).register(z.globalRegistry, {
        description: 'Sort field criteria.'
    }))
}));

export const zTenantGroupResult = z.object({
    groupId: z.optional(z.string().register(z.globalRegistry, {
        description: 'The groupId of the group.'
    }))
});

export const zTenantGroupSearchResult = zSearchQueryResponse.and(z.object({
    items: z.optional(z.array(zTenantGroupResult).register(z.globalRegistry, {
        description: 'The matching groups.'
    }))
}));

export const zTenantGroupSearchQuerySortRequest = z.object({
    field: z.enum([
        'groupId'
    ]).register(z.globalRegistry, {
        description: 'The field to sort by.'
    }),
    order: z.optional(zSortOrderEnum)
});

export const zTenantGroupSearchQueryRequest = zSearchQueryRequest.and(z.object({
    sort: z.optional(z.array(zTenantGroupSearchQuerySortRequest).register(z.globalRegistry, {
        description: 'Sort field criteria.'
    }))
}));

export const zRoleCreateRequest = z.object({
    roleId: z.string().register(z.globalRegistry, {
        description: 'The ID of the new role.'
    }),
    name: z.string().register(z.globalRegistry, {
        description: 'The display name of the new role.'
    }),
    description: z.optional(z.string().register(z.globalRegistry, {
        description: 'The description of the new role.'
    }))
});

export const zRoleCreateResult = z.object({
    roleId: z.optional(z.string().register(z.globalRegistry, {
        description: 'The ID of the created role.'
    })),
    name: z.optional(z.string().register(z.globalRegistry, {
        description: 'The display name of the created role.'
    })),
    description: z.optional(z.string().register(z.globalRegistry, {
        description: 'The description of the created role.'
    }))
});

export const zRoleUpdateRequest = z.object({
    name: z.string().register(z.globalRegistry, {
        description: 'The display name of the new role.'
    }),
    description: z.string().register(z.globalRegistry, {
        description: 'The description of the new role.'
    })
});

export const zRoleUpdateResult = z.object({
    name: z.optional(z.string().register(z.globalRegistry, {
        description: 'The display name of the updated role.'
    })),
    description: z.optional(z.string().register(z.globalRegistry, {
        description: 'The description of the updated role.'
    })),
    roleId: z.optional(z.string().register(z.globalRegistry, {
        description: 'The ID of the updated role.'
    }))
});

/**
 * Role search response item.
 */
export const zRoleResult = z.object({
    name: z.optional(z.string().register(z.globalRegistry, {
        description: 'The role name.'
    })),
    roleId: z.optional(z.string().register(z.globalRegistry, {
        description: 'The role id.'
    })),
    description: z.optional(z.string().register(z.globalRegistry, {
        description: 'The description of the role.'
    }))
}).register(z.globalRegistry, {
    description: 'Role search response item.'
});

export const zRoleSearchQuerySortRequest = z.object({
    field: z.enum([
        'name',
        'roleId'
    ]).register(z.globalRegistry, {
        description: 'The field to sort by.'
    }),
    order: z.optional(zSortOrderEnum)
});

/**
 * Role filter request
 */
export const zRoleFilter = z.object({
    roleId: z.optional(z.string().register(z.globalRegistry, {
        description: 'The role ID search filters.'
    })),
    name: z.optional(z.string().register(z.globalRegistry, {
        description: 'The role name search filters.'
    }))
}).register(z.globalRegistry, {
    description: 'Role filter request'
});

/**
 * Role search request.
 */
export const zRoleSearchQueryRequest = zSearchQueryRequest.and(z.object({
    sort: z.optional(z.array(zRoleSearchQuerySortRequest).register(z.globalRegistry, {
        description: 'Sort field criteria.'
    })),
    filter: z.optional(zRoleFilter)
}).register(z.globalRegistry, {
    description: 'Role search request.'
}));

/**
 * Role search response.
 */
export const zRoleSearchQueryResult = zSearchQueryResponse.and(z.object({
    items: z.optional(z.array(zRoleResult).register(z.globalRegistry, {
        description: 'The matching roles.'
    }))
}).register(z.globalRegistry, {
    description: 'Role search response.'
}));

export const zRoleUserResult = z.object({
    username: z.optional(zUsername)
});

export const zRoleUserSearchResult = zSearchQueryResponse.and(z.object({
    items: z.optional(z.array(zRoleUserResult).register(z.globalRegistry, {
        description: 'The matching users.'
    }))
}));

export const zRoleUserSearchQuerySortRequest = z.object({
    field: z.enum([
        'username'
    ]).register(z.globalRegistry, {
        description: 'The field to sort by.'
    }),
    order: z.optional(zSortOrderEnum)
});

export const zRoleUserSearchQueryRequest = zSearchQueryRequest.and(z.object({
    sort: z.optional(z.array(zRoleUserSearchQuerySortRequest).register(z.globalRegistry, {
        description: 'Sort field criteria.'
    }))
}));

export const zRoleClientResult = z.object({
    clientId: z.optional(z.string().register(z.globalRegistry, {
        description: 'The ID of the client.'
    }))
});

export const zRoleClientSearchResult = zSearchQueryResponse.and(z.object({
    items: z.optional(z.array(zRoleClientResult).register(z.globalRegistry, {
        description: 'The matching clients.'
    }))
}));

export const zRoleClientSearchQuerySortRequest = z.object({
    field: z.enum([
        'clientId'
    ]).register(z.globalRegistry, {
        description: 'The field to sort by.'
    }),
    order: z.optional(zSortOrderEnum)
});

export const zRoleClientSearchQueryRequest = zSearchQueryRequest.and(z.object({
    sort: z.optional(z.array(zRoleClientSearchQuerySortRequest).register(z.globalRegistry, {
        description: 'Sort field criteria.'
    }))
}));

export const zRoleGroupResult = z.object({
    groupId: z.optional(z.string().register(z.globalRegistry, {
        description: 'The id of the group.'
    }))
});

export const zRoleGroupSearchResult = zSearchQueryResponse.and(z.object({
    items: z.optional(z.array(zRoleGroupResult).register(z.globalRegistry, {
        description: 'The matching groups.'
    }))
}));

export const zRoleGroupSearchQuerySortRequest = z.object({
    field: z.enum([
        'groupId'
    ]).register(z.globalRegistry, {
        description: 'The field to sort by.'
    }),
    order: z.optional(zSortOrderEnum)
});

export const zRoleGroupSearchQueryRequest = zSearchQueryRequest.and(z.object({
    sort: z.optional(z.array(zRoleGroupSearchQuerySortRequest).register(z.globalRegistry, {
        description: 'Sort field criteria.'
    }))
}));

export const zGroupCreateRequest = z.object({
    groupId: z.string().register(z.globalRegistry, {
        description: 'The ID of the new group.'
    }),
    name: z.string().register(z.globalRegistry, {
        description: 'The display name of the new group.'
    }),
    description: z.optional(z.string().register(z.globalRegistry, {
        description: 'The description of the new group.'
    }))
});

export const zGroupCreateResult = z.object({
    groupId: z.optional(z.string().register(z.globalRegistry, {
        description: 'The ID of the created group.'
    })),
    name: z.optional(z.string().register(z.globalRegistry, {
        description: 'The display name of the created group.'
    })),
    description: z.optional(z.string().register(z.globalRegistry, {
        description: 'The description of the created group.'
    }))
});

export const zGroupUpdateRequest = z.object({
    name: z.string().register(z.globalRegistry, {
        description: 'The new name of the group.'
    }),
    description: z.string().register(z.globalRegistry, {
        description: 'The new description of the group.'
    })
});

export const zGroupUpdateResult = z.object({
    groupId: z.optional(z.string().register(z.globalRegistry, {
        description: 'The unique external group ID.'
    })),
    name: z.optional(z.string().register(z.globalRegistry, {
        description: 'The name of the group.'
    })),
    description: z.optional(z.string().register(z.globalRegistry, {
        description: 'The description of the group.'
    }))
});

/**
 * Group search response item.
 */
export const zGroupResult = z.object({
    name: z.optional(z.string().register(z.globalRegistry, {
        description: 'The group name.'
    })),
    groupId: z.optional(z.string().register(z.globalRegistry, {
        description: 'The group ID.'
    })),
    description: z.optional(z.string().register(z.globalRegistry, {
        description: 'The group description.'
    }))
}).register(z.globalRegistry, {
    description: 'Group search response item.'
});

export const zGroupSearchQuerySortRequest = z.object({
    field: z.enum([
        'name',
        'groupId'
    ]).register(z.globalRegistry, {
        description: 'The field to sort by.'
    }),
    order: z.optional(zSortOrderEnum)
});

/**
 * Group filter request
 */
export const zGroupFilter = z.object({
    groupId: z.optional(zStringFilterProperty),
    name: z.optional(z.string().register(z.globalRegistry, {
        description: 'The group name search filters.'
    }))
}).register(z.globalRegistry, {
    description: 'Group filter request'
});

/**
 * Group search request.
 */
export const zGroupSearchQueryRequest = zSearchQueryRequest.and(z.object({
    sort: z.optional(z.array(zGroupSearchQuerySortRequest).register(z.globalRegistry, {
        description: 'Sort field criteria.'
    })),
    filter: z.optional(zGroupFilter)
}).register(z.globalRegistry, {
    description: 'Group search request.'
}));

/**
 * Group search response.
 */
export const zGroupSearchQueryResult = zSearchQueryResponse.and(z.object({
    items: z.optional(z.array(zGroupResult).register(z.globalRegistry, {
        description: 'The matching groups.'
    }))
}).register(z.globalRegistry, {
    description: 'Group search response.'
}));

export const zGroupUserResult = z.object({
    username: z.optional(zUsername)
});

export const zGroupUserSearchResult = zSearchQueryResponse.and(z.object({
    items: z.optional(z.array(zGroupUserResult).register(z.globalRegistry, {
        description: 'The matching members.'
    }))
}));

export const zGroupUserSearchQuerySortRequest = z.object({
    field: z.enum([
        'username'
    ]).register(z.globalRegistry, {
        description: 'The field to sort by.'
    }),
    order: z.optional(zSortOrderEnum)
});

export const zGroupUserSearchQueryRequest = zSearchQueryRequest.and(z.object({
    sort: z.optional(z.array(zGroupUserSearchQuerySortRequest).register(z.globalRegistry, {
        description: 'Sort field criteria.'
    }))
}));

export const zGroupClientResult = z.object({
    clientId: z.optional(z.string().register(z.globalRegistry, {
        description: 'The ID of the client.'
    }))
});

export const zGroupClientSearchResult = zSearchQueryResponse.and(z.object({
    items: z.optional(z.array(zGroupClientResult).register(z.globalRegistry, {
        description: 'The matching client IDs.'
    }))
}));

export const zGroupClientSearchQuerySortRequest = z.object({
    field: z.enum([
        'clientId'
    ]).register(z.globalRegistry, {
        description: 'The field to sort by.'
    }),
    order: z.optional(zSortOrderEnum)
});

export const zGroupClientSearchQueryRequest = zSearchQueryRequest.and(z.object({
    sort: z.optional(z.array(zGroupClientSearchQuerySortRequest).register(z.globalRegistry, {
        description: 'Sort field criteria.'
    }))
}));

export const zMappingRuleCreateUpdateRequest = z.object({
    claimName: z.string().register(z.globalRegistry, {
        description: 'The name of the claim to map.'
    }),
    claimValue: z.string().register(z.globalRegistry, {
        description: 'The value of the claim to map.'
    }),
    name: z.string().register(z.globalRegistry, {
        description: 'The name of the mapping rule.'
    })
});

export const zMappingRuleCreateRequest = zMappingRuleCreateUpdateRequest.and(z.object({
    mappingRuleId: z.string().register(z.globalRegistry, {
        description: 'The unique ID of the mapping rule.'
    })
}));

export const zMappingRuleUpdateRequest = zMappingRuleCreateUpdateRequest;

export const zMappingRuleCreateUpdateResult = z.object({
    claimName: z.optional(z.string().register(z.globalRegistry, {
        description: 'The name of the claim to map.'
    })),
    claimValue: z.optional(z.string().register(z.globalRegistry, {
        description: 'The value of the claim to map.'
    })),
    name: z.optional(z.string().register(z.globalRegistry, {
        description: 'The name of the mapping rule.'
    })),
    mappingRuleId: z.optional(z.string().register(z.globalRegistry, {
        description: 'The unique ID of the mapping rule.'
    }))
});

export const zMappingRuleCreateResult = zMappingRuleCreateUpdateResult;

export const zMappingRuleUpdateResult = zMappingRuleCreateUpdateResult;

export const zMappingRuleResult = z.object({
    claimName: z.optional(z.string().register(z.globalRegistry, {
        description: 'The name of the claim to map.'
    })),
    claimValue: z.optional(z.string().register(z.globalRegistry, {
        description: 'The value of the claim to map.'
    })),
    name: z.optional(z.string().register(z.globalRegistry, {
        description: 'The name of the mapping rule.'
    })),
    mappingRuleId: z.optional(z.string().register(z.globalRegistry, {
        description: 'The ID of the mapping rule.'
    }))
});

export const zMappingRuleSearchQueryResult = zSearchQueryResponse.and(z.object({
    items: z.optional(z.array(zMappingRuleResult).register(z.globalRegistry, {
        description: 'The matching mapping rules.'
    }))
}));

/**
 * Provides information on a partition within a broker node.
 */
export const zPartition = z.object({
    partitionId: z.int().register(z.globalRegistry, {
        description: 'The unique ID of this partition.'
    }),
    role: z.enum([
        'leader',
        'follower',
        'inactive'
    ]).register(z.globalRegistry, {
        description: 'Describes the Raft role of the broker for a given partition.'
    }),
    health: z.enum([
        'healthy',
        'unhealthy',
        'dead'
    ]).register(z.globalRegistry, {
        description: 'Describes the current health of the partition.'
    })
}).register(z.globalRegistry, {
    description: 'Provides information on a partition within a broker node.'
});

/**
 * Provides information on a broker node.
 */
export const zBrokerInfo = z.object({
    nodeId: z.int().register(z.globalRegistry, {
        description: 'The unique (within a cluster) node ID for the broker.'
    }),
    host: z.string().register(z.globalRegistry, {
        description: 'The hostname for reaching the broker.'
    }),
    port: z.int().register(z.globalRegistry, {
        description: 'The port for reaching the broker.'
    }),
    partitions: z.array(zPartition).register(z.globalRegistry, {
        description: 'A list of partitions managed or replicated on this broker.'
    }),
    version: z.string().register(z.globalRegistry, {
        description: 'The broker version.'
    })
}).register(z.globalRegistry, {
    description: 'Provides information on a broker node.'
});

/**
 * The response of a topology request.
 */
export const zTopologyResponse = z.object({
    brokers: z.array(zBrokerInfo).register(z.globalRegistry, {
        description: 'A list of brokers that are part of this cluster.'
    }),
    clusterSize: z.int().register(z.globalRegistry, {
        description: 'The number of brokers in the cluster.'
    }),
    partitionsCount: z.int().register(z.globalRegistry, {
        description: 'The number of partitions are spread across the cluster.'
    }),
    replicationFactor: z.int().register(z.globalRegistry, {
        description: 'The configured replication factor for this cluster.'
    }),
    gatewayVersion: z.string().register(z.globalRegistry, {
        description: 'The version of the Zeebe Gateway.'
    }),
    lastCompletedChangeId: z.string().register(z.globalRegistry, {
        description: 'ID of the last completed change'
    })
}).register(z.globalRegistry, {
    description: 'The response of a topology request.'
});

/**
 * The response of a license request.
 */
export const zLicenseResponse = z.object({
    validLicense: z.boolean().register(z.globalRegistry, {
        description: 'True if the Camunda license is valid, false if otherwise'
    }),
    licenseType: z.string().register(z.globalRegistry, {
        description: 'Will return the license type property of the Camunda license'
    }),
    isCommercial: z.boolean().register(z.globalRegistry, {
        description: 'Will be false when a license contains a non-commerical=true property'
    }),
    expiresAt: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ]))
}).register(z.globalRegistry, {
    description: 'The response of a license request.'
});

export const zUserTaskCompletionRequest = z.object({
    variables: z.optional(z.union([
        z.record(z.string(), z.unknown()),
        z.null()
    ])),
    action: z.optional(z.union([
        z.string(),
        z.null()
    ]))
});

export const zUserTaskAssignmentRequest = z.object({
    assignee: z.optional(z.string().register(z.globalRegistry, {
        description: 'The assignee for the user task. The assignee must not be empty or `null`.'
    })),
    allowOverride: z.optional(z.union([
        z.boolean(),
        z.null()
    ])),
    action: z.optional(z.union([
        z.string(),
        z.null()
    ]))
});

/**
 * JSON object with changed task attribute values.
 *
 * The following attributes can be adjusted with this endpoint, additional attributes
 * will be ignored:
 *
 * * `candidateGroups` - reset by providing an empty list
 * * `candidateUsers` - reset by providing an empty list
 * * `dueDate` - reset by providing an empty String
 * * `followUpDate` - reset by providing an empty String
 * * `priority` - minimum 0, maximum 100, default 50
 *
 * Providing any of those attributes with a `null` value or omitting it preserves
 * the persisted attribute's value.
 *
 * The assignee cannot be adjusted with this endpoint, use the Assign task endpoint.
 * This ensures correct event emission for assignee changes.
 *
 */
export const zChangeset = z.union([
    z.object({
        dueDate: z.optional(z.union([
            z.iso.datetime(),
            z.null()
        ])),
        followUpDate: z.optional(z.union([
            z.iso.datetime(),
            z.null()
        ])),
        candidateUsers: z.optional(z.union([
            z.array(z.string()),
            z.null()
        ])),
        candidateGroups: z.optional(z.union([
            z.array(z.string()),
            z.null()
        ])),
        priority: z.optional(z.union([
            z.int().gte(0).lte(100).default(50),
            z.null()
        ])).default(50)
    }),
    z.null()
]);

export const zUserTaskUpdateRequest = z.object({
    changeset: z.optional(zChangeset),
    action: z.optional(z.union([
        z.string(),
        z.null()
    ]))
});

export const zClockPinRequest = z.object({
    timestamp: z.coerce.bigint().register(z.globalRegistry, {
        description: 'The exact time in epoch milliseconds to which the clock should be pinned.'
    })
});

export const zJobActivationRequest = z.object({
    type: z.string().register(z.globalRegistry, {
        description: 'The job type, as defined in the BPMN process (e.g. <zeebe:taskDefinition type="payment-service" />).\n'
    }),
    worker: z.optional(z.string().register(z.globalRegistry, {
        description: 'The name of the worker activating the jobs, mostly used for logging purposes.'
    })),
    timeout: z.coerce.bigint().register(z.globalRegistry, {
        description: 'A job returned after this call will not be activated by another call until the timeout (in ms) has been reached.\n'
    }),
    maxJobsToActivate: z.int().register(z.globalRegistry, {
        description: 'The maximum jobs to activate by this request.'
    }),
    fetchVariable: z.optional(z.array(z.string()).register(z.globalRegistry, {
        description: 'A list of variables to fetch as the job variables; if empty, all visible variables at the time of activation for the scope of the job will be returned.\n'
    })),
    requestTimeout: z.optional(z.coerce.bigint().register(z.globalRegistry, {
        description: 'The request will be completed when at least one job is activated or after the requestTimeout (in ms). If the requestTimeout = 0, a default timeout is used. If the requestTimeout < 0, long polling is disabled and the request is completed immediately, even when no job is activated.\n'
    })).default(BigInt(0)),
    tenantIds: z.optional(z.array(zTenantId).register(z.globalRegistry, {
        description: 'A list of IDs of tenants for which to activate jobs.'
    }))
});

/**
 * The job kind.
 */
export const zJobKindEnum = z.enum([
    'BPMN_ELEMENT',
    'EXECUTION_LISTENER',
    'TASK_LISTENER',
    'AD_HOC_SUB_PROCESS'
]).register(z.globalRegistry, {
    description: 'The job kind.'
});

/**
 * The listener event type of the job.
 */
export const zJobListenerEventTypeEnum = z.enum([
    'ASSIGNING',
    'CANCELING',
    'COMPLETING',
    'CREATING',
    'END',
    'START',
    'UNSPECIFIED',
    'UPDATING'
]).register(z.globalRegistry, {
    description: 'The listener event type of the job.'
});

/**
 * Contains properties of a user task.
 */
export const zUserTaskProperties = z.object({
    action: z.optional(z.string().register(z.globalRegistry, {
        description: 'The action performed on the user task.'
    })),
    assignee: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    candidateGroups: z.optional(z.array(z.string()).register(z.globalRegistry, {
        description: 'The groups eligible to claim the task.'
    })),
    candidateUsers: z.optional(z.array(z.string()).register(z.globalRegistry, {
        description: 'The users eligible to claim the task.'
    })),
    changedAttributes: z.optional(z.array(z.string()).register(z.globalRegistry, {
        description: 'The attributes that were changed in the task.'
    })),
    dueDate: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ])),
    followUpDate: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ])),
    formKey: z.optional(zFormKey),
    priority: z.optional(z.union([
        z.int().gte(0).lte(100),
        z.null()
    ])),
    userTaskKey: z.optional(z.union([
        zUserTaskKey,
        z.null()
    ]))
}).register(z.globalRegistry, {
    description: 'Contains properties of a user task.'
});

export const zActivatedJobResult = z.object({
    type: z.string().register(z.globalRegistry, {
        description: 'The type of the job (should match what was requested).'
    }),
    processDefinitionId: zProcessDefinitionId,
    processDefinitionVersion: z.int().register(z.globalRegistry, {
        description: "The version of the job's process definition."
    }),
    elementId: zElementId,
    customHeaders: z.record(z.string(), z.unknown()).register(z.globalRegistry, {
        description: 'A set of custom headers defined during modelling; returned as a serialized JSON document.'
    }),
    worker: z.string().register(z.globalRegistry, {
        description: 'The name of the worker which activated this job.'
    }),
    retries: z.int().register(z.globalRegistry, {
        description: 'The amount of retries left to this job (should always be positive).'
    }),
    deadline: z.coerce.bigint().register(z.globalRegistry, {
        description: 'When the job can be activated again, sent as a UNIX epoch timestamp.'
    }),
    variables: z.record(z.string(), z.unknown()).register(z.globalRegistry, {
        description: 'All variables visible to the task scope, computed at activation time.'
    }),
    tenantId: zTenantId,
    jobKey: zJobKey,
    processInstanceKey: zProcessInstanceKey,
    processDefinitionKey: zProcessDefinitionKey,
    elementInstanceKey: zElementInstanceKey,
    kind: zJobKindEnum,
    listenerEventType: zJobListenerEventTypeEnum,
    userTask: z.optional(zUserTaskProperties),
    tags: z.optional(zTagSet)
});

/**
 * The list of activated jobs
 */
export const zJobActivationResult = z.object({
    jobs: z.array(zActivatedJobResult).register(z.globalRegistry, {
        description: 'The activated jobs.'
    })
}).register(z.globalRegistry, {
    description: 'The list of activated jobs'
});

export const zJobFailRequest = z.object({
    retries: z.optional(z.int().register(z.globalRegistry, {
        description: 'The amount of retries the job should have left\n'
    })).default(0),
    errorMessage: z.optional(z.string().register(z.globalRegistry, {
        description: 'An optional message describing why the job failed. This is particularly useful if a job runs out of retries and an incident is raised, as this message can help explain why an incident was raised.\n'
    })),
    retryBackOff: z.optional(z.coerce.bigint().register(z.globalRegistry, {
        description: 'The backoff timeout (in ms) for the next retry.\n'
    })).default(BigInt(0)),
    variables: z.optional(z.record(z.string(), z.unknown()).register(z.globalRegistry, {
        description: "JSON object that will instantiate the variables at the local scope of the job's associated task.\n"
    }))
});

export const zJobErrorRequest = z.object({
    errorCode: z.string().register(z.globalRegistry, {
        description: 'The error code that will be matched with an error catch event.\n'
    }),
    errorMessage: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    variables: z.optional(z.union([
        z.record(z.string(), z.unknown()),
        z.null()
    ]))
});

/**
 * JSON object with attributes that were corrected by the worker.
 *
 * The following attributes can be corrected, additional attributes will be ignored:
 *
 * * `assignee` - clear by providing an empty String
 * * `dueDate` - clear by providing an empty String
 * * `followUpDate` - clear by providing an empty String
 * * `candidateGroups` - clear by providing an empty list
 * * `candidateUsers` - clear by providing an empty list
 * * `priority` - minimum 0, maximum 100, default 50
 *
 * Providing any of those attributes with a `null` value or omitting it preserves
 * the persisted attribute's value.
 *
 */
export const zJobResultCorrections = z.union([
    z.object({
        assignee: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        dueDate: z.optional(z.union([
            z.iso.datetime(),
            z.null()
        ])),
        followUpDate: z.optional(z.union([
            z.iso.datetime(),
            z.null()
        ])),
        candidateUsers: z.optional(z.union([
            z.array(z.string()),
            z.null()
        ])),
        candidateGroups: z.optional(z.union([
            z.array(z.string()),
            z.null()
        ])),
        priority: z.optional(z.union([
            z.int().gte(0).lte(100),
            z.null()
        ]))
    }),
    z.null()
]);

export const zJobResultUserTask = z.union([
    z.object({
        denied: z.optional(z.union([
            z.boolean(),
            z.null()
        ])),
        deniedReason: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        corrections: z.optional(zJobResultCorrections)
    }),
    z.null()
]);

export const zJobResultActivateElement = z.object({
    elementId: z.optional(zElementId),
    variables: z.optional(z.union([
        z.record(z.string(), z.unknown()),
        z.null()
    ]))
});

export const zJobResultAdHocSubProcess = z.union([
    z.object({
        activateElements: z.optional(z.array(zJobResultActivateElement).register(z.globalRegistry, {
            description: 'Indicates which elements need to be activated in the ad-hoc subprocess.'
        })),
        isCompletionConditionFulfilled: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'Indicates whether the completion condition of the ad-hoc subprocess is fulfilled.'
        })).default(false),
        isCancelRemainingInstances: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'Indicates whether the remaining instances of the ad-hoc subprocess should be canceled.'
        })).default(false)
    }),
    z.null()
]);

export const zJobResult = z.intersection(z.union([
    z.object({
        type: z.literal('userTask')
    }).and(zJobResultUserTask),
    z.object({
        type: z.literal('adHocSubProcess')
    }).and(zJobResultAdHocSubProcess)
]), z.object({
    type: z.enum([
        'userTask',
        'adHocSubProcess'
    ]).register(z.globalRegistry, {
        description: 'Used to distinguish between different types of job results.'
    })
}).register(z.globalRegistry, {
    description: 'The result of the completed job as determined by the worker.\n'
}));

export const zJobCompletionRequest = z.object({
    variables: z.optional(z.union([
        z.record(z.string(), z.unknown()),
        z.null()
    ])),
    result: z.optional(zJobResult)
});

/**
 * JSON object with changed job attribute values.
 *
 * The following attributes can be adjusted with this endpoint, additional attributes
 * will be ignored:
 *
 * * `retries` - The new amount of retries for the job; must be a positive number.
 * * `timeout` - The duration of the new timeout in ms, starting from the current moment.
 *
 * Providing any of those attributes with a null value or omitting it preserves the persisted attribute’s value.
 *
 * The job cannot be completed or failed with this endpoint, use the complete job or fail job endpoints instead.
 *
 */
export const zJobChangeset = z.object({
    retries: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    timeout: z.optional(z.union([
        z.coerce.bigint(),
        z.null()
    ]))
}).register(z.globalRegistry, {
    description: 'JSON object with changed job attribute values.\n\nThe following attributes can be adjusted with this endpoint, additional attributes\nwill be ignored:\n\n* `retries` - The new amount of retries for the job; must be a positive number.\n* `timeout` - The duration of the new timeout in ms, starting from the current moment.\n\nProviding any of those attributes with a null value or omitting it preserves the persisted attribute’s value.\n\nThe job cannot be completed or failed with this endpoint, use the complete job or fail job endpoints instead.\n'
});

export const zJobUpdateRequest = z.object({
    changeset: zJobChangeset,
    operationReference: z.optional(zOperationReference)
});

export const zJobSearchQuerySortRequest = z.object({
    field: z.enum([
        'deadline',
        'deniedReason',
        'elementId',
        'elementInstanceKey',
        'endTime',
        'errorCode',
        'errorMessage',
        'hasFailedWithRetriesLeft',
        'isDenied',
        'jobKey',
        'kind',
        'listenerEventType',
        'processDefinitionId',
        'processDefinitionKey',
        'processInstanceKey',
        'retries',
        'state',
        'tenantId',
        'type',
        'worker'
    ]).register(z.globalRegistry, {
        description: 'The field to sort by.'
    }),
    order: z.optional(zSortOrderEnum)
});

/**
 * Advanced filter
 * Advanced JobKindEnum filter.
 */
export const zAdvancedJobKindFilter = z.object({
    '$eq': z.optional(zJobKindEnum),
    '$neq': z.optional(zJobKindEnum),
    '$exists': z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Checks if the current property exists.'
    })),
    '$in': z.optional(z.array(zJobKindEnum).register(z.globalRegistry, {
        description: 'Checks if the property matches any of the provided values.'
    })),
    '$like': z.optional(zLikeFilter)
}).register(z.globalRegistry, {
    description: 'Advanced JobKindEnum filter.'
});

/**
 * JobKindEnum property with full advanced search capabilities.
 */
export const zJobKindFilterProperty = z.union([
    zJobKindEnum,
    zAdvancedJobKindFilter
]);

/**
 * Advanced filter
 * Advanced JobListenerEventTypeEnum filter.
 */
export const zAdvancedJobListenerEventTypeFilter = z.object({
    '$eq': z.optional(zJobListenerEventTypeEnum),
    '$neq': z.optional(zJobListenerEventTypeEnum),
    '$exists': z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Checks if the current property exists.'
    })),
    '$in': z.optional(z.array(zJobListenerEventTypeEnum).register(z.globalRegistry, {
        description: 'Checks if the property matches any of the provided values.'
    })),
    '$like': z.optional(zLikeFilter)
}).register(z.globalRegistry, {
    description: 'Advanced JobListenerEventTypeEnum filter.'
});

/**
 * JobListenerEventTypeEnum property with full advanced search capabilities.
 */
export const zJobListenerEventTypeFilterProperty = z.union([
    zJobListenerEventTypeEnum,
    zAdvancedJobListenerEventTypeFilter
]);

/**
 * The state of the job.
 */
export const zJobStateEnum = z.enum([
    'CANCELED',
    'COMPLETED',
    'CREATED',
    'ERROR_THROWN',
    'FAILED',
    'MIGRATED',
    'RETRIES_UPDATED',
    'TIMED_OUT'
]).register(z.globalRegistry, {
    description: 'The state of the job.'
});

/**
 * Advanced filter
 * Advanced JobStateEnum filter.
 */
export const zAdvancedJobStateFilter = z.object({
    '$eq': z.optional(zJobStateEnum),
    '$neq': z.optional(zJobStateEnum),
    '$exists': z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Checks if the current property exists.'
    })),
    '$in': z.optional(z.array(zJobStateEnum).register(z.globalRegistry, {
        description: 'Checks if the property matches any of the provided values.'
    })),
    '$like': z.optional(zLikeFilter)
}).register(z.globalRegistry, {
    description: 'Advanced JobStateEnum filter.'
});

/**
 * JobStateEnum property with full advanced search capabilities.
 */
export const zJobStateFilterProperty = z.union([
    zJobStateEnum,
    zAdvancedJobStateFilter
]);

/**
 * Job search filter.
 */
export const zJobFilter = z.object({
    deadline: z.optional(z.union([
        zDateTimeFilterProperty,
        z.null()
    ])),
    deniedReason: z.optional(zStringFilterProperty),
    elementId: z.optional(zStringFilterProperty),
    elementInstanceKey: z.optional(zElementInstanceKeyFilterProperty),
    endTime: z.optional(zDateTimeFilterProperty),
    errorCode: z.optional(zStringFilterProperty),
    errorMessage: z.optional(zStringFilterProperty),
    hasFailedWithRetriesLeft: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Indicates whether the job has failed with retries left.'
    })),
    isDenied: z.optional(z.union([
        z.boolean(),
        z.null()
    ])),
    jobKey: z.optional(zJobKeyFilterProperty),
    kind: z.optional(zJobKindFilterProperty),
    listenerEventType: z.optional(zJobListenerEventTypeFilterProperty),
    processDefinitionId: z.optional(zStringFilterProperty),
    processDefinitionKey: z.optional(zProcessDefinitionKeyFilterProperty),
    processInstanceKey: z.optional(zProcessInstanceKeyFilterProperty),
    retries: z.optional(zIntegerFilterProperty),
    state: z.optional(zJobStateFilterProperty),
    tenantId: z.optional(zStringFilterProperty),
    type: z.optional(zStringFilterProperty),
    worker: z.optional(zStringFilterProperty)
}).register(z.globalRegistry, {
    description: 'Job search filter.'
});

/**
 * Job search request.
 */
export const zJobSearchQuery = zSearchQueryRequest.and(z.object({
    sort: z.optional(z.array(zJobSearchQuerySortRequest).register(z.globalRegistry, {
        description: 'Sort field criteria.'
    })),
    filter: z.optional(zJobFilter)
}).register(z.globalRegistry, {
    description: 'Job search request.'
}));

export const zJobSearchResult = z.object({
    customHeaders: z.record(z.string(), z.string()).register(z.globalRegistry, {
        description: 'A set of custom headers defined during modelling.'
    }),
    deadline: z.optional(z.union([
        z.iso.datetime(),
        z.null()
    ])),
    deniedReason: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    elementId: zElementId,
    elementInstanceKey: zElementInstanceKey,
    endTime: z.optional(z.iso.datetime().register(z.globalRegistry, {
        description: 'When the job ended.'
    })),
    errorCode: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    errorMessage: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    hasFailedWithRetriesLeft: z.boolean().register(z.globalRegistry, {
        description: 'Indicates whether the job has failed with retries left.'
    }),
    isDenied: z.optional(z.union([
        z.boolean(),
        z.null()
    ])),
    jobKey: zJobKey,
    kind: zJobKindEnum,
    listenerEventType: zJobListenerEventTypeEnum,
    processDefinitionId: zProcessDefinitionId,
    processDefinitionKey: zProcessDefinitionKey,
    processInstanceKey: zProcessInstanceKey,
    retries: z.int().register(z.globalRegistry, {
        description: 'The amount of retries left to this job.'
    }),
    state: zJobStateEnum,
    tenantId: zTenantId,
    type: z.string().register(z.globalRegistry, {
        description: 'The type of the job.'
    }),
    worker: z.string().register(z.globalRegistry, {
        description: 'The name of the worker of this job.'
    })
});

/**
 * Job search response.
 */
export const zJobSearchQueryResult = zSearchQueryResponse.and(z.object({
    items: z.optional(z.array(zJobSearchResult).register(z.globalRegistry, {
        description: 'The matching jobs.'
    }))
}).register(z.globalRegistry, {
    description: 'Job search response.'
}));

/**
 * A Problem detail object as described in [RFC 9457](https://www.rfc-editor.org/rfc/rfc9457). There may be additional properties specific to the problem type.
 *
 */
export const zProblemDetail = z.object({
    type: z.optional(z.url().register(z.globalRegistry, {
        description: 'A URI identifying the problem type.'
    })).default('about:blank'),
    title: z.optional(z.string().register(z.globalRegistry, {
        description: 'A summary of the problem type.'
    })),
    status: z.optional(z.int().gte(400).lte(600).register(z.globalRegistry, {
        description: 'The HTTP status code for this problem.'
    })),
    detail: z.optional(z.string().register(z.globalRegistry, {
        description: 'An explanation of the problem in more detail.'
    })),
    instance: z.optional(z.string().register(z.globalRegistry, {
        description: 'A URI path identifying the origin of the problem.'
    }))
}).register(z.globalRegistry, {
    description: 'A Problem detail object as described in [RFC 9457](https://www.rfc-editor.org/rfc/rfc9457). There may be additional properties specific to the problem type.\n'
});

export const zDecisionRequirementsSearchQuerySortRequest = z.object({
    field: z.enum([
        'decisionRequirementsKey',
        'decisionRequirementsName',
        'version',
        'decisionRequirementsId',
        'tenantId'
    ]).register(z.globalRegistry, {
        description: 'The field to sort by.'
    }),
    order: z.optional(zSortOrderEnum)
});

/**
 * Decision requirements search filter.
 */
export const zDecisionRequirementsFilter = z.object({
    decisionRequirementsName: z.optional(z.string().register(z.globalRegistry, {
        description: 'The DMN name of the decision requirements.'
    })),
    version: z.optional(z.int().register(z.globalRegistry, {
        description: 'The assigned version of the decision requirements.'
    })),
    decisionRequirementsId: z.optional(z.string().register(z.globalRegistry, {
        description: 'the DMN ID of the decision requirements.'
    })),
    tenantId: z.optional(zTenantId),
    decisionRequirementsKey: z.optional(zDecisionRequirementsKey),
    resourceName: z.optional(z.string().register(z.globalRegistry, {
        description: 'The name of the resource from which the decision requirements were parsed.'
    }))
}).register(z.globalRegistry, {
    description: 'Decision requirements search filter.'
});

export const zDecisionRequirementsSearchQuery = zSearchQueryRequest.and(z.object({
    sort: z.optional(z.array(zDecisionRequirementsSearchQuerySortRequest).register(z.globalRegistry, {
        description: 'Sort field criteria.'
    })),
    filter: z.optional(zDecisionRequirementsFilter)
}));

export const zDecisionRequirementsResult = z.object({
    decisionRequirementsName: z.optional(z.string().register(z.globalRegistry, {
        description: 'The DMN name of the decision requirements.'
    })),
    version: z.optional(z.int().register(z.globalRegistry, {
        description: 'The assigned version of the decision requirements.'
    })),
    decisionRequirementsId: z.optional(z.string().register(z.globalRegistry, {
        description: 'The DMN ID of the decision requirements.'
    })),
    resourceName: z.optional(z.string().register(z.globalRegistry, {
        description: 'The name of the resource from which this decision requirements was parsed.'
    })),
    tenantId: z.optional(zTenantId),
    decisionRequirementsKey: z.optional(zDecisionRequirementsKey)
});

export const zDecisionRequirementsSearchQueryResult = zSearchQueryResponse.and(z.object({
    items: z.optional(z.array(zDecisionRequirementsResult).register(z.globalRegistry, {
        description: 'The matching decision requirements.'
    }))
}));

/**
 * Decision evaluation by ID
 */
export const zDecisionEvaluationById = z.object({
    decisionDefinitionId: zDecisionDefinitionId,
    variables: z.optional(z.record(z.string(), z.unknown()).register(z.globalRegistry, {
        description: 'The message variables as JSON document.'
    })),
    tenantId: z.optional(zTenantId)
});

/**
 * Decision evaluation by key
 */
export const zDecisionEvaluationByKey = z.object({
    decisionDefinitionKey: zDecisionDefinitionKey,
    variables: z.optional(z.record(z.string(), z.unknown()).register(z.globalRegistry, {
        description: 'The message variables as JSON document.'
    })),
    tenantId: z.optional(zTenantId)
});

export const zDecisionEvaluationInstruction = z.union([
    zDecisionEvaluationById,
    zDecisionEvaluationByKey
]);

/**
 * The evaluated decision outputs.
 */
export const zEvaluatedDecisionOutputItem = z.object({
    outputId: z.optional(z.string().register(z.globalRegistry, {
        description: 'The ID of the evaluated decision output.'
    })),
    outputName: z.optional(z.string().register(z.globalRegistry, {
        description: 'The name of the evaluated decision output.'
    })),
    outputValue: z.optional(z.string().register(z.globalRegistry, {
        description: 'The value of the evaluated decision output.'
    }))
}).register(z.globalRegistry, {
    description: 'The evaluated decision outputs.'
});

/**
 * A decision rule that matched within this decision evaluation.
 */
export const zMatchedDecisionRuleItem = z.object({
    ruleId: z.optional(z.string().register(z.globalRegistry, {
        description: 'The ID of the matched rule.'
    })),
    ruleIndex: z.optional(z.int().register(z.globalRegistry, {
        description: 'The index of the matched rule.'
    })),
    evaluatedOutputs: z.optional(z.array(zEvaluatedDecisionOutputItem).register(z.globalRegistry, {
        description: 'The evaluated decision outputs.'
    }))
}).register(z.globalRegistry, {
    description: 'A decision rule that matched within this decision evaluation.'
});

/**
 * A decision input that was evaluated within this decision evaluation.
 */
export const zEvaluatedDecisionInputItem = z.object({
    inputId: z.optional(z.string().register(z.globalRegistry, {
        description: 'The ID of the evaluated decision input.'
    })),
    inputName: z.optional(z.string().register(z.globalRegistry, {
        description: 'The name of the evaluated decision input.'
    })),
    inputValue: z.optional(z.string().register(z.globalRegistry, {
        description: 'The value of the evaluated decision input.'
    }))
}).register(z.globalRegistry, {
    description: 'A decision input that was evaluated within this decision evaluation.'
});

/**
 * A decision that was evaluated.
 */
export const zEvaluatedDecisionResult = z.object({
    decisionDefinitionId: z.optional(zDecisionDefinitionId),
    decisionDefinitionName: z.optional(z.string().register(z.globalRegistry, {
        description: 'The name of the decision which was evaluated.'
    })),
    decisionDefinitionVersion: z.optional(z.int().register(z.globalRegistry, {
        description: 'The version of the decision which was evaluated.'
    })),
    decisionDefinitionType: z.optional(z.string().register(z.globalRegistry, {
        description: 'The type of the decision which was evaluated.'
    })),
    output: z.optional(z.string().register(z.globalRegistry, {
        description: 'JSON document that will instantiate the result of the decision which was evaluated.\n'
    })),
    tenantId: z.optional(zTenantId),
    matchedRules: z.optional(z.array(zMatchedDecisionRuleItem).register(z.globalRegistry, {
        description: 'The decision rules that matched within this decision evaluation.'
    })),
    evaluatedInputs: z.optional(z.array(zEvaluatedDecisionInputItem).register(z.globalRegistry, {
        description: 'The decision inputs that were evaluated within this decision evaluation.'
    })),
    decisionDefinitionKey: z.optional(zDecisionDefinitionKey),
    decisionEvaluationInstanceKey: z.optional(zDecisionEvaluationInstanceKey)
}).register(z.globalRegistry, {
    description: 'A decision that was evaluated.'
});

export const zEvaluateDecisionResult = z.object({
    decisionDefinitionId: zDecisionDefinitionId,
    decisionDefinitionName: z.string().register(z.globalRegistry, {
        description: 'The name of the decision which was evaluated.'
    }),
    decisionDefinitionVersion: z.int().register(z.globalRegistry, {
        description: 'The version of the decision which was evaluated.'
    }),
    decisionRequirementsId: z.string().register(z.globalRegistry, {
        description: 'The ID of the decision requirements graph that the decision which was evaluated is part of.'
    }),
    output: z.string().register(z.globalRegistry, {
        description: 'JSON document that will instantiate the result of the decision which was evaluated.\n'
    }),
    failedDecisionDefinitionId: zDecisionDefinitionId,
    failureMessage: z.string().register(z.globalRegistry, {
        description: 'Message describing why the decision which was evaluated failed.'
    }),
    tenantId: zTenantId,
    decisionDefinitionKey: zDecisionDefinitionKey,
    decisionRequirementsKey: zDecisionRequirementsKey,
    decisionInstanceKey: z.optional(zDecisionInstanceKey),
    decisionEvaluationKey: zDecisionEvaluationKey,
    evaluatedDecisions: z.array(zEvaluatedDecisionResult).register(z.globalRegistry, {
        description: 'Decisions that were evaluated within the requested decision evaluation.'
    })
});

export const zDecisionInstanceSearchQuerySortRequest = z.object({
    field: z.enum([
        'decisionDefinitionId',
        'decisionDefinitionKey',
        'decisionDefinitionName',
        'decisionDefinitionType',
        'decisionDefinitionVersion',
        'decisionEvaluationInstanceKey',
        'decisionEvaluationKey',
        'elementInstanceKey',
        'evaluationDate',
        'evaluationFailure',
        'processDefinitionKey',
        'processInstanceKey',
        'state',
        'tenantId'
    ]).register(z.globalRegistry, {
        description: 'The field to sort by.'
    }),
    order: z.optional(zSortOrderEnum)
});

/**
 * The state of the decision instance.
 */
export const zDecisionInstanceStateEnum = z.enum([
    'EVALUATED',
    'FAILED',
    'UNSPECIFIED',
    'UNKNOWN'
]).register(z.globalRegistry, {
    description: 'The state of the decision instance.'
});

/**
 * The type of the decision.
 */
export const zDecisionDefinitionTypeEnum = z.enum([
    'DECISION_TABLE',
    'LITERAL_EXPRESSION',
    'UNSPECIFIED',
    'UNKNOWN'
]).register(z.globalRegistry, {
    description: 'The type of the decision.'
});

/**
 * Decision instance search filter.
 */
export const zDecisionInstanceFilter = z.object({
    decisionEvaluationInstanceKey: z.optional(zDecisionEvaluationInstanceKey),
    state: z.optional(zDecisionInstanceStateEnum),
    evaluationFailure: z.optional(z.string().register(z.globalRegistry, {
        description: 'The evaluation failure of the decision instance.'
    })),
    evaluationDate: z.optional(zDateTimeFilterProperty),
    decisionDefinitionId: z.optional(zDecisionDefinitionId),
    decisionDefinitionName: z.optional(z.string().register(z.globalRegistry, {
        description: 'The name of the DMN decision.'
    })),
    decisionDefinitionVersion: z.optional(z.int().register(z.globalRegistry, {
        description: 'The version of the decision.'
    })),
    decisionDefinitionType: z.optional(zDecisionDefinitionTypeEnum),
    tenantId: z.optional(zTenantId),
    decisionEvaluationKey: z.optional(zDecisionEvaluationKey),
    processDefinitionKey: z.optional(zProcessDefinitionKey),
    processInstanceKey: z.optional(zProcessInstanceKey),
    decisionDefinitionKey: z.optional(zDecisionDefinitionKeyFilterProperty),
    elementInstanceKey: z.optional(zElementInstanceKeyFilterProperty)
}).register(z.globalRegistry, {
    description: 'Decision instance search filter.'
});

export const zDecisionInstanceSearchQuery = zSearchQueryRequest.and(z.object({
    sort: z.optional(z.array(zDecisionInstanceSearchQuerySortRequest).register(z.globalRegistry, {
        description: 'Sort field criteria.'
    })),
    filter: z.optional(zDecisionInstanceFilter)
}));

export const zDecisionInstanceResult = z.object({
    decisionEvaluationInstanceKey: z.optional(zDecisionEvaluationInstanceKey),
    state: z.optional(zDecisionInstanceStateEnum),
    evaluationDate: z.optional(z.iso.datetime().register(z.globalRegistry, {
        description: 'The evaluation date of the decision instance.'
    })),
    evaluationFailure: z.optional(z.string().register(z.globalRegistry, {
        description: 'The evaluation failure of the decision instance.'
    })),
    decisionDefinitionId: z.optional(zDecisionDefinitionId),
    decisionDefinitionName: z.optional(z.string().register(z.globalRegistry, {
        description: 'The name of the DMN decision.'
    })),
    decisionDefinitionVersion: z.optional(z.int().register(z.globalRegistry, {
        description: 'The version of the decision.'
    })),
    decisionDefinitionType: z.optional(zDecisionDefinitionTypeEnum),
    result: z.optional(z.string().register(z.globalRegistry, {
        description: 'The result of the decision instance.'
    })),
    tenantId: z.optional(zTenantId),
    decisionEvaluationKey: z.optional(zDecisionEvaluationKey),
    processDefinitionKey: z.optional(zProcessDefinitionKey),
    processInstanceKey: z.optional(zProcessInstanceKey),
    decisionDefinitionKey: z.optional(zDecisionDefinitionKey),
    elementInstanceKey: z.optional(zElementInstanceKey)
});

export const zDecisionInstanceSearchQueryResult = zSearchQueryResponse.and(z.object({
    items: z.optional(z.array(zDecisionInstanceResult).register(z.globalRegistry, {
        description: 'The matching decision instances.'
    }))
}));

export const zDecisionInstanceGetQueryResult = zDecisionInstanceResult.and(z.object({
    evaluatedInputs: z.optional(z.array(zEvaluatedDecisionInputItem).register(z.globalRegistry, {
        description: 'The evaluated inputs of the decision instance.\n'
    })),
    matchedRules: z.optional(z.array(zMatchedDecisionRuleItem).register(z.globalRegistry, {
        description: 'The matched rules of the decision instance.\n'
    }))
}));

export const zMessageCorrelationRequest = z.object({
    name: z.string().register(z.globalRegistry, {
        description: 'The message name as defined in the BPMN process\n'
    }),
    correlationKey: z.optional(z.string().register(z.globalRegistry, {
        description: 'The correlation key of the message.'
    })).default(''),
    variables: z.optional(z.record(z.string(), z.unknown()).register(z.globalRegistry, {
        description: 'The message variables as JSON document'
    })),
    tenantId: z.optional(zTenantId)
});

/**
 * The message key of the correlated message, as well as the first process instance key it
 * correlated with.
 *
 */
export const zMessageCorrelationResult = z.object({
    tenantId: z.optional(zTenantId),
    messageKey: z.optional(zMessageCorrelationKey),
    processInstanceKey: z.optional(zProcessInstanceKey)
}).register(z.globalRegistry, {
    description: 'The message key of the correlated message, as well as the first process instance key it\ncorrelated with.\n'
});

export const zMessagePublicationRequest = z.object({
    name: z.string().register(z.globalRegistry, {
        description: 'The name of the message.'
    }),
    correlationKey: z.optional(z.string().register(z.globalRegistry, {
        description: 'The correlation key of the message.'
    })).default(''),
    timeToLive: z.optional(z.coerce.bigint().register(z.globalRegistry, {
        description: 'Timespan (in ms) to buffer the message on the broker.'
    })).default(BigInt(0)),
    messageId: z.optional(z.string().register(z.globalRegistry, {
        description: 'The unique ID of the message. This is used to ensure only one message with the given ID\nwill be published during the lifetime of the message (if `timeToLive` is set).\n'
    })),
    variables: z.optional(z.record(z.string(), z.unknown()).register(z.globalRegistry, {
        description: 'The message variables as JSON document.'
    })),
    tenantId: z.optional(zTenantId)
});

/**
 * The message key of the published message.
 */
export const zMessagePublicationResult = z.object({
    tenantId: z.optional(zTenantId),
    messageKey: z.optional(zMessageKey)
}).register(z.globalRegistry, {
    description: 'The message key of the published message.'
});

/**
 * Document Id that uniquely identifies a document.
 */
export const zDocumentId = z.string().register(z.globalRegistry, {
    description: 'Document Id that uniquely identifies a document.'
});

/**
 * Information about the document.
 */
export const zDocumentMetadata = z.object({
    contentType: z.optional(z.string().register(z.globalRegistry, {
        description: 'The content type of the document.'
    })),
    fileName: z.optional(z.string().register(z.globalRegistry, {
        description: 'The name of the file.'
    })),
    expiresAt: z.optional(z.iso.datetime().register(z.globalRegistry, {
        description: 'The date and time when the document expires.'
    })),
    size: z.optional(z.coerce.bigint().register(z.globalRegistry, {
        description: 'The size of the document in bytes.'
    })),
    processDefinitionId: z.optional(zProcessDefinitionId),
    processInstanceKey: z.optional(zProcessInstanceKey),
    customProperties: z.optional(z.record(z.string(), z.unknown()).register(z.globalRegistry, {
        description: 'Custom properties of the document.'
    }))
}).register(z.globalRegistry, {
    description: 'Information about the document.'
});

export const zDocumentReference = z.object({
    'camunda.document.type': z.optional(z.enum([
        'camunda'
    ]).register(z.globalRegistry, {
        description: 'Document discriminator. Always set to "camunda".'
    })),
    storeId: z.optional(z.string().register(z.globalRegistry, {
        description: 'The ID of the document store.'
    })),
    documentId: z.optional(zDocumentId),
    contentHash: z.optional(z.string().register(z.globalRegistry, {
        description: 'The hash of the document.'
    })),
    metadata: z.optional(zDocumentMetadata)
});

export const zDocumentCreationFailureDetail = z.object({
    fileName: z.optional(z.string().register(z.globalRegistry, {
        description: 'The name of the file.'
    })),
    detail: z.optional(z.string().register(z.globalRegistry, {
        description: 'The detail of the failure.'
    }))
});

export const zDocumentCreationBatchResponse = z.object({
    createdDocuments: z.optional(z.array(zDocumentReference).register(z.globalRegistry, {
        description: 'Documents that were successfully created.'
    })),
    failedDocuments: z.optional(z.array(zDocumentCreationFailureDetail).register(z.globalRegistry, {
        description: 'Documents that failed creation.'
    }))
});

export const zDocumentLinkRequest = z.object({
    timeToLive: z.optional(z.coerce.bigint().register(z.globalRegistry, {
        description: 'The time-to-live of the document link in ms.'
    })).default(BigInt(3600000))
});

export const zDocumentLink = z.object({
    url: z.optional(z.string().register(z.globalRegistry, {
        description: 'The link to the document.'
    })),
    expiresAt: z.optional(z.iso.datetime().register(z.globalRegistry, {
        description: 'The date and time when the link expires.'
    }))
});

/**
 * A deployed process.
 */
export const zDeploymentProcessResult = z.object({
    processDefinitionId: zProcessDefinitionId,
    processDefinitionVersion: z.int().register(z.globalRegistry, {
        description: 'The assigned process version.'
    }),
    resourceName: z.string().register(z.globalRegistry, {
        description: 'The resource name from which this process was parsed.'
    }),
    tenantId: zTenantId,
    processDefinitionKey: zProcessDefinitionKey
}).register(z.globalRegistry, {
    description: 'A deployed process.'
});

/**
 * A deployed decision.
 */
export const zDeploymentDecisionResult = z.object({
    decisionDefinitionId: z.optional(zDecisionDefinitionId),
    version: z.optional(z.int().register(z.globalRegistry, {
        description: 'The assigned decision version.'
    })),
    name: z.optional(z.string().register(z.globalRegistry, {
        description: 'The DMN name of the decision, as parsed during deployment.'
    })),
    tenantId: z.optional(zTenantId),
    decisionRequirementsId: z.optional(z.string().register(z.globalRegistry, {
        description: 'The dmn ID of the decision requirements graph that this decision is part of, as parsed during deployment.\n'
    })),
    decisionDefinitionKey: z.optional(zDecisionDefinitionKey),
    decisionRequirementsKey: z.optional(zDecisionRequirementsKey)
}).register(z.globalRegistry, {
    description: 'A deployed decision.'
});

/**
 * Deployed decision requirements.
 */
export const zDeploymentDecisionRequirementsResult = z.object({
    decisionRequirementsId: z.optional(z.string().register(z.globalRegistry, {
        description: 'The dmn decision requirements ID, as parsed during deployment; together with the versions forms a unique identifier for a specific decision.\n'
    })),
    version: z.optional(z.int().register(z.globalRegistry, {
        description: 'The assigned decision requirements version.'
    })),
    decisionRequirementsName: z.optional(z.string().register(z.globalRegistry, {
        description: 'The DMN name of the decision requirements, as parsed during deployment.'
    })),
    tenantId: z.optional(zTenantId),
    resourceName: z.optional(z.string().register(z.globalRegistry, {
        description: 'The resource name from which this decision requirements was parsed.'
    })),
    decisionRequirementsKey: z.optional(zDecisionRequirementsKey)
}).register(z.globalRegistry, {
    description: 'Deployed decision requirements.'
});

/**
 * A deployed form.
 */
export const zDeploymentFormResult = z.object({
    formId: z.optional(zFormId),
    version: z.optional(z.int().register(z.globalRegistry, {
        description: 'The assigned form version.'
    })),
    resourceName: z.optional(z.string().register(z.globalRegistry, {
        description: 'The resource name from which this form was parsed.'
    })),
    tenantId: z.optional(zTenantId),
    formKey: z.optional(zFormKey)
}).register(z.globalRegistry, {
    description: 'A deployed form.'
});

/**
 * A deployed Resource.
 */
export const zDeploymentResourceResult = z.object({
    resourceId: z.optional(z.string().register(z.globalRegistry, {
        description: 'The resource ID, as parsed during deployment, together with the version forms a\nunique identifier for a specific form.\n'
    })),
    version: z.optional(z.int().register(z.globalRegistry, {
        description: 'The assigned resource version.'
    })),
    resourceName: z.optional(z.string().register(z.globalRegistry, {
        description: 'The resource name from which this resource was parsed.'
    })),
    tenantId: z.optional(zTenantId),
    resourceKey: z.optional(zResourceKey)
}).register(z.globalRegistry, {
    description: 'A deployed Resource.'
});

export const zDeploymentMetadataResult = z.object({
    processDefinition: z.optional(zDeploymentProcessResult),
    decisionDefinition: z.optional(zDeploymentDecisionResult),
    decisionRequirements: z.optional(zDeploymentDecisionRequirementsResult),
    form: z.optional(zDeploymentFormResult),
    resource: z.optional(zDeploymentResourceResult)
});

export const zDeploymentResult = z.object({
    tenantId: zTenantId,
    deploymentKey: zDeploymentKey,
    deployments: z.array(zDeploymentMetadataResult).register(z.globalRegistry, {
        description: 'Items deployed by the request.'
    })
});

export const zIncidentResolutionRequest = z.object({
    operationReference: z.optional(zOperationReference)
});

export const zProcessInstanceCreationStartInstruction = z.object({
    elementId: zElementId
});

/**
 * Terminates the process instance after a specific BPMN element is completed or terminated.
 *
 */
export const zProcessInstanceCreationTerminateInstruction = z.object({
    afterElementId: zElementId
}).register(z.globalRegistry, {
    description: 'Terminates the process instance after a specific BPMN element is completed or terminated.\n'
});

export const zProcessInstanceCreationRuntimeInstruction = z.object({
    type: z.literal('TERMINATE_PROCESS_INSTANCE')
}).and(zProcessInstanceCreationTerminateInstruction).and(z.object({
    type: z.enum([
        'TERMINATE_PROCESS_INSTANCE'
    ]).register(z.globalRegistry, {
        description: 'The type of the runtime instruction'
    })
}).register(z.globalRegistry, {
    description: 'Runtime instructions'
}));

/**
 * Process creation by ID
 */
export const zProcessInstanceCreationInstructionById = z.object({
    processDefinitionId: zProcessDefinitionId,
    processDefinitionVersion: z.optional(z.int().register(z.globalRegistry, {
        description: 'The version of the process. By default, the latest version of the process is used.\n'
    })).default(-1),
    variables: z.optional(z.record(z.string(), z.unknown()).register(z.globalRegistry, {
        description: 'JSON object that will instantiate the variables for the root variable scope\nof the process instance.\n'
    })),
    tenantId: z.optional(zTenantId),
    operationReference: z.optional(zOperationReference),
    startInstructions: z.optional(z.array(zProcessInstanceCreationStartInstruction).register(z.globalRegistry, {
        description: 'List of start instructions. By default, the process instance will start at\nthe start event. If provided, the process instance will apply start instructions\nafter it has been created.\n'
    })),
    runtimeInstructions: z.optional(z.array(zProcessInstanceCreationRuntimeInstruction).register(z.globalRegistry, {
        description: 'Runtime instructions (alpha). List of instructions that affect the runtime behavior of\nthe process instance. Refer to specific instruction types for more details.\n\nThis parameter is an alpha feature and may be subject to change\nin future releases.\n'
    })),
    awaitCompletion: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Wait for the process instance to complete. If the process instance completion does\nnot occur within the requestTimeout, the request will be closed. This can lead to a 504\nresponse status. Disabled by default.\n'
    })).default(false),
    fetchVariables: z.optional(z.array(z.string()).register(z.globalRegistry, {
        description: 'List of variables by name to be included in the response when awaitCompletion is set to true.\nIf empty, all visible variables in the root scope will be returned.\n'
    })),
    requestTimeout: z.optional(z.coerce.bigint().register(z.globalRegistry, {
        description: 'Timeout (in ms) the request waits for the process to complete. By default or\nwhen set to 0, the generic request timeout configured in the cluster is applied.\n'
    })).default(BigInt(0)),
    tags: z.optional(zTagSet)
});

/**
 * Process creation by key
 */
export const zProcessInstanceCreationInstructionByKey = z.object({
    processDefinitionKey: zProcessDefinitionKey,
    variables: z.optional(z.record(z.string(), z.unknown()).register(z.globalRegistry, {
        description: 'JSON object that will instantiate the variables for the root variable scope\nof the process instance.\n'
    })),
    tenantId: z.optional(zTenantId),
    operationReference: z.optional(zOperationReference),
    startInstructions: z.optional(z.array(zProcessInstanceCreationStartInstruction).register(z.globalRegistry, {
        description: 'List of start instructions. By default, the process instance will start at\nthe start event. If provided, the process instance will apply start instructions\nafter it has been created.\n'
    })),
    runtimeInstructions: z.optional(z.array(zProcessInstanceCreationRuntimeInstruction).register(z.globalRegistry, {
        description: 'Runtime instructions (alpha). List of instructions that affect the runtime behavior of\nthe process instance. Refer to specific instruction types for more details.\n\nThis parameter is an alpha feature and may be subject to change\nin future releases.\n'
    })),
    awaitCompletion: z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Wait for the process instance to complete. If the process instance completion does\nnot occur within the requestTimeout, the request will be closed. This can lead to a 504\nresponse status. Disabled by default.\n'
    })).default(false),
    fetchVariables: z.optional(z.array(z.string()).register(z.globalRegistry, {
        description: 'List of variables by name to be included in the response when awaitCompletion is set to true.\nIf empty, all visible variables in the root scope will be returned.\n'
    })),
    requestTimeout: z.optional(z.coerce.bigint().register(z.globalRegistry, {
        description: 'Timeout (in ms) the request waits for the process to complete. By default or\nwhen set to 0, the generic request timeout configured in the cluster is applied.\n'
    })).default(BigInt(0)),
    tags: z.optional(zTagSet)
});

/**
 * Instructions for creating a process instance. The process definition can be specified
 * either by ID or by key.
 *
 */
export const zProcessInstanceCreationInstruction = z.union([
    zProcessInstanceCreationInstructionById,
    zProcessInstanceCreationInstructionByKey
]);

export const zCreateProcessInstanceResult = z.object({
    processDefinitionId: zProcessDefinitionId,
    processDefinitionVersion: z.int().register(z.globalRegistry, {
        description: 'The version of the process definition which was used to create the process instance.\n'
    }),
    tenantId: zTenantId,
    variables: z.record(z.string(), z.unknown()).register(z.globalRegistry, {
        description: 'All the variables visible in the root scope.'
    }),
    processDefinitionKey: zProcessDefinitionKey,
    processInstanceKey: zProcessInstanceKey,
    tags: z.optional(zTagSet)
});

/**
 * The mapping instructions describe how to map elements from the source process definition to the target process definition.
 *
 */
export const zMigrateProcessInstanceMappingInstruction = z.object({
    sourceElementId: zElementId,
    targetElementId: zElementId
}).register(z.globalRegistry, {
    description: 'The mapping instructions describe how to map elements from the source process definition to the target process definition.\n'
});

/**
 * The migration instructions describe how to migrate a process instance from one process definition to another.
 *
 */
export const zProcessInstanceMigrationBatchOperationPlan = z.object({
    mappingInstructions: z.array(zMigrateProcessInstanceMappingInstruction).register(z.globalRegistry, {
        description: 'Element mappings from the source process instance to the target process instance.'
    }),
    targetProcessDefinitionKey: zProcessDefinitionKey
}).register(z.globalRegistry, {
    description: 'The migration instructions describe how to migrate a process instance from one process definition to another.\n'
});

export const zProcessInstanceMigrationBatchOperationRequest = z.object({
    filter: zProcessInstanceFilter,
    migrationPlan: zProcessInstanceMigrationBatchOperationPlan
});

/**
 * The migration instructions describe how to migrate a process instance from one process definition to another.
 *
 */
export const zProcessInstanceMigrationInstruction = z.object({
    mappingInstructions: z.array(zMigrateProcessInstanceMappingInstruction).register(z.globalRegistry, {
        description: 'Element mappings from the source process instance to the target process instance.'
    }),
    operationReference: z.optional(zOperationReference),
    targetProcessDefinitionKey: zProcessDefinitionKey
}).register(z.globalRegistry, {
    description: 'The migration instructions describe how to migrate a process instance from one process definition to another.\n'
});

/**
 * Instructions describing which variables should be created.
 */
export const zModifyProcessInstanceVariableInstruction = z.object({
    variables: z.record(z.string(), z.unknown()).register(z.globalRegistry, {
        description: 'JSON document that will instantiate the variables for the root variable scope of the process instance.\nIt must be a JSON object, as variables will be mapped in a key-value fashion.\n'
    }),
    scopeId: z.optional(z.string().register(z.globalRegistry, {
        description: 'The ID of the element in which scope the variables should be created.\nLeave empty to create the variables in the global scope of the process instance\n'
    })).default('')
}).register(z.globalRegistry, {
    description: 'Instructions describing which variables should be created.'
});

/**
 * Instructions describing an element that should be activated.
 */
export const zProcessInstanceModificationActivateInstruction = z.object({
    elementId: zElementId,
    variableInstructions: z.optional(z.array(zModifyProcessInstanceVariableInstruction).register(z.globalRegistry, {
        description: 'Instructions describing which variables should be created.'
    })),
    ancestorElementInstanceKey: z.optional(z.union([
        z.string().default('-1'),
        zElementInstanceKey
    ]))
}).register(z.globalRegistry, {
    description: 'Instructions describing an element that should be activated.'
});

/**
 * Instructions describing which elements should be terminated.
 */
export const zProcessInstanceModificationTerminateInstruction = z.object({
    elementInstanceKey: zElementInstanceKey
}).register(z.globalRegistry, {
    description: 'Instructions describing which elements should be terminated.'
});

export const zProcessInstanceModificationInstruction = z.object({
    operationReference: z.optional(zOperationReference),
    activateInstructions: z.optional(z.array(zProcessInstanceModificationActivateInstruction).register(z.globalRegistry, {
        description: 'Instructions describing which elements should be activated in which scopes and which variables should be created.'
    })),
    terminateInstructions: z.optional(z.array(zProcessInstanceModificationTerminateInstruction).register(z.globalRegistry, {
        description: 'Instructions describing which elements should be terminated.'
    }))
});

export const zSetVariableRequest = z.object({
    variables: z.record(z.string(), z.unknown()).register(z.globalRegistry, {
        description: 'JSON object representing the variables to set in the element’s scope.'
    }),
    local: z.optional(z.boolean().register(z.globalRegistry, {
        description: "If set to true, the variables are merged strictly into the local scope (as specified by the `elementInstanceKey`).\nOtherwise, the variables are propagated to upper scopes and set at the outermost one.\n\nLet’s consider the following example:\n\nThere are two scopes '1' and '2'.\nScope '1' is the parent scope of '2'. The effective variables of the scopes are:\n1 => { \"foo\" : 2 }\n2 => { \"bar\" : 1 }\n\nAn update request with elementInstanceKey as '2', variables { \"foo\" : 5 }, and local set\nto true leaves scope '1' unchanged and adjusts scope '2' to { \"bar\" : 1, \"foo\" 5 }.\n\nBy default, with local set to false, scope '1' will be { \"foo\": 5 }\nand scope '2' will be { \"bar\" : 1 }.\n"
    })).default(false),
    operationReference: z.optional(zOperationReference)
});

export const zDeleteResourceRequest = z.union([
    z.object({
        operationReference: z.optional(zOperationReference)
    }),
    z.null()
]);

export const zSignalBroadcastRequest = z.object({
    signalName: z.string().register(z.globalRegistry, {
        description: 'The name of the signal to broadcast.'
    }),
    variables: z.optional(z.record(z.string(), z.unknown()).register(z.globalRegistry, {
        description: 'The signal variables as a JSON object.'
    })),
    tenantId: z.optional(zTenantId)
});

export const zSignalBroadcastResult = z.object({
    tenantId: zTenantId,
    signalKey: zSignalKey
});

export const zFormResult = z.object({
    tenantId: z.optional(zTenantId),
    formId: z.optional(zFormId),
    schema: z.optional(z.record(z.string(), z.unknown()).register(z.globalRegistry, {
        description: 'The form content.'
    })),
    version: z.optional(z.coerce.bigint().register(z.globalRegistry, {
        description: 'The version of the the deployed form.'
    })),
    formKey: z.optional(zFormKey)
});

export const zResourceResult = z.object({
    resourceName: z.optional(z.string().register(z.globalRegistry, {
        description: 'The resource name from which this resource was parsed.'
    })),
    version: z.optional(z.int().register(z.globalRegistry, {
        description: 'The assigned resource version.'
    })),
    versionTag: z.optional(z.string().register(z.globalRegistry, {
        description: 'The version tag of this resource.'
    })),
    resourceId: z.optional(z.string().register(z.globalRegistry, {
        description: 'The resource ID of this resource.'
    })),
    tenantId: z.optional(zTenantId),
    resourceKey: z.optional(zResourceKey)
});

/**
 * The type of the batch operation.
 */
export const zBatchOperationTypeEnum = z.enum([
    'CANCEL_PROCESS_INSTANCE',
    'RESOLVE_INCIDENT',
    'MIGRATE_PROCESS_INSTANCE',
    'MODIFY_PROCESS_INSTANCE',
    'DELETE_PROCESS_INSTANCE',
    'ADD_VARIABLE',
    'UPDATE_VARIABLE',
    'DELETE_DECISION_DEFINITION',
    'DELETE_PROCESS_DEFINITION'
]).register(z.globalRegistry, {
    description: 'The type of the batch operation.'
});

/**
 * The created batch operation.
 */
export const zBatchOperationCreatedResult = z.object({
    batchOperationKey: z.optional(zBatchOperationKey),
    batchOperationType: z.optional(zBatchOperationTypeEnum)
}).register(z.globalRegistry, {
    description: 'The created batch operation.'
});

export const zBatchOperationSearchQuerySortRequest = z.object({
    field: z.enum([
        'batchOperationKey',
        'operationType',
        'state',
        'startDate',
        'endDate'
    ]).register(z.globalRegistry, {
        description: 'The field to sort by.'
    }),
    order: z.optional(zSortOrderEnum)
});

/**
 * Advanced filter
 * Advanced BatchOperationTypeEnum filter.
 */
export const zAdvancedBatchOperationTypeFilter = z.object({
    '$eq': z.optional(zBatchOperationTypeEnum),
    '$neq': z.optional(zBatchOperationTypeEnum),
    '$exists': z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Checks if the current property exists.'
    })),
    '$in': z.optional(z.array(zBatchOperationTypeEnum).register(z.globalRegistry, {
        description: 'Checks if the property matches any of the provided values.'
    })),
    '$like': z.optional(zLikeFilter)
}).register(z.globalRegistry, {
    description: 'Advanced BatchOperationTypeEnum filter.'
});

/**
 * BatchOperationTypeEnum property with full advanced search capabilities.
 */
export const zBatchOperationTypeFilterProperty = z.union([
    zBatchOperationTypeEnum,
    zAdvancedBatchOperationTypeFilter
]);

/**
 * The batch operation state.
 */
export const zBatchOperationStateEnum = z.enum([
    'ACTIVE',
    'CANCELED',
    'COMPLETED',
    'CREATED',
    'FAILED',
    'PARTIALLY_COMPLETED',
    'SUSPENDED'
]).register(z.globalRegistry, {
    description: 'The batch operation state.'
});

/**
 * Advanced filter
 * Advanced BatchOperationStateEnum filter.
 */
export const zAdvancedBatchOperationStateFilter = z.object({
    '$eq': z.optional(zBatchOperationStateEnum),
    '$neq': z.optional(zBatchOperationStateEnum),
    '$exists': z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Checks if the current property exists.'
    })),
    '$in': z.optional(z.array(zBatchOperationStateEnum).register(z.globalRegistry, {
        description: 'Checks if the property matches any of the provided values.'
    })),
    '$like': z.optional(zLikeFilter)
}).register(z.globalRegistry, {
    description: 'Advanced BatchOperationStateEnum filter.'
});

/**
 * BatchOperationStateEnum property with full advanced search capabilities.
 */
export const zBatchOperationStateFilterProperty = z.union([
    zBatchOperationStateEnum,
    zAdvancedBatchOperationStateFilter
]);

/**
 * Batch operation filter request.
 */
export const zBatchOperationFilter = z.object({
    batchOperationKey: z.optional(zBasicStringFilterProperty),
    operationType: z.optional(zBatchOperationTypeFilterProperty),
    state: z.optional(zBatchOperationStateFilterProperty)
}).register(z.globalRegistry, {
    description: 'Batch operation filter request.'
});

/**
 * Batch operation search request.
 */
export const zBatchOperationSearchQuery = zSearchQueryRequest.and(z.object({
    sort: z.optional(z.array(zBatchOperationSearchQuerySortRequest).register(z.globalRegistry, {
        description: 'Sort field criteria.'
    })),
    filter: z.optional(zBatchOperationFilter)
}).register(z.globalRegistry, {
    description: 'Batch operation search request.'
}));

export const zBatchOperationItemSearchQuerySortRequest = z.object({
    field: z.enum([
        'batchOperationKey',
        'itemKey',
        'processInstanceKey',
        'state'
    ]).register(z.globalRegistry, {
        description: 'The field to sort by.'
    }),
    order: z.optional(zSortOrderEnum)
});

/**
 * The state, one of ACTIVE, COMPLETED, TERMINATED.
 */
export const zBatchOperationItemStateEnum = z.enum([
    'ACTIVE',
    'COMPLETED',
    'CANCELED',
    'FAILED'
]).register(z.globalRegistry, {
    description: 'The state, one of ACTIVE, COMPLETED, TERMINATED.'
});

/**
 * Advanced filter
 * Advanced BatchOperationItemStateEnum filter.
 */
export const zAdvancedBatchOperationItemStateFilter = z.object({
    '$eq': z.optional(zBatchOperationItemStateEnum),
    '$neq': z.optional(zBatchOperationItemStateEnum),
    '$exists': z.optional(z.boolean().register(z.globalRegistry, {
        description: 'Checks if the current property exists.'
    })),
    '$in': z.optional(z.array(zBatchOperationItemStateEnum).register(z.globalRegistry, {
        description: 'Checks if the property matches any of the provided values.'
    })),
    '$like': z.optional(zLikeFilter)
}).register(z.globalRegistry, {
    description: 'Advanced BatchOperationItemStateEnum filter.'
});

/**
 * BatchOperationItemStateEnum property with full advanced search capabilities.
 */
export const zBatchOperationItemStateFilterProperty = z.union([
    zBatchOperationItemStateEnum,
    zAdvancedBatchOperationItemStateFilter
]);

/**
 * Batch operation item filter request.
 */
export const zBatchOperationItemFilter = z.object({
    batchOperationKey: z.optional(zBasicStringFilterProperty),
    itemKey: z.optional(zBasicStringFilterProperty),
    processInstanceKey: z.optional(zProcessInstanceKeyFilterProperty),
    state: z.optional(zBatchOperationItemStateFilterProperty)
}).register(z.globalRegistry, {
    description: 'Batch operation item filter request.'
});

/**
 * Batch operation item search request.
 */
export const zBatchOperationItemSearchQuery = zSearchQueryRequest.and(z.object({
    sort: z.optional(z.array(zBatchOperationItemSearchQuerySortRequest).register(z.globalRegistry, {
        description: 'Sort field criteria.'
    })),
    filter: z.optional(zBatchOperationItemFilter)
}).register(z.globalRegistry, {
    description: 'Batch operation item search request.'
}));

export const zBatchOperationError = z.object({
    partitionId: z.optional(z.int().register(z.globalRegistry, {
        description: 'The partition ID where the error occurred.'
    })),
    type: z.optional(z.enum([
        'QUERY_FAILED',
        'RESULT_BUFFER_SIZE_EXCEEDED'
    ]).register(z.globalRegistry, {
        description: 'The type of the error that occurred during the batch operation.'
    })),
    message: z.optional(z.string().register(z.globalRegistry, {
        description: 'The error message that occurred during the batch operation.'
    }))
});

export const zBatchOperationResponse = z.object({
    batchOperationKey: z.optional(zBatchOperationKey),
    state: z.optional(z.enum([
        'ACTIVE',
        'CANCELED',
        'COMPLETED',
        'CREATED',
        'FAILED',
        'PARTIALLY_COMPLETED',
        'SUSPENDED'
    ]).register(z.globalRegistry, {
        description: 'The state of the batch operation.'
    })),
    batchOperationType: z.optional(zBatchOperationTypeEnum),
    startDate: z.optional(z.iso.datetime().register(z.globalRegistry, {
        description: 'The start date of the batch operation.'
    })),
    endDate: z.optional(z.iso.datetime().register(z.globalRegistry, {
        description: 'The end date of the batch operation.'
    })),
    operationsTotalCount: z.optional(z.int().register(z.globalRegistry, {
        description: 'The total number of items contained in this batch operation.'
    })),
    operationsFailedCount: z.optional(z.int().register(z.globalRegistry, {
        description: 'The number of items which failed during execution of the batch operation. (e.g. because they are rejected by the Zeebe engine).'
    })),
    operationsCompletedCount: z.optional(z.int().register(z.globalRegistry, {
        description: 'The number of successfully completed tasks.'
    })),
    errors: z.optional(z.array(zBatchOperationError).register(z.globalRegistry, {
        description: 'The errors that occurred per partition during the batch operation.'
    }))
});

/**
 * The batch operation search query result.
 */
export const zBatchOperationSearchQueryResult = zSearchQueryResponse.and(z.object({
    items: z.optional(z.array(zBatchOperationResponse).register(z.globalRegistry, {
        description: 'The matching batch operations.'
    }))
}).register(z.globalRegistry, {
    description: 'The batch operation search query result.'
}));

export const zBatchOperationItemResponse = z.object({
    operationType: z.optional(zBatchOperationTypeEnum),
    batchOperationKey: z.optional(zBatchOperationKey),
    itemKey: z.optional(z.string().register(z.globalRegistry, {
        description: 'Key of the item, e.g. a process instance key.'
    })),
    processInstanceKey: z.optional(zProcessInstanceKey),
    state: z.optional(z.enum([
        'ACTIVE',
        'COMPLETED',
        'SKIPPED',
        'CANCELED',
        'FAILED'
    ]).register(z.globalRegistry, {
        description: 'State of the item.'
    })),
    processedDate: z.optional(z.iso.datetime().register(z.globalRegistry, {
        description: 'the date this item was processed.'
    })),
    errorMessage: z.optional(z.string().register(z.globalRegistry, {
        description: 'the error message from the engine in case of a failed operation.'
    }))
});

export const zBatchOperationItemSearchQueryResult = zSearchQueryResponse.and(z.object({
    items: z.optional(z.array(zBatchOperationItemResponse).register(z.globalRegistry, {
        description: 'The matching batch operations.'
    }))
}));

/**
 * The process instance filter that defines which process instances should be canceled.
 */
export const zProcessInstanceCancellationBatchOperationRequest = z.object({
    filter: zProcessInstanceFilter
}).register(z.globalRegistry, {
    description: 'The process instance filter that defines which process instances should be canceled.'
});

/**
 * The process instance filter that defines which process instances should have their incidents resolved.
 */
export const zProcessInstanceIncidentResolutionBatchOperationRequest = z.object({
    filter: zProcessInstanceFilter
}).register(z.globalRegistry, {
    description: 'The process instance filter that defines which process instances should have their incidents resolved.'
});

/**
 * Instructions describing a move operation. This instruction will terminate all active elementInstance
 * at sourceElementId and activate a new element instance for each terminated one at targetElementId.
 */
export const zProcessInstanceModificationMoveBatchOperationInstruction = z.object({
    sourceElementId: zElementId,
    targetElementId: zElementId
}).register(z.globalRegistry, {
    description: 'Instructions describing a move operation. This instruction will terminate all active elementInstance\nat sourceElementId and activate a new element instance for each terminated one at targetElementId.'
});

/**
 * The process instance filter to define on which process instances tokens should be moved,
 * as well as mapping instructions which active element instances should be terminated and which
 * new element instances should be activated
 *
 */
export const zProcessInstanceModificationBatchOperationRequest = z.object({
    filter: zProcessInstanceFilter,
    moveInstructions: z.array(zProcessInstanceModificationMoveBatchOperationInstruction).register(z.globalRegistry, {
        description: 'Instructions describing which elements should be activated in which scopes and which variables should be created.'
    })
}).register(z.globalRegistry, {
    description: 'The process instance filter to define on which process instances tokens should be moved,\nas well as mapping instructions which active element instances should be terminated and which\nnew element instances should be activated\n'
});

export const zGetTopologyData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Obtains the current topology of the cluster the gateway is part of.
 */
export const zGetTopologyResponse = zTopologyResponse;

export const zGetStatusData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The cluster is UP and has at least one partition with a healthy leader.
 */
export const zGetStatusResponse = z.void().register(z.globalRegistry, {
    description: 'The cluster is UP and has at least one partition with a healthy leader.'
});

export const zGetLicenseData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Obtains the current status of the Camunda license.
 */
export const zGetLicenseResponse = zLicenseResponse;

export const zGetAuthenticationData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The current user is successfully returned.
 */
export const zGetAuthenticationResponse = zCamundaUserResult;

export const zActivateJobsData = z.object({
    body: zJobActivationRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The list of activated jobs.
 */
export const zActivateJobsResponse = zJobActivationResult;

export const zSearchJobsData = z.object({
    body: z.optional(zJobSearchQuery),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The job search result.
 */
export const zSearchJobsResponse = zJobSearchQueryResult;

export const zFailJobData = z.object({
    body: z.optional(zJobFailRequest),
    path: z.object({
        jobKey: zJobKey
    }),
    query: z.optional(z.never())
});

/**
 * The job is failed.
 */
export const zFailJobResponse = z.void().register(z.globalRegistry, {
    description: 'The job is failed.'
});

export const zThrowJobErrorData = z.object({
    body: zJobErrorRequest,
    path: z.object({
        jobKey: zJobKey
    }),
    query: z.optional(z.never())
});

/**
 * An error is thrown for the job.
 */
export const zThrowJobErrorResponse = z.void().register(z.globalRegistry, {
    description: 'An error is thrown for the job.'
});

export const zCompleteJobData = z.object({
    body: z.optional(zJobCompletionRequest),
    path: z.object({
        jobKey: zJobKey
    }),
    query: z.optional(z.never())
});

/**
 * The job was completed successfully.
 */
export const zCompleteJobResponse = z.void().register(z.globalRegistry, {
    description: 'The job was completed successfully.'
});

export const zUpdateJobData = z.object({
    body: zJobUpdateRequest,
    path: z.object({
        jobKey: zJobKey
    }),
    query: z.optional(z.never())
});

/**
 * The job was updated successfully.
 */
export const zUpdateJobResponse = z.void().register(z.globalRegistry, {
    description: 'The job was updated successfully.'
});

export const zResolveIncidentData = z.object({
    body: z.optional(zIncidentResolutionRequest),
    path: z.object({
        incidentKey: zIncidentKey
    }),
    query: z.optional(z.never())
});

/**
 * The incident is marked as resolved.
 */
export const zResolveIncidentResponse = z.void().register(z.globalRegistry, {
    description: 'The incident is marked as resolved.'
});

export const zCreateTenantData = z.object({
    body: zTenantCreateRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The tenant was created successfully.
 */
export const zCreateTenantResponse = zTenantCreateResult;

export const zDeleteTenantData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        tenantId: zTenantId
    }),
    query: z.optional(z.never())
});

/**
 * The tenant was deleted successfully.
 */
export const zDeleteTenantResponse = z.void().register(z.globalRegistry, {
    description: 'The tenant was deleted successfully.'
});

export const zGetTenantData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        tenantId: zTenantId
    }),
    query: z.optional(z.never())
});

/**
 * The tenant was retrieved successfully.
 */
export const zGetTenantResponse = zTenantResult;

export const zUpdateTenantData = z.object({
    body: zTenantUpdateRequest,
    path: z.object({
        tenantId: zTenantId
    }),
    query: z.optional(z.never())
});

/**
 * The tenant was updated successfully.
 */
export const zUpdateTenantResponse = zTenantUpdateResult;

export const zUnassignUserFromTenantData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        tenantId: zTenantId,
        username: zUsername
    }),
    query: z.optional(z.never())
});

/**
 * The user was successfully unassigned from the tenant.
 */
export const zUnassignUserFromTenantResponse = z.void().register(z.globalRegistry, {
    description: 'The user was successfully unassigned from the tenant.'
});

export const zAssignUserToTenantData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        tenantId: zTenantId,
        username: zUsername
    }),
    query: z.optional(z.never())
});

/**
 * The user was successfully assigned to the tenant.
 */
export const zAssignUserToTenantResponse = z.void().register(z.globalRegistry, {
    description: 'The user was successfully assigned to the tenant.'
});

export const zSearchUsersForTenantData = z.object({
    body: z.optional(zTenantUserSearchQueryRequest),
    path: z.object({
        tenantId: zTenantId
    }),
    query: z.optional(z.never())
});

/**
 * The search result of users for the tenant.
 */
export const zSearchUsersForTenantResponse = zTenantUserSearchResult;

export const zSearchClientsForTenantData = z.object({
    body: z.optional(zTenantClientSearchQueryRequest),
    path: z.object({
        tenantId: zTenantId
    }),
    query: z.optional(z.never())
});

/**
 * The search result of users for the tenant.
 */
export const zSearchClientsForTenantResponse = zTenantClientSearchResult;

export const zSearchGroupIdsForTenantData = z.object({
    body: z.optional(zTenantGroupSearchQueryRequest),
    path: z.object({
        tenantId: zTenantId
    }),
    query: z.optional(z.never())
});

/**
 * The search result of groups for the tenant.
 */
export const zSearchGroupIdsForTenantResponse = zTenantGroupSearchResult;

export const zSearchRolesForTenantData = z.object({
    body: z.optional(zRoleSearchQueryRequest),
    path: z.object({
        tenantId: zTenantId
    }),
    query: z.optional(z.never())
});

/**
 * The search result of roles for the tenant.
 */
export const zSearchRolesForTenantResponse = zRoleSearchQueryResult;

export const zUnassignClientFromTenantData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        tenantId: zTenantId,
        clientId: z.string().register(z.globalRegistry, {
            description: 'The unique identifier of the application.'
        })
    }),
    query: z.optional(z.never())
});

/**
 * The client was successfully unassigned from the tenant.
 */
export const zUnassignClientFromTenantResponse = z.void().register(z.globalRegistry, {
    description: 'The client was successfully unassigned from the tenant.'
});

export const zAssignClientToTenantData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        tenantId: zTenantId,
        clientId: z.string().register(z.globalRegistry, {
            description: 'The ID of the client to assign.'
        })
    }),
    query: z.optional(z.never())
});

/**
 * The client was successfully assigned to the tenant.
 */
export const zAssignClientToTenantResponse = z.void().register(z.globalRegistry, {
    description: 'The client was successfully assigned to the tenant.'
});

export const zUnassignMappingRuleFromTenantData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        tenantId: zTenantId,
        mappingRuleId: z.string().register(z.globalRegistry, {
            description: 'The unique identifier of the mapping rule.'
        })
    }),
    query: z.optional(z.never())
});

/**
 * The mapping rule was successfully unassigned from the tenant.
 */
export const zUnassignMappingRuleFromTenantResponse = z.void().register(z.globalRegistry, {
    description: 'The mapping rule was successfully unassigned from the tenant.'
});

export const zAssignMappingRuleToTenantData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        tenantId: zTenantId,
        mappingRuleId: z.string().register(z.globalRegistry, {
            description: 'The unique identifier of the mapping rule.'
        })
    }),
    query: z.optional(z.never())
});

/**
 * The mapping rule was successfully assigned to the tenant.
 */
export const zAssignMappingRuleToTenantResponse = z.void().register(z.globalRegistry, {
    description: 'The mapping rule was successfully assigned to the tenant.'
});

export const zSearchMappingRulesForTenantData = z.object({
    body: z.optional(zMappingRuleSearchQueryRequest),
    path: z.object({
        tenantId: zTenantId
    }),
    query: z.optional(z.never())
});

/**
 * The search result of MappingRules for the tenant.
 */
export const zSearchMappingRulesForTenantResponse = zMappingRuleSearchQueryResult;

export const zUnassignGroupFromTenantData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        tenantId: zTenantId,
        groupId: z.string().register(z.globalRegistry, {
            description: 'The unique identifier of the group.'
        })
    }),
    query: z.optional(z.never())
});

/**
 * The group was successfully unassigned from the tenant.
 */
export const zUnassignGroupFromTenantResponse = z.void().register(z.globalRegistry, {
    description: 'The group was successfully unassigned from the tenant.'
});

export const zAssignGroupToTenantData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        tenantId: zTenantId,
        groupId: z.string().register(z.globalRegistry, {
            description: 'The unique identifier of the group.'
        })
    }),
    query: z.optional(z.never())
});

/**
 * The group was successfully assigned to the tenant.
 */
export const zAssignGroupToTenantResponse = z.void().register(z.globalRegistry, {
    description: 'The group was successfully assigned to the tenant.'
});

export const zUnassignRoleFromTenantData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        tenantId: zTenantId,
        roleId: z.string().register(z.globalRegistry, {
            description: 'The unique identifier of the role.'
        })
    }),
    query: z.optional(z.never())
});

/**
 * The role was successfully unassigned from the tenant.
 */
export const zUnassignRoleFromTenantResponse = z.void().register(z.globalRegistry, {
    description: 'The role was successfully unassigned from the tenant.'
});

export const zAssignRoleToTenantData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        tenantId: zTenantId,
        roleId: z.string().register(z.globalRegistry, {
            description: 'The unique identifier of the role.'
        })
    }),
    query: z.optional(z.never())
});

/**
 * The role was successfully assigned to the tenant.
 */
export const zAssignRoleToTenantResponse = z.void().register(z.globalRegistry, {
    description: 'The role was successfully assigned to the tenant.'
});

export const zSearchTenantsData = z.object({
    body: z.optional(zTenantSearchQueryRequest),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The tenants search result
 */
export const zSearchTenantsResponse = zTenantSearchQueryResult;

export const zCompleteUserTaskData = z.object({
    body: z.optional(zUserTaskCompletionRequest),
    path: z.object({
        userTaskKey: zUserTaskKey
    }),
    query: z.optional(z.never())
});

/**
 * The user task was completed successfully.
 */
export const zCompleteUserTaskResponse = z.void().register(z.globalRegistry, {
    description: 'The user task was completed successfully.'
});

export const zAssignUserTaskData = z.object({
    body: zUserTaskAssignmentRequest,
    path: z.object({
        userTaskKey: zUserTaskKey
    }),
    query: z.optional(z.never())
});

/**
 * The user task's assignment was adjusted.
 */
export const zAssignUserTaskResponse = z.void().register(z.globalRegistry, {
    description: "The user task's assignment was adjusted."
});

export const zGetUserTaskData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        userTaskKey: zUserTaskKey
    }),
    query: z.optional(z.never())
});

/**
 * The user task is successfully returned.
 *
 */
export const zGetUserTaskResponse = zUserTaskResult;

export const zUpdateUserTaskData = z.object({
    body: z.optional(zUserTaskUpdateRequest),
    path: z.object({
        userTaskKey: zUserTaskKey
    }),
    query: z.optional(z.never())
});

/**
 * The user task was updated successfully.
 */
export const zUpdateUserTaskResponse = z.void().register(z.globalRegistry, {
    description: 'The user task was updated successfully.'
});

export const zGetUserTaskFormData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        userTaskKey: zUserTaskKey
    }),
    query: z.optional(z.never())
});

export const zGetUserTaskFormResponse = z.union([
    zFormResult,
    z.void().register(z.globalRegistry, {
        description: 'The user task was found, but no form is associated with it.'
    })
]);

export const zUnassignUserTaskData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        userTaskKey: zUserTaskKey
    }),
    query: z.optional(z.never())
});

/**
 * The user task was unassigned successfully.
 */
export const zUnassignUserTaskResponse = z.void().register(z.globalRegistry, {
    description: 'The user task was unassigned successfully.'
});

export const zSearchUserTasksData = z.object({
    body: z.optional(zUserTaskSearchQuery),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The user task search result.
 */
export const zSearchUserTasksResponse = zUserTaskSearchQueryResult;

export const zSearchUserTaskVariablesData = z.object({
    body: z.optional(zUserTaskVariableSearchQueryRequest),
    path: z.object({
        userTaskKey: zUserTaskKey
    }),
    query: z.optional(z.never())
});

/**
 * The user task variables search response.
 *
 */
export const zSearchUserTaskVariablesResponse = zVariableSearchQueryResult;

export const zSearchVariablesData = z.object({
    body: z.optional(zVariableSearchQuery),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The variable search result.
 */
export const zSearchVariablesResponse = zVariableSearchQueryResult;

export const zGetVariableData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        variableKey: zVariableKey
    }),
    query: z.optional(z.never())
});

/**
 * The variable is successfully returned.
 */
export const zGetVariableResponse = zVariableResult;

export const zPinClockData = z.object({
    body: zClockPinRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The clock was successfully pinned to the specified time in epoch milliseconds.
 *
 */
export const zPinClockResponse = z.void().register(z.globalRegistry, {
    description: 'The clock was successfully pinned to the specified time in epoch milliseconds.\n'
});

export const zResetClockData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The clock was successfully reset to the system time.
 */
export const zResetClockResponse = z.void().register(z.globalRegistry, {
    description: 'The clock was successfully reset to the system time.'
});

export const zSearchProcessDefinitionsData = z.object({
    body: z.optional(zProcessDefinitionSearchQuery),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The process definition search result.
 */
export const zSearchProcessDefinitionsResponse = zProcessDefinitionSearchQueryResult;

export const zGetProcessDefinitionData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        processDefinitionKey: zProcessDefinitionKey
    }),
    query: z.optional(z.never())
});

/**
 * The process definition is successfully returned.
 */
export const zGetProcessDefinitionResponse = zProcessDefinitionResult;

export const zGetProcessDefinitionXmlData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        processDefinitionKey: zProcessDefinitionKey
    }),
    query: z.optional(z.never())
});

/**
 * The XML of the process definition is successfully returned.
 */
export const zGetProcessDefinitionXmlResponse = z.string().register(z.globalRegistry, {
    description: 'The XML of the process definition is successfully returned.'
});

export const zGetStartProcessFormData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        processDefinitionKey: zProcessDefinitionKey
    }),
    query: z.optional(z.never())
});

export const zGetStartProcessFormResponse = z.union([
    zFormResult,
    z.void().register(z.globalRegistry, {
        description: 'The process was found, but no form is associated with it.'
    })
]);

export const zGetProcessDefinitionStatisticsData = z.object({
    body: z.optional(zProcessDefinitionElementStatisticsQuery),
    path: z.object({
        processDefinitionKey: zProcessDefinitionKey
    }),
    query: z.optional(z.never())
});

/**
 * The process definition statistics result.
 */
export const zGetProcessDefinitionStatisticsResponse = zProcessDefinitionElementStatisticsQueryResult;

export const zCreateProcessInstanceData = z.object({
    body: zProcessInstanceCreationInstruction,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The process instance was created.
 */
export const zCreateProcessInstanceResponse = zCreateProcessInstanceResult;

export const zGetProcessInstanceData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        processInstanceKey: zProcessInstanceKey
    }),
    query: z.optional(z.never())
});

/**
 * The process instance is successfully returned.
 */
export const zGetProcessInstanceResponse = zProcessInstanceResult;

export const zGetProcessInstanceSequenceFlowsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        processInstanceKey: zProcessInstanceKey
    }),
    query: z.optional(z.never())
});

/**
 * The process instance sequence flows result.
 */
export const zGetProcessInstanceSequenceFlowsResponse = zProcessInstanceSequenceFlowsQueryResult;

export const zGetProcessInstanceStatisticsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        processInstanceKey: zProcessInstanceKey
    }),
    query: z.optional(z.never())
});

/**
 * The process instance statistics result.
 */
export const zGetProcessInstanceStatisticsResponse = zProcessInstanceElementStatisticsQueryResult;

export const zSearchProcessInstancesData = z.object({
    body: z.optional(zProcessInstanceSearchQuery),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The process instance search result.
 */
export const zSearchProcessInstancesResponse = zProcessInstanceSearchQueryResult;

export const zSearchProcessInstanceIncidentsData = z.object({
    body: z.optional(zProcessInstanceIncidentSearchQuery),
    path: z.object({
        processInstanceKey: zProcessInstanceKey
    }),
    query: z.optional(z.never())
});

/**
 * The process instance search result.
 */
export const zSearchProcessInstanceIncidentsResponse = zIncidentSearchQueryResult;

export const zCancelProcessInstanceData = z.object({
    body: z.optional(zCancelProcessInstanceRequest),
    path: z.object({
        processInstanceKey: zProcessInstanceKey
    }),
    query: z.optional(z.never())
});

/**
 * The process instance is canceled.
 */
export const zCancelProcessInstanceResponse = z.void().register(z.globalRegistry, {
    description: 'The process instance is canceled.'
});

export const zCancelProcessInstancesBatchOperationData = z.object({
    body: zProcessInstanceCancellationBatchOperationRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The batch operation request was created.
 */
export const zCancelProcessInstancesBatchOperationResponse = zBatchOperationCreatedResult;

export const zResolveIncidentsBatchOperationData = z.object({
    body: z.optional(zProcessInstanceIncidentResolutionBatchOperationRequest),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The batch operation request was created.
 */
export const zResolveIncidentsBatchOperationResponse = zBatchOperationCreatedResult;

export const zMigrateProcessInstancesBatchOperationData = z.object({
    body: zProcessInstanceMigrationBatchOperationRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The batch operation request was created.
 */
export const zMigrateProcessInstancesBatchOperationResponse = zBatchOperationCreatedResult;

export const zModifyProcessInstancesBatchOperationData = z.object({
    body: zProcessInstanceModificationBatchOperationRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The batch operation request was created.
 */
export const zModifyProcessInstancesBatchOperationResponse = zBatchOperationCreatedResult;

export const zMigrateProcessInstanceData = z.object({
    body: zProcessInstanceMigrationInstruction,
    path: z.object({
        processInstanceKey: zProcessInstanceKey
    }),
    query: z.optional(z.never())
});

/**
 * The process instance is migrated.
 */
export const zMigrateProcessInstanceResponse = z.void().register(z.globalRegistry, {
    description: 'The process instance is migrated.'
});

export const zModifyProcessInstanceData = z.object({
    body: zProcessInstanceModificationInstruction,
    path: z.object({
        processInstanceKey: zProcessInstanceKey
    }),
    query: z.optional(z.never())
});

/**
 * The process instance is modified.
 */
export const zModifyProcessInstanceResponse = z.void().register(z.globalRegistry, {
    description: 'The process instance is modified.'
});

export const zGetProcessInstanceCallHierarchyData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        processInstanceKey: zProcessInstanceKey
    }),
    query: z.optional(z.never())
});

/**
 * The call hierarchy is successfully returned.
 */
export const zGetProcessInstanceCallHierarchyResponse = z.array(zProcessInstanceCallHierarchyEntry).register(z.globalRegistry, {
    description: 'The call hierarchy is successfully returned.'
});

export const zSearchElementInstancesData = z.object({
    body: z.optional(zElementInstanceSearchQuery),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The element instance search result.
 */
export const zSearchElementInstancesResponse = zElementInstanceSearchQueryResult;

export const zGetElementInstanceData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        elementInstanceKey: zElementInstanceKey
    }),
    query: z.optional(z.never())
});

/**
 * The element instance is successfully returned.
 */
export const zGetElementInstanceResponse = zElementInstanceResult;

export const zSearchDecisionDefinitionsData = z.object({
    body: z.optional(zDecisionDefinitionSearchQuery),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The decision definition search result.
 */
export const zSearchDecisionDefinitionsResponse = zDecisionDefinitionSearchQueryResult;

export const zGetDecisionDefinitionData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        decisionDefinitionKey: zDecisionDefinitionKey
    }),
    query: z.optional(z.never())
});

/**
 * The decision definition is successfully returned.
 *
 */
export const zGetDecisionDefinitionResponse = zDecisionDefinitionResult;

export const zGetDecisionDefinitionXmlData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        decisionDefinitionKey: zDecisionDefinitionKey
    }),
    query: z.optional(z.never())
});

/**
 * The XML of the decision definition is successfully returned.
 */
export const zGetDecisionDefinitionXmlResponse = z.string().register(z.globalRegistry, {
    description: 'The XML of the decision definition is successfully returned.'
});

export const zSearchDecisionRequirementsData = z.object({
    body: z.optional(zDecisionRequirementsSearchQuery),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The decision requirements search result.
 */
export const zSearchDecisionRequirementsResponse = zDecisionRequirementsSearchQueryResult;

export const zGetDecisionRequirementsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        decisionRequirementsKey: zDecisionRequirementsKey
    }),
    query: z.optional(z.never())
});

/**
 * The decision requirements is successfully returned.
 */
export const zGetDecisionRequirementsResponse = zDecisionRequirementsResult;

export const zGetDecisionRequirementsXmlData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        decisionRequirementsKey: zDecisionRequirementsKey
    }),
    query: z.optional(z.never())
});

/**
 * The XML of the decision requirements is successfully returned.
 */
export const zGetDecisionRequirementsXmlResponse = z.string().register(z.globalRegistry, {
    description: 'The XML of the decision requirements is successfully returned.'
});

export const zSearchDecisionInstancesData = z.object({
    body: z.optional(zDecisionInstanceSearchQuery),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The decision instance search result.
 */
export const zSearchDecisionInstancesResponse = zDecisionInstanceSearchQueryResult;

export const zGetDecisionInstanceData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        decisionEvaluationInstanceKey: zDecisionEvaluationInstanceKey
    }),
    query: z.optional(z.never())
});

/**
 * The decision instance is successfully returned.
 */
export const zGetDecisionInstanceResponse = zDecisionInstanceGetQueryResult;

export const zEvaluateDecisionData = z.object({
    body: zDecisionEvaluationInstruction,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The decision was evaluated.
 */
export const zEvaluateDecisionResponse = zEvaluateDecisionResult;

export const zCreateAuthorizationData = z.object({
    body: zAuthorizationRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The authorization was created successfully.
 *
 */
export const zCreateAuthorizationResponse = zAuthorizationCreateResult;

export const zDeleteAuthorizationData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        authorizationKey: zAuthorizationKey
    }),
    query: z.optional(z.never())
});

/**
 * The authorization was deleted successfully.
 */
export const zDeleteAuthorizationResponse = z.void().register(z.globalRegistry, {
    description: 'The authorization was deleted successfully.'
});

export const zGetAuthorizationData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        authorizationKey: zAuthorizationKey
    }),
    query: z.optional(z.never())
});

/**
 * The authorization was successfully returned.
 */
export const zGetAuthorizationResponse = zAuthorizationResult;

export const zUpdateAuthorizationData = z.object({
    body: zAuthorizationRequest,
    path: z.object({
        authorizationKey: zAuthorizationKey
    }),
    query: z.optional(z.never())
});

/**
 * The authorization was updated successfully.
 */
export const zUpdateAuthorizationResponse = z.void().register(z.globalRegistry, {
    description: 'The authorization was updated successfully.'
});

export const zSearchAuthorizationsData = z.object({
    body: z.optional(zAuthorizationSearchQuery),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The authorization search result.
 */
export const zSearchAuthorizationsResponse = zAuthorizationSearchResult;

export const zCreateRoleData = z.object({
    body: z.optional(zRoleCreateRequest),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The role was created successfully.
 *
 */
export const zCreateRoleResponse = zRoleCreateResult;

export const zDeleteRoleData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        roleId: z.string().register(z.globalRegistry, {
            description: 'The ID of the role to delete.'
        })
    }),
    query: z.optional(z.never())
});

/**
 * The role was deleted successfully.
 */
export const zDeleteRoleResponse = z.void().register(z.globalRegistry, {
    description: 'The role was deleted successfully.'
});

export const zGetRoleData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        roleId: z.string().register(z.globalRegistry, {
            description: 'The role ID.'
        })
    }),
    query: z.optional(z.never())
});

/**
 * The role is successfully returned.
 */
export const zGetRoleResponse = zRoleResult;

export const zUpdateRoleData = z.object({
    body: zRoleUpdateRequest,
    path: z.object({
        roleId: z.string().register(z.globalRegistry, {
            description: 'The ID of the role to update.'
        })
    }),
    query: z.optional(z.never())
});

/**
 * The role was updated successfully.
 */
export const zUpdateRoleResponse = zRoleUpdateResult;

export const zSearchUsersForRoleData = z.object({
    body: z.optional(zRoleUserSearchQueryRequest),
    path: z.object({
        roleId: z.string().register(z.globalRegistry, {
            description: 'The role ID.'
        })
    }),
    query: z.optional(z.never())
});

/**
 * The users with the assigned role.
 */
export const zSearchUsersForRoleResponse = zRoleUserSearchResult;

export const zSearchClientsForRoleData = z.object({
    body: z.optional(zRoleClientSearchQueryRequest),
    path: z.object({
        roleId: z.string().register(z.globalRegistry, {
            description: 'The role ID.'
        })
    }),
    query: z.optional(z.never())
});

/**
 * The clients with the assigned role.
 */
export const zSearchClientsForRoleResponse = zRoleClientSearchResult;

export const zUnassignRoleFromUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        roleId: z.string().register(z.globalRegistry, {
            description: 'The role ID.'
        }),
        username: zUsername
    }),
    query: z.optional(z.never())
});

/**
 * The role was unassigned successfully from the user.
 */
export const zUnassignRoleFromUserResponse = z.void().register(z.globalRegistry, {
    description: 'The role was unassigned successfully from the user.'
});

export const zAssignRoleToUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        roleId: z.string().register(z.globalRegistry, {
            description: 'The role ID.'
        }),
        username: zUsername
    }),
    query: z.optional(z.never())
});

/**
 * The role was assigned successfully to the user.
 */
export const zAssignRoleToUserResponse = z.void().register(z.globalRegistry, {
    description: 'The role was assigned successfully to the user.'
});

export const zUnassignRoleFromClientData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        roleId: z.string().register(z.globalRegistry, {
            description: 'The role ID.'
        }),
        clientId: z.string().register(z.globalRegistry, {
            description: 'The client ID.'
        })
    }),
    query: z.optional(z.never())
});

/**
 * The role was unassigned successfully from the client.
 */
export const zUnassignRoleFromClientResponse = z.void().register(z.globalRegistry, {
    description: 'The role was unassigned successfully from the client.'
});

export const zAssignRoleToClientData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        roleId: z.string().register(z.globalRegistry, {
            description: 'The role ID.'
        }),
        clientId: z.string().register(z.globalRegistry, {
            description: 'The client ID.'
        })
    }),
    query: z.optional(z.never())
});

/**
 * The role was assigned successfully to the client.
 */
export const zAssignRoleToClientResponse = z.void().register(z.globalRegistry, {
    description: 'The role was assigned successfully to the client.'
});

export const zSearchRolesData = z.object({
    body: z.optional(zRoleSearchQueryRequest),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The roles search result.
 */
export const zSearchRolesResponse = zRoleSearchQueryResult;

export const zUnassignRoleFromGroupData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        roleId: z.string().register(z.globalRegistry, {
            description: 'The role ID.'
        }),
        groupId: z.string().register(z.globalRegistry, {
            description: 'The group ID.'
        })
    }),
    query: z.optional(z.never())
});

/**
 * The role was unassigned successfully from the group.
 */
export const zUnassignRoleFromGroupResponse = z.void().register(z.globalRegistry, {
    description: 'The role was unassigned successfully from the group.'
});

export const zAssignRoleToGroupData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        roleId: z.string().register(z.globalRegistry, {
            description: 'The role ID.'
        }),
        groupId: z.string().register(z.globalRegistry, {
            description: 'The group ID.'
        })
    }),
    query: z.optional(z.never())
});

/**
 * The role was assigned successfully to the group.
 */
export const zAssignRoleToGroupResponse = z.void().register(z.globalRegistry, {
    description: 'The role was assigned successfully to the group.'
});

export const zSearchGroupsForRoleData = z.object({
    body: z.optional(zRoleGroupSearchQueryRequest),
    path: z.object({
        roleId: z.string().register(z.globalRegistry, {
            description: 'The role ID.'
        })
    }),
    query: z.optional(z.never())
});

/**
 * The groups with assigned role.
 */
export const zSearchGroupsForRoleResponse = zRoleGroupSearchResult;

export const zUnassignRoleFromMappingRuleData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        roleId: z.string().register(z.globalRegistry, {
            description: 'The role ID.'
        }),
        mappingRuleId: z.string().register(z.globalRegistry, {
            description: 'The mapping rule ID.'
        })
    }),
    query: z.optional(z.never())
});

/**
 * The role was unassigned successfully from the mapping rule.
 */
export const zUnassignRoleFromMappingRuleResponse = z.void().register(z.globalRegistry, {
    description: 'The role was unassigned successfully from the mapping rule.'
});

export const zAssignRoleToMappingRuleData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        roleId: z.string().register(z.globalRegistry, {
            description: 'The role ID.'
        }),
        mappingRuleId: z.string().register(z.globalRegistry, {
            description: 'The mapping rule ID.'
        })
    }),
    query: z.optional(z.never())
});

/**
 * The role was assigned successfully to the mapping rule.
 */
export const zAssignRoleToMappingRuleResponse = z.void().register(z.globalRegistry, {
    description: 'The role was assigned successfully to the mapping rule.'
});

export const zSearchMappingRulesForRoleData = z.object({
    body: z.optional(zMappingRuleSearchQueryRequest),
    path: z.object({
        roleId: z.string().register(z.globalRegistry, {
            description: 'The role ID.'
        })
    }),
    query: z.optional(z.never())
});

/**
 * The mapping rules with assigned role.
 */
export const zSearchMappingRulesForRoleResponse = zMappingRuleSearchQueryResult;

export const zCreateGroupData = z.object({
    body: z.optional(zGroupCreateRequest),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The group was created successfully.
 */
export const zCreateGroupResponse = zGroupCreateResult;

export const zDeleteGroupData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        groupId: z.string().register(z.globalRegistry, {
            description: 'The ID of the group to delete.'
        })
    }),
    query: z.optional(z.never())
});

/**
 * The group was deleted successfully.
 */
export const zDeleteGroupResponse = z.void().register(z.globalRegistry, {
    description: 'The group was deleted successfully.'
});

export const zGetGroupData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        groupId: z.string().register(z.globalRegistry, {
            description: 'The group ID.'
        })
    }),
    query: z.optional(z.never())
});

/**
 * The group is successfully returned.
 */
export const zGetGroupResponse = zGroupResult;

export const zUpdateGroupData = z.object({
    body: zGroupUpdateRequest,
    path: z.object({
        groupId: z.string().register(z.globalRegistry, {
            description: 'The ID of the group to update.'
        })
    }),
    query: z.optional(z.never())
});

/**
 * The group was updated successfully.
 */
export const zUpdateGroupResponse = zGroupUpdateResult;

export const zSearchUsersForGroupData = z.object({
    body: z.optional(zGroupUserSearchQueryRequest),
    path: z.object({
        groupId: z.string().register(z.globalRegistry, {
            description: 'The group ID.'
        })
    }),
    query: z.optional(z.never())
});

/**
 * The users assigned to the group.
 */
export const zSearchUsersForGroupResponse = zGroupUserSearchResult;

export const zSearchMappingRulesForGroupData = z.object({
    body: z.optional(zMappingRuleSearchQueryRequest),
    path: z.object({
        groupId: z.string().register(z.globalRegistry, {
            description: 'The group ID.'
        })
    }),
    query: z.optional(z.never())
});

/**
 * The mapping rules assigned to the group.
 */
export const zSearchMappingRulesForGroupResponse = zMappingRuleSearchQueryResult;

export const zSearchRolesForGroupData = z.object({
    body: z.optional(zRoleSearchQueryRequest),
    path: z.object({
        groupId: z.string().register(z.globalRegistry, {
            description: 'The group ID.'
        })
    }),
    query: z.optional(z.never())
});

/**
 * The roles assigned to the group.
 */
export const zSearchRolesForGroupResponse = zRoleSearchQueryResult;

export const zSearchClientsForGroupData = z.object({
    body: z.optional(zGroupClientSearchQueryRequest),
    path: z.object({
        groupId: z.string().register(z.globalRegistry, {
            description: 'The group ID.'
        })
    }),
    query: z.optional(z.never())
});

/**
 * The clients assigned to the group.
 */
export const zSearchClientsForGroupResponse = zGroupClientSearchResult;

export const zUnassignUserFromGroupData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        groupId: z.string().register(z.globalRegistry, {
            description: 'The group ID.'
        }),
        username: zUsername
    }),
    query: z.optional(z.never())
});

/**
 * The user was unassigned successfully from the group.
 */
export const zUnassignUserFromGroupResponse = z.void().register(z.globalRegistry, {
    description: 'The user was unassigned successfully from the group.'
});

export const zAssignUserToGroupData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        groupId: z.string().register(z.globalRegistry, {
            description: 'The group ID.'
        }),
        username: zUsername
    }),
    query: z.optional(z.never())
});

/**
 * The user was assigned successfully to the group.
 */
export const zAssignUserToGroupResponse = z.void().register(z.globalRegistry, {
    description: 'The user was assigned successfully to the group.'
});

export const zUnassignClientFromGroupData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        groupId: z.string().register(z.globalRegistry, {
            description: 'The group ID.'
        }),
        clientId: z.string().register(z.globalRegistry, {
            description: 'The client ID.'
        })
    }),
    query: z.optional(z.never())
});

/**
 * The client was unassigned successfully from the group.
 */
export const zUnassignClientFromGroupResponse = z.void().register(z.globalRegistry, {
    description: 'The client was unassigned successfully from the group.'
});

export const zAssignClientToGroupData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        groupId: z.string().register(z.globalRegistry, {
            description: 'The group ID.'
        }),
        clientId: z.string().register(z.globalRegistry, {
            description: 'The client ID.'
        })
    }),
    query: z.optional(z.never())
});

/**
 * The client was assigned successfully to the group.
 */
export const zAssignClientToGroupResponse = z.void().register(z.globalRegistry, {
    description: 'The client was assigned successfully to the group.'
});

export const zUnassignMappingRuleFromGroupData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        groupId: z.string().register(z.globalRegistry, {
            description: 'The group ID.'
        }),
        mappingRuleId: z.string().register(z.globalRegistry, {
            description: 'The mapping rule ID.'
        })
    }),
    query: z.optional(z.never())
});

/**
 * The mapping rule was unassigned successfully from the group.
 */
export const zUnassignMappingRuleFromGroupResponse = z.void().register(z.globalRegistry, {
    description: 'The mapping rule was unassigned successfully from the group.'
});

export const zAssignMappingRuleToGroupData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        groupId: z.string().register(z.globalRegistry, {
            description: 'The group ID.'
        }),
        mappingRuleId: z.string().register(z.globalRegistry, {
            description: 'The mapping rule ID.'
        })
    }),
    query: z.optional(z.never())
});

/**
 * The mapping rule was assigned successfully to the group.
 */
export const zAssignMappingRuleToGroupResponse = z.void().register(z.globalRegistry, {
    description: 'The mapping rule was assigned successfully to the group.'
});

export const zSearchGroupsData = z.object({
    body: z.optional(zGroupSearchQueryRequest),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The groups search result.
 */
export const zSearchGroupsResponse = zGroupSearchQueryResult;

export const zCreateMappingRuleData = z.object({
    body: z.optional(zMappingRuleCreateRequest),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The mapping rule was created successfully.
 */
export const zCreateMappingRuleResponse = zMappingRuleCreateResult;

export const zDeleteMappingRuleData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        mappingRuleId: z.string().register(z.globalRegistry, {
            description: 'The ID of the mapping rule to delete.'
        })
    }),
    query: z.optional(z.never())
});

/**
 * The mapping rule was deleted successfully.
 */
export const zDeleteMappingRuleResponse = z.void().register(z.globalRegistry, {
    description: 'The mapping rule was deleted successfully.'
});

export const zGetMappingRuleData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        mappingRuleId: z.string().register(z.globalRegistry, {
            description: 'The ID of the mapping rule to get.'
        })
    }),
    query: z.optional(z.never())
});

/**
 * The mapping rule was returned successfully.
 */
export const zGetMappingRuleResponse = zMappingRuleResult;

export const zUpdateMappingRuleData = z.object({
    body: z.optional(zMappingRuleUpdateRequest),
    path: z.object({
        mappingRuleId: z.string().register(z.globalRegistry, {
            description: 'The ID of the mapping rule to update.'
        })
    }),
    query: z.optional(z.never())
});

/**
 * The mapping rule was updated successfully.
 */
export const zUpdateMappingRuleResponse = zMappingRuleUpdateResult;

export const zSearchMappingRuleData = z.object({
    body: z.optional(zMappingRuleSearchQueryRequest),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The mapping rule search result.
 */
export const zSearchMappingRuleResponse = zMappingRuleSearchQueryResult;

export const zPublishMessageData = z.object({
    body: zMessagePublicationRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The message was published.
 */
export const zPublishMessageResponse = zMessagePublicationResult;

export const zCorrelateMessageData = z.object({
    body: zMessageCorrelationRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The message is correlated to one or more process instances
 */
export const zCorrelateMessageResponse = zMessageCorrelationResult;

export const zSearchCorrelatedMessageSubscriptionsData = z.object({
    body: z.optional(zCorrelatedMessageSubscriptionSearchQuery),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The correlated message subscriptions search result.
 */
export const zSearchCorrelatedMessageSubscriptionsResponse = zCorrelatedMessageSubscriptionSearchQueryResult;

export const zSearchMessageSubscriptionsData = z.object({
    body: z.optional(zMessageSubscriptionSearchQuery),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The message subscription search result.
 */
export const zSearchMessageSubscriptionsResponse = zMessageSubscriptionSearchQueryResult;

export const zCreateDocumentData = z.object({
    body: z.object({
        file: z.string(),
        metadata: z.optional(zDocumentMetadata)
    }),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        storeId: z.optional(z.string().register(z.globalRegistry, {
            description: 'The ID of the document store to upload the documents to. Currently, only a single document store is supported per cluster. However, this attribute is included to allow for potential future support of multiple document stores.'
        })),
        documentId: z.optional(z.string().register(z.globalRegistry, {
            description: 'The ID of the document to upload. If not provided, a new ID will be generated. Specifying an existing ID will result in an error if the document already exists.\n'
        }))
    }))
});

/**
 * The document was uploaded successfully.
 */
export const zCreateDocumentResponse = zDocumentReference;

export const zCreateDocumentsData = z.object({
    body: z.object({
        files: z.array(z.string()).min(1).register(z.globalRegistry, {
            description: 'The documents to upload.'
        }),
        metadataList: z.optional(z.array(zDocumentMetadata).register(z.globalRegistry, {
            description: 'Optional JSON array of metadata object whose index aligns with each file entry. The metadata array must have the same length as the files array.\n'
        }))
    }),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        storeId: z.optional(z.string().register(z.globalRegistry, {
            description: 'The ID of the document store to upload the documents to. Currently, only a single document store is supported per cluster. However, this attribute is included to allow for potential future support of multiple document stores.'
        }))
    }))
});

/**
 * All documents were uploaded successfully.
 */
export const zCreateDocumentsResponse = zDocumentCreationBatchResponse;

export const zDeleteDocumentData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        documentId: zDocumentId
    }),
    query: z.optional(z.object({
        storeId: z.optional(z.string().register(z.globalRegistry, {
            description: 'The ID of the document store to delete the document from.'
        }))
    }))
});

/**
 * The document was deleted successfully.
 */
export const zDeleteDocumentResponse = z.void().register(z.globalRegistry, {
    description: 'The document was deleted successfully.'
});

export const zGetDocumentData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        documentId: zDocumentId
    }),
    query: z.object({
        storeId: z.optional(z.string().register(z.globalRegistry, {
            description: 'The ID of the document store to download the document from.'
        })),
        contentHash: z.string().register(z.globalRegistry, {
            description: 'The hash of the document content that was computed by the document store during upload. The hash is part of the document reference that is returned when uploading a document. If the client fails to provide the correct hash, the request will be rejected.\n'
        })
    })
});

/**
 * The document was downloaded successfully.
 */
export const zGetDocumentResponse = z.string().register(z.globalRegistry, {
    description: 'The document was downloaded successfully.'
});

export const zCreateDocumentLinkData = z.object({
    body: z.optional(zDocumentLinkRequest),
    path: z.object({
        documentId: zDocumentId
    }),
    query: z.object({
        storeId: z.optional(z.string().register(z.globalRegistry, {
            description: 'The ID of the document store to link the document from.'
        })),
        contentHash: z.string().register(z.globalRegistry, {
            description: 'The hash of the document content that was computed by the document store during upload. The hash is part of the document reference that is returned when uploading a document. If the client fails to provide the correct hash, the request will be rejected.\n'
        })
    })
});

/**
 * The document link was created successfully.
 */
export const zCreateDocumentLinkResponse = zDocumentLink;

export const zCreateUserData = z.object({
    body: zUserRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The user was created successfully.
 *
 */
export const zCreateUserResponse = zUserCreateResult;

export const zSearchUsersData = z.object({
    body: z.optional(zUserSearchQueryRequest),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The user search result.
 */
export const zSearchUsersResponse = zUserSearchResult;

export const zDeleteUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        username: zUsername
    }),
    query: z.optional(z.never())
});

/**
 * The user was deleted successfully.
 */
export const zDeleteUserResponse = z.void().register(z.globalRegistry, {
    description: 'The user was deleted successfully.'
});

export const zGetUserData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        username: zUsername
    }),
    query: z.optional(z.never())
});

/**
 * The user is successfully returned.
 */
export const zGetUserResponse = zUserResult;

export const zUpdateUserData = z.object({
    body: zUserUpdateRequest,
    path: z.object({
        username: zUsername
    }),
    query: z.optional(z.never())
});

/**
 * The user was updated successfully.
 */
export const zUpdateUserResponse = zUserUpdateResult;

export const zCreateAdminUserData = z.object({
    body: zUserRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The user was created and got assigned the admin role successfully.
 *
 */
export const zCreateAdminUserResponse = zUserCreateResult;

export const zSearchIncidentsData = z.object({
    body: z.optional(zIncidentSearchQuery),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The incident search result.
 *
 */
export const zSearchIncidentsResponse = zIncidentSearchQueryResult;

export const zGetIncidentData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        incidentKey: zIncidentKey
    }),
    query: z.optional(z.never())
});

/**
 * The incident is successfully returned.
 */
export const zGetIncidentResponse = zIncidentResult;

export const zGetUsageMetricsData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.object({
        startTime: z.iso.datetime().register(z.globalRegistry, {
            description: 'The start date for usage metrics, including this date. Value in ISO 8601 format.'
        }),
        endTime: z.iso.datetime().register(z.globalRegistry, {
            description: 'The end date for usage metrics, including this date. Value in ISO 8601 format.'
        }),
        tenantId: z.optional(zTenantId),
        withTenants: z.optional(z.boolean().register(z.globalRegistry, {
            description: 'Whether to return tenant metrics in addition to the total metrics or not. Default false.'
        })).default(false)
    })
});

/**
 * The usage metrics search result.
 */
export const zGetUsageMetricsResponse = zUsageMetricsResponse;

export const zCreateDeploymentData = z.object({
    body: z.object({
        resources: z.array(
            z.any().refine(
                (v) => (typeof File !== 'undefined' && v instanceof File),
                { message: 'Expected File (with a filename & extension)' }
            )
        ).nonempty().register(z.globalRegistry, {}),
        tenantId: z.optional(z.string().register(z.globalRegistry, {
            description: 'The tenant to deploy the resources to.'
        }))
    }),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The resources are deployed.
 */
export const zCreateDeploymentResponse = zDeploymentResult;

export const zDeleteResourceData = z.object({
    body: z.optional(zDeleteResourceRequest),
    path: z.object({
        resourceKey: zResourceKey
    }),
    query: z.optional(z.never())
});

export const zGetResourceData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        resourceKey: zResourceKey
    }),
    query: z.optional(z.never())
});

/**
 * The resource is successfully returned.
 */
export const zGetResourceResponse = zResourceResult;

export const zGetResourceContentData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        resourceKey: zResourceKey
    }),
    query: z.optional(z.never())
});

/**
 * The resource content is successfully returned.
 */
export const zGetResourceContentResponse = z.string().register(z.globalRegistry, {
    description: 'The resource content is successfully returned.'
});

export const zCreateElementInstanceVariablesData = z.object({
    body: zSetVariableRequest,
    path: z.object({
        elementInstanceKey: zElementInstanceKey
    }),
    query: z.optional(z.never())
});

/**
 * The variables were updated.
 */
export const zCreateElementInstanceVariablesResponse = z.void().register(z.globalRegistry, {
    description: 'The variables were updated.'
});

export const zActivateAdHocSubProcessActivitiesData = z.object({
    body: zAdHocSubProcessActivateActivitiesInstruction,
    path: z.object({
        adHocSubProcessInstanceKey: zElementInstanceKey
    }),
    query: z.optional(z.never())
});

/**
 * The ad-hoc sub-process instance is modified.
 */
export const zActivateAdHocSubProcessActivitiesResponse = z.void().register(z.globalRegistry, {
    description: 'The ad-hoc sub-process instance is modified.'
});

export const zBroadcastSignalData = z.object({
    body: zSignalBroadcastRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The signal was broadcast.
 */
export const zBroadcastSignalResponse = zSignalBroadcastResult;

export const zGetBatchOperationData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        batchOperationKey: zBatchOperationKey
    }),
    query: z.optional(z.never())
});

/**
 * The batch operation was found.
 */
export const zGetBatchOperationResponse = zBatchOperationResponse;

export const zSearchBatchOperationsData = z.object({
    body: z.optional(zBatchOperationSearchQuery),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The batch operation search result.
 */
export const zSearchBatchOperationsResponse = zBatchOperationSearchQueryResult;

export const zCancelBatchOperationData = z.object({
    body: z.optional(z.unknown()),
    path: z.object({
        batchOperationKey: zBatchOperationKey
    }),
    query: z.optional(z.never())
});

/**
 * The batch operation cancel request was created.
 */
export const zCancelBatchOperationResponse = z.void().register(z.globalRegistry, {
    description: 'The batch operation cancel request was created.'
});

export const zSuspendBatchOperationData = z.object({
    body: z.optional(z.unknown()),
    path: z.object({
        batchOperationKey: zBatchOperationKey
    }),
    query: z.optional(z.never())
});

/**
 * The batch operation pause request was created.
 */
export const zSuspendBatchOperationResponse = z.void().register(z.globalRegistry, {
    description: 'The batch operation pause request was created.'
});

export const zResumeBatchOperationData = z.object({
    body: z.optional(z.unknown()),
    path: z.object({
        batchOperationKey: zBatchOperationKey
    }),
    query: z.optional(z.never())
});

/**
 * The batch operation resume request was created.
 */
export const zResumeBatchOperationResponse = z.void().register(z.globalRegistry, {
    description: 'The batch operation resume request was created.'
});

export const zSearchBatchOperationItemsData = z.object({
    body: z.optional(zBatchOperationItemSearchQuery),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The batch operation search result.
 */
export const zSearchBatchOperationItemsResponse = zBatchOperationItemSearchQueryResult;