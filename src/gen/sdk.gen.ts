// This file is auto-generated by @hey-api/openapi-ts

import { type Client, formDataBodySerializer, type Options as Options2, type TDataShape } from './client';
import { client } from './client.gen';
import type { ActivateAdHocSubProcessActivitiesData, ActivateAdHocSubProcessActivitiesErrors, ActivateAdHocSubProcessActivitiesResponses, ActivateJobsData, ActivateJobsErrors, ActivateJobsResponses, AssignClientToGroupData, AssignClientToGroupErrors, AssignClientToGroupResponses, AssignClientToTenantData, AssignClientToTenantErrors, AssignClientToTenantResponses, AssignGroupToTenantData, AssignGroupToTenantErrors, AssignGroupToTenantResponses, AssignMappingRuleToGroupData, AssignMappingRuleToGroupErrors, AssignMappingRuleToGroupResponses, AssignMappingRuleToTenantData, AssignMappingRuleToTenantErrors, AssignMappingRuleToTenantResponses, AssignRoleToClientData, AssignRoleToClientErrors, AssignRoleToClientResponses, AssignRoleToGroupData, AssignRoleToGroupErrors, AssignRoleToGroupResponses, AssignRoleToMappingRuleData, AssignRoleToMappingRuleErrors, AssignRoleToMappingRuleResponses, AssignRoleToTenantData, AssignRoleToTenantErrors, AssignRoleToTenantResponses, AssignRoleToUserData, AssignRoleToUserErrors, AssignRoleToUserResponses, AssignUserTaskData, AssignUserTaskErrors, AssignUserTaskResponses, AssignUserToGroupData, AssignUserToGroupErrors, AssignUserToGroupResponses, AssignUserToTenantData, AssignUserToTenantErrors, AssignUserToTenantResponses, BroadcastSignalData, BroadcastSignalErrors, BroadcastSignalResponses, CancelBatchOperationData, CancelBatchOperationErrors, CancelBatchOperationResponses, CancelProcessInstanceData, CancelProcessInstanceErrors, CancelProcessInstanceResponses, CancelProcessInstancesBatchOperationData, CancelProcessInstancesBatchOperationErrors, CancelProcessInstancesBatchOperationResponses, CompleteJobData, CompleteJobErrors, CompleteJobResponses, CompleteUserTaskData, CompleteUserTaskErrors, CompleteUserTaskResponses, CorrelateMessageData, CorrelateMessageErrors, CorrelateMessageResponses, CreateAdminUserData, CreateAdminUserErrors, CreateAdminUserResponses, CreateAuthorizationData, CreateAuthorizationErrors, CreateAuthorizationResponses, CreateDeploymentData, CreateDeploymentErrors, CreateDeploymentResponses, CreateDocumentData, CreateDocumentErrors, CreateDocumentLinkData, CreateDocumentLinkErrors, CreateDocumentLinkResponses, CreateDocumentResponses, CreateDocumentsData, CreateDocumentsErrors, CreateDocumentsResponses, CreateElementInstanceVariablesData, CreateElementInstanceVariablesErrors, CreateElementInstanceVariablesResponses, CreateGlobalClusterVariableData, CreateGlobalClusterVariableErrors, CreateGlobalClusterVariableResponses, CreateGroupData, CreateGroupErrors, CreateGroupResponses, CreateMappingRuleData, CreateMappingRuleErrors, CreateMappingRuleResponses, CreateProcessInstanceData, CreateProcessInstanceErrors, CreateProcessInstanceResponses, CreateRoleData, CreateRoleErrors, CreateRoleResponses, CreateTenantClusterVariableData, CreateTenantClusterVariableErrors, CreateTenantClusterVariableResponses, CreateTenantData, CreateTenantErrors, CreateTenantResponses, CreateUserData, CreateUserErrors, CreateUserResponses, DeleteAuthorizationData, DeleteAuthorizationErrors, DeleteAuthorizationResponses, DeleteDocumentData, DeleteDocumentErrors, DeleteDocumentResponses, DeleteGlobalClusterVariableData, DeleteGlobalClusterVariableErrors, DeleteGlobalClusterVariableResponses, DeleteGroupData, DeleteGroupErrors, DeleteGroupResponses, DeleteMappingRuleData, DeleteMappingRuleErrors, DeleteMappingRuleResponses, DeleteProcessInstanceData, DeleteProcessInstanceErrors, DeleteProcessInstanceResponses, DeleteProcessInstancesBatchOperationData, DeleteProcessInstancesBatchOperationErrors, DeleteProcessInstancesBatchOperationResponses, DeleteResourceData, DeleteResourceErrors, DeleteResourceResponses, DeleteRoleData, DeleteRoleErrors, DeleteRoleResponses, DeleteTenantClusterVariableData, DeleteTenantClusterVariableErrors, DeleteTenantClusterVariableResponses, DeleteTenantData, DeleteTenantErrors, DeleteTenantResponses, DeleteUserData, DeleteUserErrors, DeleteUserResponses, EvaluateConditionalsData, EvaluateConditionalsErrors, EvaluateConditionalsResponses, EvaluateDecisionData, EvaluateDecisionErrors, EvaluateDecisionResponses, EvaluateExpressionData, EvaluateExpressionErrors, EvaluateExpressionResponses, FailJobData, FailJobErrors, FailJobResponses, GetAuditLogData, GetAuditLogErrors, GetAuditLogResponses, GetAuthenticationData, GetAuthenticationErrors, GetAuthenticationResponses, GetAuthorizationData, GetAuthorizationErrors, GetAuthorizationResponses, GetBatchOperationData, GetBatchOperationErrors, GetBatchOperationResponses, GetDecisionDefinitionData, GetDecisionDefinitionErrors, GetDecisionDefinitionResponses, GetDecisionDefinitionXmlData, GetDecisionDefinitionXmlErrors, GetDecisionDefinitionXmlResponses, GetDecisionInstanceData, GetDecisionInstanceErrors, GetDecisionInstanceResponses, GetDecisionRequirementsData, GetDecisionRequirementsErrors, GetDecisionRequirementsResponses, GetDecisionRequirementsXmlData, GetDecisionRequirementsXmlErrors, GetDecisionRequirementsXmlResponses, GetDocumentData, GetDocumentErrors, GetDocumentResponses, GetElementInstanceData, GetElementInstanceErrors, GetElementInstanceResponses, GetGlobalClusterVariableData, GetGlobalClusterVariableErrors, GetGlobalClusterVariableResponses, GetGroupData, GetGroupErrors, GetGroupResponses, GetIncidentData, GetIncidentErrors, GetIncidentResponses, GetLicenseData, GetLicenseErrors, GetLicenseResponses, GetMappingRuleData, GetMappingRuleErrors, GetMappingRuleResponses, GetProcessDefinitionData, GetProcessDefinitionErrors, GetProcessDefinitionInstanceStatisticsData, GetProcessDefinitionInstanceStatisticsErrors, GetProcessDefinitionInstanceStatisticsResponses, GetProcessDefinitionInstanceVersionStatisticsData, GetProcessDefinitionInstanceVersionStatisticsErrors, GetProcessDefinitionInstanceVersionStatisticsResponses, GetProcessDefinitionMessageSubscriptionStatisticsData, GetProcessDefinitionMessageSubscriptionStatisticsErrors, GetProcessDefinitionMessageSubscriptionStatisticsResponses, GetProcessDefinitionResponses, GetProcessDefinitionStatisticsData, GetProcessDefinitionStatisticsErrors, GetProcessDefinitionStatisticsResponses, GetProcessDefinitionXmlData, GetProcessDefinitionXmlErrors, GetProcessDefinitionXmlResponses, GetProcessInstanceCallHierarchyData, GetProcessInstanceCallHierarchyErrors, GetProcessInstanceCallHierarchyResponses, GetProcessInstanceData, GetProcessInstanceErrors, GetProcessInstanceResponses, GetProcessInstanceSequenceFlowsData, GetProcessInstanceSequenceFlowsErrors, GetProcessInstanceSequenceFlowsResponses, GetProcessInstanceStatisticsByDefinitionData, GetProcessInstanceStatisticsByDefinitionErrors, GetProcessInstanceStatisticsByDefinitionResponses, GetProcessInstanceStatisticsByErrorData, GetProcessInstanceStatisticsByErrorErrors, GetProcessInstanceStatisticsByErrorResponses, GetProcessInstanceStatisticsData, GetProcessInstanceStatisticsErrors, GetProcessInstanceStatisticsResponses, GetResourceContentData, GetResourceContentErrors, GetResourceContentResponses, GetResourceData, GetResourceErrors, GetResourceResponses, GetRoleData, GetRoleErrors, GetRoleResponses, GetStartProcessFormData, GetStartProcessFormErrors, GetStartProcessFormResponses, GetStatusData, GetStatusErrors, GetStatusResponses, GetTenantClusterVariableData, GetTenantClusterVariableErrors, GetTenantClusterVariableResponses, GetTenantData, GetTenantErrors, GetTenantResponses, GetTopologyData, GetTopologyErrors, GetTopologyResponses, GetUsageMetricsData, GetUsageMetricsErrors, GetUsageMetricsResponses, GetUserData, GetUserErrors, GetUserResponses, GetUserTaskData, GetUserTaskErrors, GetUserTaskFormData, GetUserTaskFormErrors, GetUserTaskFormResponses, GetUserTaskResponses, GetVariableData, GetVariableErrors, GetVariableResponses, MigrateProcessInstanceData, MigrateProcessInstanceErrors, MigrateProcessInstanceResponses, MigrateProcessInstancesBatchOperationData, MigrateProcessInstancesBatchOperationErrors, MigrateProcessInstancesBatchOperationResponses, ModifyProcessInstanceData, ModifyProcessInstanceErrors, ModifyProcessInstanceResponses, ModifyProcessInstancesBatchOperationData, ModifyProcessInstancesBatchOperationErrors, ModifyProcessInstancesBatchOperationResponses, PinClockData, PinClockErrors, PinClockResponses, PublishMessageData, PublishMessageErrors, PublishMessageResponses, ResetClockData, ResetClockErrors, ResetClockResponses, ResolveIncidentData, ResolveIncidentErrors, ResolveIncidentResponses, ResolveIncidentsBatchOperationData, ResolveIncidentsBatchOperationErrors, ResolveIncidentsBatchOperationResponses, ResolveProcessInstanceIncidentsData, ResolveProcessInstanceIncidentsErrors, ResolveProcessInstanceIncidentsResponses, ResumeBatchOperationData, ResumeBatchOperationErrors, ResumeBatchOperationResponses, SearchAuditLogsData, SearchAuditLogsErrors, SearchAuditLogsResponses, SearchAuthorizationsData, SearchAuthorizationsErrors, SearchAuthorizationsResponses, SearchBatchOperationItemsData, SearchBatchOperationItemsErrors, SearchBatchOperationItemsResponses, SearchBatchOperationsData, SearchBatchOperationsErrors, SearchBatchOperationsResponses, SearchClientsForGroupData, SearchClientsForGroupErrors, SearchClientsForGroupResponses, SearchClientsForRoleData, SearchClientsForRoleErrors, SearchClientsForRoleResponses, SearchClientsForTenantData, SearchClientsForTenantResponses, SearchClusterVariablesData, SearchClusterVariablesErrors, SearchClusterVariablesResponses, SearchCorrelatedMessageSubscriptionsData, SearchCorrelatedMessageSubscriptionsErrors, SearchCorrelatedMessageSubscriptionsResponses, SearchDecisionDefinitionsData, SearchDecisionDefinitionsErrors, SearchDecisionDefinitionsResponses, SearchDecisionInstancesData, SearchDecisionInstancesErrors, SearchDecisionInstancesResponses, SearchDecisionRequirementsData, SearchDecisionRequirementsErrors, SearchDecisionRequirementsResponses, SearchElementInstanceIncidentsData, SearchElementInstanceIncidentsErrors, SearchElementInstanceIncidentsResponses, SearchElementInstancesData, SearchElementInstancesErrors, SearchElementInstancesResponses, SearchGroupIdsForTenantData, SearchGroupIdsForTenantResponses, SearchGroupsData, SearchGroupsErrors, SearchGroupsForRoleData, SearchGroupsForRoleErrors, SearchGroupsForRoleResponses, SearchGroupsResponses, SearchIncidentsData, SearchIncidentsErrors, SearchIncidentsResponses, SearchJobsData, SearchJobsErrors, SearchJobsResponses, SearchMappingRuleData, SearchMappingRuleErrors, SearchMappingRuleResponses, SearchMappingRulesForGroupData, SearchMappingRulesForGroupErrors, SearchMappingRulesForGroupResponses, SearchMappingRulesForRoleData, SearchMappingRulesForRoleErrors, SearchMappingRulesForRoleResponses, SearchMappingRulesForTenantData, SearchMappingRulesForTenantResponses, SearchMessageSubscriptionsData, SearchMessageSubscriptionsErrors, SearchMessageSubscriptionsResponses, SearchProcessDefinitionsData, SearchProcessDefinitionsErrors, SearchProcessDefinitionsResponses, SearchProcessInstanceIncidentsData, SearchProcessInstanceIncidentsErrors, SearchProcessInstanceIncidentsResponses, SearchProcessInstancesData, SearchProcessInstancesErrors, SearchProcessInstancesResponses, SearchRolesData, SearchRolesErrors, SearchRolesForGroupData, SearchRolesForGroupErrors, SearchRolesForGroupResponses, SearchRolesForTenantData, SearchRolesForTenantResponses, SearchRolesResponses, SearchTenantsData, SearchTenantsErrors, SearchTenantsResponses, SearchUsersData, SearchUsersErrors, SearchUsersForGroupData, SearchUsersForGroupErrors, SearchUsersForGroupResponses, SearchUsersForRoleData, SearchUsersForRoleErrors, SearchUsersForRoleResponses, SearchUsersForTenantData, SearchUsersForTenantResponses, SearchUsersResponses, SearchUserTaskAuditLogsData, SearchUserTaskAuditLogsErrors, SearchUserTaskAuditLogsResponses, SearchUserTasksData, SearchUserTasksErrors, SearchUserTasksResponses, SearchUserTaskVariablesData, SearchUserTaskVariablesErrors, SearchUserTaskVariablesResponses, SearchVariablesData, SearchVariablesErrors, SearchVariablesResponses, SuspendBatchOperationData, SuspendBatchOperationErrors, SuspendBatchOperationResponses, ThrowJobErrorData, ThrowJobErrorErrors, ThrowJobErrorResponses, UnassignClientFromGroupData, UnassignClientFromGroupErrors, UnassignClientFromGroupResponses, UnassignClientFromTenantData, UnassignClientFromTenantErrors, UnassignClientFromTenantResponses, UnassignGroupFromTenantData, UnassignGroupFromTenantErrors, UnassignGroupFromTenantResponses, UnassignMappingRuleFromGroupData, UnassignMappingRuleFromGroupErrors, UnassignMappingRuleFromGroupResponses, UnassignMappingRuleFromTenantData, UnassignMappingRuleFromTenantErrors, UnassignMappingRuleFromTenantResponses, UnassignRoleFromClientData, UnassignRoleFromClientErrors, UnassignRoleFromClientResponses, UnassignRoleFromGroupData, UnassignRoleFromGroupErrors, UnassignRoleFromGroupResponses, UnassignRoleFromMappingRuleData, UnassignRoleFromMappingRuleErrors, UnassignRoleFromMappingRuleResponses, UnassignRoleFromTenantData, UnassignRoleFromTenantErrors, UnassignRoleFromTenantResponses, UnassignRoleFromUserData, UnassignRoleFromUserErrors, UnassignRoleFromUserResponses, UnassignUserFromGroupData, UnassignUserFromGroupErrors, UnassignUserFromGroupResponses, UnassignUserFromTenantData, UnassignUserFromTenantErrors, UnassignUserFromTenantResponses, UnassignUserTaskData, UnassignUserTaskErrors, UnassignUserTaskResponses, UpdateAuthorizationData, UpdateAuthorizationErrors, UpdateAuthorizationResponses, UpdateGroupData, UpdateGroupErrors, UpdateGroupResponses, UpdateJobData, UpdateJobErrors, UpdateJobResponses, UpdateMappingRuleData, UpdateMappingRuleErrors, UpdateMappingRuleResponses, UpdateRoleData, UpdateRoleErrors, UpdateRoleResponses, UpdateTenantData, UpdateTenantErrors, UpdateTenantResponses, UpdateUserData, UpdateUserErrors, UpdateUserResponses, UpdateUserTaskData, UpdateUserTaskErrors, UpdateUserTaskResponses } from './types.gen';
import { zActivateAdHocSubProcessActivitiesData, zActivateAdHocSubProcessActivitiesResponse, zActivateJobsData, zActivateJobsResponse, zAssignClientToGroupData, zAssignClientToGroupResponse, zAssignClientToTenantData, zAssignClientToTenantResponse, zAssignGroupToTenantData, zAssignGroupToTenantResponse, zAssignMappingRuleToGroupData, zAssignMappingRuleToGroupResponse, zAssignMappingRuleToTenantData, zAssignMappingRuleToTenantResponse, zAssignRoleToClientData, zAssignRoleToClientResponse, zAssignRoleToGroupData, zAssignRoleToGroupResponse, zAssignRoleToMappingRuleData, zAssignRoleToMappingRuleResponse, zAssignRoleToTenantData, zAssignRoleToTenantResponse, zAssignRoleToUserData, zAssignRoleToUserResponse, zAssignUserTaskData, zAssignUserTaskResponse, zAssignUserToGroupData, zAssignUserToGroupResponse, zAssignUserToTenantData, zAssignUserToTenantResponse, zBroadcastSignalData, zBroadcastSignalResponse, zCancelBatchOperationData, zCancelBatchOperationResponse, zCancelProcessInstanceData, zCancelProcessInstanceResponse, zCancelProcessInstancesBatchOperationData, zCancelProcessInstancesBatchOperationResponse, zCompleteJobData, zCompleteJobResponse, zCompleteUserTaskData, zCompleteUserTaskResponse, zCorrelateMessageData, zCorrelateMessageResponse, zCreateAdminUserData, zCreateAuthorizationData, zCreateAuthorizationResponse, zCreateDeploymentData, zCreateDeploymentResponse, zCreateDocumentData, zCreateDocumentLinkData, zCreateDocumentLinkResponse, zCreateDocumentResponse, zCreateDocumentsData, zCreateDocumentsResponse, zCreateElementInstanceVariablesData, zCreateElementInstanceVariablesResponse, zCreateGlobalClusterVariableData, zCreateGlobalClusterVariableResponse, zCreateGroupData, zCreateGroupResponse, zCreateMappingRuleData, zCreateMappingRuleResponse, zCreateProcessInstanceData, zCreateProcessInstanceResponse, zCreateRoleData, zCreateRoleResponse, zCreateTenantClusterVariableData, zCreateTenantClusterVariableResponse, zCreateTenantData, zCreateTenantResponse, zCreateUserData, zCreateUserResponse, zDeleteAuthorizationData, zDeleteAuthorizationResponse, zDeleteDocumentData, zDeleteDocumentResponse, zDeleteGlobalClusterVariableData, zDeleteGlobalClusterVariableResponse, zDeleteGroupData, zDeleteGroupResponse, zDeleteMappingRuleData, zDeleteMappingRuleResponse, zDeleteProcessInstanceData, zDeleteProcessInstanceResponse, zDeleteProcessInstancesBatchOperationData, zDeleteProcessInstancesBatchOperationResponse, zDeleteResourceData, zDeleteRoleData, zDeleteRoleResponse, zDeleteTenantClusterVariableData, zDeleteTenantClusterVariableResponse, zDeleteTenantData, zDeleteTenantResponse, zDeleteUserData, zDeleteUserResponse, zEvaluateConditionalsData, zEvaluateConditionalsResponse, zEvaluateDecisionData, zEvaluateDecisionResponse, zEvaluateExpressionData, zEvaluateExpressionResponse, zFailJobData, zFailJobResponse, zGetAuditLogData, zGetAuditLogResponse, zGetAuthenticationData, zGetAuthenticationResponse, zGetAuthorizationData, zGetAuthorizationResponse, zGetBatchOperationData, zGetBatchOperationResponse, zGetDecisionDefinitionData, zGetDecisionDefinitionResponse, zGetDecisionDefinitionXmlData, zGetDecisionDefinitionXmlResponse, zGetDecisionInstanceData, zGetDecisionInstanceResponse, zGetDecisionRequirementsData, zGetDecisionRequirementsResponse, zGetDecisionRequirementsXmlData, zGetDecisionRequirementsXmlResponse, zGetDocumentData, zGetDocumentResponse, zGetElementInstanceData, zGetElementInstanceResponse, zGetGlobalClusterVariableData, zGetGlobalClusterVariableResponse, zGetGroupData, zGetGroupResponse, zGetIncidentData, zGetIncidentResponse, zGetLicenseData, zGetLicenseResponse, zGetMappingRuleData, zGetMappingRuleResponse, zGetProcessDefinitionData, zGetProcessDefinitionInstanceStatisticsData, zGetProcessDefinitionInstanceStatisticsResponse, zGetProcessDefinitionInstanceVersionStatisticsData, zGetProcessDefinitionInstanceVersionStatisticsResponse, zGetProcessDefinitionMessageSubscriptionStatisticsData, zGetProcessDefinitionMessageSubscriptionStatisticsResponse, zGetProcessDefinitionResponse, zGetProcessDefinitionStatisticsData, zGetProcessDefinitionStatisticsResponse, zGetProcessDefinitionXmlData, zGetProcessDefinitionXmlResponse, zGetProcessInstanceCallHierarchyData, zGetProcessInstanceCallHierarchyResponse, zGetProcessInstanceData, zGetProcessInstanceResponse, zGetProcessInstanceSequenceFlowsData, zGetProcessInstanceSequenceFlowsResponse, zGetProcessInstanceStatisticsByDefinitionData, zGetProcessInstanceStatisticsByDefinitionResponse, zGetProcessInstanceStatisticsByErrorData, zGetProcessInstanceStatisticsByErrorResponse, zGetProcessInstanceStatisticsData, zGetProcessInstanceStatisticsResponse, zGetResourceContentData, zGetResourceContentResponse, zGetResourceData, zGetResourceResponse, zGetRoleData, zGetRoleResponse, zGetStartProcessFormData, zGetStartProcessFormResponse, zGetStatusData, zGetStatusResponse, zGetTenantClusterVariableData, zGetTenantClusterVariableResponse, zGetTenantData, zGetTenantResponse, zGetTopologyData, zGetTopologyResponse, zGetUsageMetricsData, zGetUsageMetricsResponse, zGetUserData, zGetUserResponse, zGetUserTaskData, zGetUserTaskFormData, zGetUserTaskFormResponse, zGetUserTaskResponse, zGetVariableData, zGetVariableResponse, zMigrateProcessInstanceData, zMigrateProcessInstanceResponse, zMigrateProcessInstancesBatchOperationData, zMigrateProcessInstancesBatchOperationResponse, zModifyProcessInstanceData, zModifyProcessInstanceResponse, zModifyProcessInstancesBatchOperationData, zModifyProcessInstancesBatchOperationResponse, zPinClockData, zPinClockResponse, zPublishMessageData, zPublishMessageResponse, zResetClockData, zResetClockResponse, zResolveIncidentData, zResolveIncidentResponse, zResolveIncidentsBatchOperationData, zResolveIncidentsBatchOperationResponse, zResolveProcessInstanceIncidentsData, zResolveProcessInstanceIncidentsResponse, zResumeBatchOperationData, zResumeBatchOperationResponse, zSearchAuditLogsData, zSearchAuditLogsResponse, zSearchAuthorizationsData, zSearchAuthorizationsResponse, zSearchBatchOperationItemsData, zSearchBatchOperationItemsResponse, zSearchBatchOperationsData, zSearchBatchOperationsResponse, zSearchClientsForGroupData, zSearchClientsForGroupResponse, zSearchClientsForRoleData, zSearchClientsForRoleResponse, zSearchClientsForTenantData, zSearchClientsForTenantResponse, zSearchClusterVariablesData, zSearchClusterVariablesResponse, zSearchCorrelatedMessageSubscriptionsData, zSearchCorrelatedMessageSubscriptionsResponse, zSearchDecisionDefinitionsData, zSearchDecisionDefinitionsResponse, zSearchDecisionInstancesData, zSearchDecisionInstancesResponse, zSearchDecisionRequirementsData, zSearchDecisionRequirementsResponse, zSearchElementInstanceIncidentsData, zSearchElementInstanceIncidentsResponse, zSearchElementInstancesData, zSearchElementInstancesResponse, zSearchGroupIdsForTenantData, zSearchGroupIdsForTenantResponse, zSearchGroupsData, zSearchGroupsForRoleData, zSearchGroupsForRoleResponse, zSearchGroupsResponse, zSearchIncidentsData, zSearchIncidentsResponse, zSearchJobsData, zSearchJobsResponse, zSearchMappingRuleData, zSearchMappingRuleResponse, zSearchMappingRulesForGroupData, zSearchMappingRulesForGroupResponse, zSearchMappingRulesForRoleData, zSearchMappingRulesForRoleResponse, zSearchMappingRulesForTenantData, zSearchMappingRulesForTenantResponse, zSearchMessageSubscriptionsData, zSearchMessageSubscriptionsResponse, zSearchProcessDefinitionsData, zSearchProcessDefinitionsResponse, zSearchProcessInstanceIncidentsData, zSearchProcessInstanceIncidentsResponse, zSearchProcessInstancesData, zSearchProcessInstancesResponse, zSearchRolesData, zSearchRolesForGroupData, zSearchRolesForGroupResponse, zSearchRolesForTenantData, zSearchRolesForTenantResponse, zSearchRolesResponse, zSearchTenantsData, zSearchTenantsResponse, zSearchUsersData, zSearchUsersForGroupData, zSearchUsersForGroupResponse, zSearchUsersForRoleData, zSearchUsersForRoleResponse, zSearchUsersForTenantData, zSearchUsersForTenantResponse, zSearchUsersResponse, zSearchUserTaskAuditLogsData, zSearchUserTaskAuditLogsResponse, zSearchUserTasksData, zSearchUserTasksResponse, zSearchUserTaskVariablesData, zSearchUserTaskVariablesResponse, zSearchVariablesData, zSearchVariablesResponse, zSuspendBatchOperationData, zSuspendBatchOperationResponse, zThrowJobErrorData, zThrowJobErrorResponse, zUnassignClientFromGroupData, zUnassignClientFromGroupResponse, zUnassignClientFromTenantData, zUnassignClientFromTenantResponse, zUnassignGroupFromTenantData, zUnassignGroupFromTenantResponse, zUnassignMappingRuleFromGroupData, zUnassignMappingRuleFromGroupResponse, zUnassignMappingRuleFromTenantData, zUnassignMappingRuleFromTenantResponse, zUnassignRoleFromClientData, zUnassignRoleFromClientResponse, zUnassignRoleFromGroupData, zUnassignRoleFromGroupResponse, zUnassignRoleFromMappingRuleData, zUnassignRoleFromMappingRuleResponse, zUnassignRoleFromTenantData, zUnassignRoleFromTenantResponse, zUnassignRoleFromUserData, zUnassignRoleFromUserResponse, zUnassignUserFromGroupData, zUnassignUserFromGroupResponse, zUnassignUserFromTenantData, zUnassignUserFromTenantResponse, zUnassignUserTaskData, zUnassignUserTaskResponse, zUpdateAuthorizationData, zUpdateAuthorizationResponse, zUpdateGroupData, zUpdateGroupResponse, zUpdateJobData, zUpdateJobResponse, zUpdateMappingRuleData, zUpdateMappingRuleResponse, zUpdateRoleData, zUpdateRoleResponse, zUpdateTenantData, zUpdateTenantResponse, zUpdateUserData, zUpdateUserResponse, zUpdateUserTaskData, zUpdateUserTaskResponse } from './zod.gen';

export type Options<TData extends TDataShape = TDataShape, ThrowOnError extends boolean = boolean> = Options2<TData, ThrowOnError> & {
    /**
     * You can provide a client instance returned by `createClient()` instead of
     * individual options. This might be also useful if you want to implement a
     * custom client.
     */
    client?: Client;
    /**
     * You can pass arbitrary values through the `meta` object. This can be
     * used to access values that aren't defined as part of the SDK function.
     */
    meta?: Record<string, unknown>;
};

/**
 * Search audit logs
 *
 * Search for audit logs based on given criteria.
 */
export const searchAuditLogs = <ThrowOnError extends boolean = true>(options?: Options<SearchAuditLogsData, ThrowOnError>) => {
    return (options?.client ?? client).post<SearchAuditLogsResponses, SearchAuditLogsErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/audit-logs/search',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Get audit log
 *
 * Get an audit log entry by auditLogKey.
 */
export const getAuditLog = <ThrowOnError extends boolean = true>(options: Options<GetAuditLogData, ThrowOnError>) => {
    return (options.client ?? client).get<GetAuditLogResponses, GetAuditLogErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/audit-logs/{auditLogKey}',
        ...options
    });
};

/**
 * Get current user
 *
 * Retrieves the current authenticated user.
 */
export const getAuthentication = <ThrowOnError extends boolean = true>(options?: Options<GetAuthenticationData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetAuthenticationResponses, GetAuthenticationErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/authentication/me',
        ...options
    });
};

/**
 * Create authorization
 *
 * Create the authorization.
 */
export const createAuthorization = <ThrowOnError extends boolean = true>(options: Options<CreateAuthorizationData, ThrowOnError>) => {
    return (options.client ?? client).post<CreateAuthorizationResponses, CreateAuthorizationErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/authorizations',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Search authorizations
 *
 * Search for authorizations based on given criteria.
 */
export const searchAuthorizations = <ThrowOnError extends boolean = true>(options?: Options<SearchAuthorizationsData, ThrowOnError>) => {
    return (options?.client ?? client).post<SearchAuthorizationsResponses, SearchAuthorizationsErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/authorizations/search',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Delete authorization
 *
 * Deletes the authorization with the given key.
 */
export const deleteAuthorization = <ThrowOnError extends boolean = true>(options: Options<DeleteAuthorizationData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteAuthorizationResponses, DeleteAuthorizationErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/authorizations/{authorizationKey}',
        ...options
    });
};

/**
 * Get authorization
 *
 * Get authorization by the given key.
 */
export const getAuthorization = <ThrowOnError extends boolean = true>(options: Options<GetAuthorizationData, ThrowOnError>) => {
    return (options.client ?? client).get<GetAuthorizationResponses, GetAuthorizationErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/authorizations/{authorizationKey}',
        ...options
    });
};

/**
 * Update authorization
 *
 * Update the authorization with the given key.
 */
export const updateAuthorization = <ThrowOnError extends boolean = true>(options: Options<UpdateAuthorizationData, ThrowOnError>) => {
    return (options.client ?? client).put<UpdateAuthorizationResponses, UpdateAuthorizationErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/authorizations/{authorizationKey}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Search batch operation items
 *
 * Search for batch operation items based on given criteria.
 */
export const searchBatchOperationItems = <ThrowOnError extends boolean = true>(options?: Options<SearchBatchOperationItemsData, ThrowOnError>) => {
    return (options?.client ?? client).post<SearchBatchOperationItemsResponses, SearchBatchOperationItemsErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/batch-operation-items/search',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Search batch operations
 *
 * Search for batch operations based on given criteria.
 */
export const searchBatchOperations = <ThrowOnError extends boolean = true>(options?: Options<SearchBatchOperationsData, ThrowOnError>) => {
    return (options?.client ?? client).post<SearchBatchOperationsResponses, SearchBatchOperationsErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/batch-operations/search',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Get batch operation
 *
 * Get batch operation by key.
 */
export const getBatchOperation = <ThrowOnError extends boolean = true>(options: Options<GetBatchOperationData, ThrowOnError>) => {
    return (options.client ?? client).get<GetBatchOperationResponses, GetBatchOperationErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/batch-operations/{batchOperationKey}',
        ...options
    });
};

/**
 * Cancel Batch operation
 *
 * Cancels a running batch operation.
 * This is done asynchronously, the progress can be tracked using the batch operation status endpoint (/batch-operations/{batchOperationKey}).
 *
 */
export const cancelBatchOperation = <ThrowOnError extends boolean = true>(options: Options<CancelBatchOperationData, ThrowOnError>) => {
    return (options.client ?? client).post<CancelBatchOperationResponses, CancelBatchOperationErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/batch-operations/{batchOperationKey}/cancellation',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Resume Batch operation
 *
 * Resumes a suspended batch operation.
 * This is done asynchronously, the progress can be tracked using the batch operation status endpoint (/batch-operations/{batchOperationKey}).
 *
 */
export const resumeBatchOperation = <ThrowOnError extends boolean = true>(options: Options<ResumeBatchOperationData, ThrowOnError>) => {
    return (options.client ?? client).post<ResumeBatchOperationResponses, ResumeBatchOperationErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/batch-operations/{batchOperationKey}/resumption',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Suspend Batch operation
 *
 * Suspends a running batch operation.
 * This is done asynchronously, the progress can be tracked using the batch operation status endpoint (/batch-operations/{batchOperationKey}).
 *
 */
export const suspendBatchOperation = <ThrowOnError extends boolean = true>(options: Options<SuspendBatchOperationData, ThrowOnError>) => {
    return (options.client ?? client).post<SuspendBatchOperationResponses, SuspendBatchOperationErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/batch-operations/{batchOperationKey}/suspension',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Pin internal clock (alpha)
 *
 * Set a precise, static time for the Zeebe engine's internal clock.
 * When the clock is pinned, it remains at the specified time and does not advance.
 * To change the time, the clock must be pinned again with a new timestamp.
 *
 * This endpoint is an alpha feature and may be subject to change
 * in future releases.
 *
 */
export const pinClock = <ThrowOnError extends boolean = true>(options: Options<PinClockData, ThrowOnError>) => {
    return (options.client ?? client).put<PinClockResponses, PinClockErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/clock',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Reset internal clock (alpha)
 *
 * Resets the Zeebe engine's internal clock to the current system time, enabling it to tick in real-time.
 * This operation is useful for returning the clock to
 * normal behavior after it has been pinned to a specific time.
 *
 * This endpoint is an alpha feature and may be subject to change
 * in future releases.
 *
 */
export const resetClock = <ThrowOnError extends boolean = true>(options?: Options<ResetClockData, ThrowOnError>) => {
    return (options?.client ?? client).post<ResetClockResponses, ResetClockErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/clock/reset',
        ...options
    });
};

/**
 * Create a global-scoped cluster variable
 */
export const createGlobalClusterVariable = <ThrowOnError extends boolean = true>(options: Options<CreateGlobalClusterVariableData, ThrowOnError>) => {
    return (options.client ?? client).post<CreateGlobalClusterVariableResponses, CreateGlobalClusterVariableErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/cluster-variables/global',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Delete a global-scoped cluster variable
 */
export const deleteGlobalClusterVariable = <ThrowOnError extends boolean = true>(options: Options<DeleteGlobalClusterVariableData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteGlobalClusterVariableResponses, DeleteGlobalClusterVariableErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/cluster-variables/global/{name}',
        ...options
    });
};

/**
 * Get a global-scoped cluster variable
 */
export const getGlobalClusterVariable = <ThrowOnError extends boolean = true>(options: Options<GetGlobalClusterVariableData, ThrowOnError>) => {
    return (options.client ?? client).get<GetGlobalClusterVariableResponses, GetGlobalClusterVariableErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/cluster-variables/global/{name}',
        ...options
    });
};

/**
 * Search for cluster variables based on given criteria. By default, long variable values in the response are truncated.
 */
export const searchClusterVariables = <ThrowOnError extends boolean = true>(options?: Options<SearchClusterVariablesData, ThrowOnError>) => {
    return (options?.client ?? client).post<SearchClusterVariablesResponses, SearchClusterVariablesErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/cluster-variables/search',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Create a tenant-scoped cluster variable
 */
export const createTenantClusterVariable = <ThrowOnError extends boolean = true>(options: Options<CreateTenantClusterVariableData, ThrowOnError>) => {
    return (options.client ?? client).post<CreateTenantClusterVariableResponses, CreateTenantClusterVariableErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/cluster-variables/tenants/{tenantId}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Delete a tenant-scoped cluster variable
 */
export const deleteTenantClusterVariable = <ThrowOnError extends boolean = true>(options: Options<DeleteTenantClusterVariableData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteTenantClusterVariableResponses, DeleteTenantClusterVariableErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/cluster-variables/tenants/{tenantId}/{name}',
        ...options
    });
};

/**
 * Get a tenant-scoped cluster variable
 */
export const getTenantClusterVariable = <ThrowOnError extends boolean = true>(options: Options<GetTenantClusterVariableData, ThrowOnError>) => {
    return (options.client ?? client).get<GetTenantClusterVariableResponses, GetTenantClusterVariableErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/cluster-variables/tenants/{tenantId}/{name}',
        ...options
    });
};

/**
 * Evaluate root level conditional start events
 *
 * Evaluates root-level conditional start events for process definitions.
 * If the evaluation is successful, it will return the keys of all created process instances, along with their associated process definition key.
 * Multiple root-level conditional start events of the same process definition can trigger if their conditions evaluate to true.
 *
 */
export const evaluateConditionals = <ThrowOnError extends boolean = true>(options: Options<EvaluateConditionalsData, ThrowOnError>) => {
    return (options.client ?? client).post<EvaluateConditionalsResponses, EvaluateConditionalsErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/conditionals/evaluation',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Search correlated message subscriptions
 *
 * Search correlated message subscriptions based on given criteria.
 */
export const searchCorrelatedMessageSubscriptions = <ThrowOnError extends boolean = true>(options?: Options<SearchCorrelatedMessageSubscriptionsData, ThrowOnError>) => {
    return (options?.client ?? client).post<SearchCorrelatedMessageSubscriptionsResponses, SearchCorrelatedMessageSubscriptionsErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/correlated-message-subscriptions/search',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Evaluate decision
 *
 * Evaluates a decision.
 * You specify the decision to evaluate either by using its unique key (as returned by
 * DeployResource), or using the decision ID. When using the decision ID, the latest deployed
 * version of the decision is used.
 *
 */
export const evaluateDecision = <ThrowOnError extends boolean = true>(options: Options<EvaluateDecisionData, ThrowOnError>) => {
    return (options.client ?? client).post<EvaluateDecisionResponses, EvaluateDecisionErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/decision-definitions/evaluation',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Search decision definitions
 *
 * Search for decision definitions based on given criteria.
 */
export const searchDecisionDefinitions = <ThrowOnError extends boolean = true>(options?: Options<SearchDecisionDefinitionsData, ThrowOnError>) => {
    return (options?.client ?? client).post<SearchDecisionDefinitionsResponses, SearchDecisionDefinitionsErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/decision-definitions/search',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Get decision definition
 *
 * Returns a decision definition by key.
 */
export const getDecisionDefinition = <ThrowOnError extends boolean = true>(options: Options<GetDecisionDefinitionData, ThrowOnError>) => {
    return (options.client ?? client).get<GetDecisionDefinitionResponses, GetDecisionDefinitionErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/decision-definitions/{decisionDefinitionKey}',
        ...options
    });
};

/**
 * Get decision definition XML
 *
 * Returns decision definition as XML.
 */
export const getDecisionDefinitionXml = <ThrowOnError extends boolean = true>(options: Options<GetDecisionDefinitionXmlData, ThrowOnError>) => {
    return (options.client ?? client).get<GetDecisionDefinitionXmlResponses, GetDecisionDefinitionXmlErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/decision-definitions/{decisionDefinitionKey}/xml',
        ...options
    });
};

/**
 * Search decision instances
 *
 * Search for decision instances based on given criteria.
 */
export const searchDecisionInstances = <ThrowOnError extends boolean = true>(options?: Options<SearchDecisionInstancesData, ThrowOnError>) => {
    return (options?.client ?? client).post<SearchDecisionInstancesResponses, SearchDecisionInstancesErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/decision-instances/search',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Get decision instance
 *
 * Returns a decision instance.
 */
export const getDecisionInstance = <ThrowOnError extends boolean = true>(options: Options<GetDecisionInstanceData, ThrowOnError>) => {
    return (options.client ?? client).get<GetDecisionInstanceResponses, GetDecisionInstanceErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/decision-instances/{decisionEvaluationInstanceKey}',
        ...options
    });
};

/**
 * Search decision requirements
 *
 * Search for decision requirements based on given criteria.
 */
export const searchDecisionRequirements = <ThrowOnError extends boolean = true>(options?: Options<SearchDecisionRequirementsData, ThrowOnError>) => {
    return (options?.client ?? client).post<SearchDecisionRequirementsResponses, SearchDecisionRequirementsErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/decision-requirements/search',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Get decision requirements
 *
 * Returns Decision Requirements as JSON.
 */
export const getDecisionRequirements = <ThrowOnError extends boolean = true>(options: Options<GetDecisionRequirementsData, ThrowOnError>) => {
    return (options.client ?? client).get<GetDecisionRequirementsResponses, GetDecisionRequirementsErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/decision-requirements/{decisionRequirementsKey}',
        ...options
    });
};

/**
 * Get decision requirements XML
 *
 * Returns decision requirements as XML.
 */
export const getDecisionRequirementsXml = <ThrowOnError extends boolean = true>(options: Options<GetDecisionRequirementsXmlData, ThrowOnError>) => {
    return (options.client ?? client).get<GetDecisionRequirementsXmlResponses, GetDecisionRequirementsXmlErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/decision-requirements/{decisionRequirementsKey}/xml',
        ...options
    });
};

/**
 * Deploy resources
 *
 * Deploys one or more resources (e.g. processes, decision models, or forms).
 * This is an atomic call, i.e. either all resources are deployed or none of them are.
 *
 */
export const createDeployment = <ThrowOnError extends boolean = true>(options: Options<CreateDeploymentData, ThrowOnError>) => {
    return (options.client ?? client).post<CreateDeploymentResponses, CreateDeploymentErrors, ThrowOnError>({
        ...formDataBodySerializer,
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/deployments',
        ...options,
        headers: {
            'Content-Type': null,
            ...options.headers
        }
    });
};

/**
 * Upload document
 *
 * Upload a document to the Camunda 8 cluster.
 *
 * Note that this is currently supported for document stores of type: AWS, GCP, in-memory (non-production), local (non-production)
 *
 */
export const createDocument = <ThrowOnError extends boolean = true>(options: Options<CreateDocumentData, ThrowOnError>) => {
    return (options.client ?? client).post<CreateDocumentResponses, CreateDocumentErrors, ThrowOnError>({
        ...formDataBodySerializer,
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/documents',
        ...options,
        headers: {
            'Content-Type': null,
            ...options.headers
        }
    });
};

/**
 * Upload multiple documents
 *
 * Upload multiple documents to the Camunda 8 cluster.
 *
 * The caller must provide a file name for each document, which will be used in case of a multi-status response
 * to identify which documents failed to upload. The file name can be provided in the `Content-Disposition` header
 * of the file part or in the `fileName` field of the metadata. You can add a parallel array of metadata objects. These
 * are matched with the files based on index, and must have the same length as the files array.
 * To pass homogenous metadata for all files, spread the metadata over the metadata array.
 * A filename value provided explicitly via the metadata array in the request overrides the `Content-Disposition` header
 * of the file part.
 *
 * In case of a multi-status response, the response body will contain a list of `DocumentBatchProblemDetail` objects,
 * each of which contains the file name of the document that failed to upload and the reason for the failure.
 * The client can choose to retry the whole batch or individual documents based on the response.
 *
 * Note that this is currently supported for document stores of type: AWS, GCP, in-memory (non-production), local (non-production)
 *
 */
export const createDocuments = <ThrowOnError extends boolean = true>(options: Options<CreateDocumentsData, ThrowOnError>) => {
    return (options.client ?? client).post<CreateDocumentsResponses, CreateDocumentsErrors, ThrowOnError>({
        ...formDataBodySerializer,
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/documents/batch',
        ...options,
        headers: {
            'Content-Type': null,
            ...options.headers
        }
    });
};

/**
 * Delete document
 *
 * Delete a document from the Camunda 8 cluster.
 *
 * Note that this is currently supported for document stores of type: AWS, GCP, in-memory (non-production), local (non-production)
 *
 */
export const deleteDocument = <ThrowOnError extends boolean = true>(options: Options<DeleteDocumentData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteDocumentResponses, DeleteDocumentErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/documents/{documentId}',
        ...options
    });
};

/**
 * Download document
 *
 * Download a document from the Camunda 8 cluster.
 *
 * Note that this is currently supported for document stores of type: AWS, GCP, in-memory (non-production), local (non-production)
 *
 */
export const getDocument = <ThrowOnError extends boolean = true>(options: Options<GetDocumentData, ThrowOnError>) => {
    return (options.client ?? client).get<GetDocumentResponses, GetDocumentErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/documents/{documentId}',
        ...options
    });
};

/**
 * Create document link
 *
 * Create a link to a document in the Camunda 8 cluster.
 *
 * Note that this is currently supported for document stores of type: AWS, GCP
 *
 */
export const createDocumentLink = <ThrowOnError extends boolean = true>(options: Options<CreateDocumentLinkData, ThrowOnError>) => {
    return (options.client ?? client).post<CreateDocumentLinkResponses, CreateDocumentLinkErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/documents/{documentId}/links',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Activate activities within an ad-hoc sub-process
 *
 * Activates selected activities within an ad-hoc sub-process identified by element ID.
 * The provided element IDs must exist within the ad-hoc sub-process instance identified by the
 * provided adHocSubProcessInstanceKey.
 *
 */
export const activateAdHocSubProcessActivities = <ThrowOnError extends boolean = true>(options: Options<ActivateAdHocSubProcessActivitiesData, ThrowOnError>) => {
    return (options.client ?? client).post<ActivateAdHocSubProcessActivitiesResponses, ActivateAdHocSubProcessActivitiesErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/element-instances/ad-hoc-activities/{adHocSubProcessInstanceKey}/activation',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Search element instances
 *
 * Search for element instances based on given criteria.
 */
export const searchElementInstances = <ThrowOnError extends boolean = true>(options?: Options<SearchElementInstancesData, ThrowOnError>) => {
    return (options?.client ?? client).post<SearchElementInstancesResponses, SearchElementInstancesErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/element-instances/search',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Get element instance
 *
 * Returns element instance as JSON.
 */
export const getElementInstance = <ThrowOnError extends boolean = true>(options: Options<GetElementInstanceData, ThrowOnError>) => {
    return (options.client ?? client).get<GetElementInstanceResponses, GetElementInstanceErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/element-instances/{elementInstanceKey}',
        ...options
    });
};

/**
 * Search for incidents of a specific element instance
 *
 * Search for incidents caused by the specified element instance, including incidents of any child instances created from this element instance.
 *
 * Although the `elementInstanceKey` is provided as a path parameter to indicate the root element instance,
 * you may also include an `elementInstanceKey` within the filter object to narrow results to specific
 * child element instances. This is useful, for example, if you want to isolate incidents associated with
 * nested or subordinate elements within the given element instance while excluding incidents directly tied
 * to the root element itself.
 *
 */
export const searchElementInstanceIncidents = <ThrowOnError extends boolean = true>(options: Options<SearchElementInstanceIncidentsData, ThrowOnError>) => {
    return (options.client ?? client).post<SearchElementInstanceIncidentsResponses, SearchElementInstanceIncidentsErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/element-instances/{elementInstanceKey}/incidents/search',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Update element instance variables
 *
 * Updates all the variables of a particular scope (for example, process instance, element instance) with the given variable data.
 * Specify the element instance in the `elementInstanceKey` parameter.
 *
 */
export const createElementInstanceVariables = <ThrowOnError extends boolean = true>(options: Options<CreateElementInstanceVariablesData, ThrowOnError>) => {
    return (options.client ?? client).put<CreateElementInstanceVariablesResponses, CreateElementInstanceVariablesErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/element-instances/{elementInstanceKey}/variables',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Evaluate an expression
 *
 * Evaluates a FEEL expression and returns the result. Supports references to tenant scoped cluster variables when a tenant ID is provided.
 */
export const evaluateExpression = <ThrowOnError extends boolean = true>(options: Options<EvaluateExpressionData, ThrowOnError>) => {
    return (options.client ?? client).post<EvaluateExpressionResponses, EvaluateExpressionErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/expression/evaluation',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Create group
 *
 * Create a new group.
 */
export const createGroup = <ThrowOnError extends boolean = true>(options?: Options<CreateGroupData, ThrowOnError>) => {
    return (options?.client ?? client).post<CreateGroupResponses, CreateGroupErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/groups',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Search groups
 *
 * Search for groups based on given criteria.
 */
export const searchGroups = <ThrowOnError extends boolean = true>(options?: Options<SearchGroupsData, ThrowOnError>) => {
    return (options?.client ?? client).post<SearchGroupsResponses, SearchGroupsErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/groups/search',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Delete group
 *
 * Deletes the group with the given ID.
 */
export const deleteGroup = <ThrowOnError extends boolean = true>(options: Options<DeleteGroupData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteGroupResponses, DeleteGroupErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/groups/{groupId}',
        ...options
    });
};

/**
 * Get group
 *
 * Get a group by its ID.
 */
export const getGroup = <ThrowOnError extends boolean = true>(options: Options<GetGroupData, ThrowOnError>) => {
    return (options.client ?? client).get<GetGroupResponses, GetGroupErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/groups/{groupId}',
        ...options
    });
};

/**
 * Update group
 *
 * Update a group with the given ID.
 */
export const updateGroup = <ThrowOnError extends boolean = true>(options: Options<UpdateGroupData, ThrowOnError>) => {
    return (options.client ?? client).put<UpdateGroupResponses, UpdateGroupErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/groups/{groupId}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Search group clients
 *
 * Search clients assigned to a group.
 */
export const searchClientsForGroup = <ThrowOnError extends boolean = true>(options: Options<SearchClientsForGroupData, ThrowOnError>) => {
    return (options.client ?? client).post<SearchClientsForGroupResponses, SearchClientsForGroupErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/groups/{groupId}/clients/search',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Unassign a client from a group
 *
 * Unassigns a client from a group.
 * The client is removed as a group member, with associated authorizations, roles, and tenant assignments no longer applied.
 *
 */
export const unassignClientFromGroup = <ThrowOnError extends boolean = true>(options: Options<UnassignClientFromGroupData, ThrowOnError>) => {
    return (options.client ?? client).delete<UnassignClientFromGroupResponses, UnassignClientFromGroupErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/groups/{groupId}/clients/{clientId}',
        ...options
    });
};

/**
 * Assign a client to a group
 *
 * Assigns a client to a group, making it a member of the group.
 * Members of the group inherit the group authorizations, roles, and tenant assignments.
 *
 */
export const assignClientToGroup = <ThrowOnError extends boolean = true>(options: Options<AssignClientToGroupData, ThrowOnError>) => {
    return (options.client ?? client).put<AssignClientToGroupResponses, AssignClientToGroupErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/groups/{groupId}/clients/{clientId}',
        ...options
    });
};

/**
 * Search group mapping rules
 *
 * Search mapping rules assigned to a group.
 */
export const searchMappingRulesForGroup = <ThrowOnError extends boolean = true>(options: Options<SearchMappingRulesForGroupData, ThrowOnError>) => {
    return (options.client ?? client).post<SearchMappingRulesForGroupResponses, SearchMappingRulesForGroupErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/groups/{groupId}/mapping-rules/search',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Unassign a mapping rule from a group
 *
 * Unassigns a mapping rule from a group.
 */
export const unassignMappingRuleFromGroup = <ThrowOnError extends boolean = true>(options: Options<UnassignMappingRuleFromGroupData, ThrowOnError>) => {
    return (options.client ?? client).delete<UnassignMappingRuleFromGroupResponses, UnassignMappingRuleFromGroupErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/groups/{groupId}/mapping-rules/{mappingRuleId}',
        ...options
    });
};

/**
 * Assign a mapping rule to a group
 *
 * Assigns a mapping rule to a group.
 */
export const assignMappingRuleToGroup = <ThrowOnError extends boolean = true>(options: Options<AssignMappingRuleToGroupData, ThrowOnError>) => {
    return (options.client ?? client).put<AssignMappingRuleToGroupResponses, AssignMappingRuleToGroupErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/groups/{groupId}/mapping-rules/{mappingRuleId}',
        ...options
    });
};

/**
 * Search group roles
 *
 * Search roles assigned to a group.
 */
export const searchRolesForGroup = <ThrowOnError extends boolean = true>(options: Options<SearchRolesForGroupData, ThrowOnError>) => {
    return (options.client ?? client).post<SearchRolesForGroupResponses, SearchRolesForGroupErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/groups/{groupId}/roles/search',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Search group users
 *
 * Search users assigned to a group.
 */
export const searchUsersForGroup = <ThrowOnError extends boolean = true>(options: Options<SearchUsersForGroupData, ThrowOnError>) => {
    return (options.client ?? client).post<SearchUsersForGroupResponses, SearchUsersForGroupErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/groups/{groupId}/users/search',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Unassign a user from a group
 *
 * Unassigns a user from a group.
 * The user is removed as a group member, with associated authorizations, roles, and tenant assignments no longer applied.
 *
 */
export const unassignUserFromGroup = <ThrowOnError extends boolean = true>(options: Options<UnassignUserFromGroupData, ThrowOnError>) => {
    return (options.client ?? client).delete<UnassignUserFromGroupResponses, UnassignUserFromGroupErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/groups/{groupId}/users/{username}',
        ...options
    });
};

/**
 * Assign a user to a group
 *
 * Assigns a user to a group, making the user a member of the group.
 * Group members inherit the group authorizations, roles, and tenant assignments.
 *
 */
export const assignUserToGroup = <ThrowOnError extends boolean = true>(options: Options<AssignUserToGroupData, ThrowOnError>) => {
    return (options.client ?? client).put<AssignUserToGroupResponses, AssignUserToGroupErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/groups/{groupId}/users/{username}',
        ...options
    });
};

/**
 * Search incidents
 *
 * Search for incidents based on given criteria.
 *
 */
export const searchIncidents = <ThrowOnError extends boolean = true>(options?: Options<SearchIncidentsData, ThrowOnError>) => {
    return (options?.client ?? client).post<SearchIncidentsResponses, SearchIncidentsErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/incidents/search',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Get incident
 *
 * Returns incident as JSON.
 *
 */
export const getIncident = <ThrowOnError extends boolean = true>(options: Options<GetIncidentData, ThrowOnError>) => {
    return (options.client ?? client).get<GetIncidentResponses, GetIncidentErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/incidents/{incidentKey}',
        ...options
    });
};

/**
 * Resolve incident
 *
 * Marks the incident as resolved; most likely a call to Update job will be necessary
 * to reset the job's retries, followed by this call.
 *
 */
export const resolveIncident = <ThrowOnError extends boolean = true>(options: Options<ResolveIncidentData, ThrowOnError>) => {
    return (options.client ?? client).post<ResolveIncidentResponses, ResolveIncidentErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/incidents/{incidentKey}/resolution',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get process instance statistics by definition
 *
 * Returns statistics for active process instances with incidents, grouped by process
 * definition. The result set is scoped to a specific incident error hash code, which must be
 * provided as a filter in the request body.
 *
 */
export const getProcessInstanceStatisticsByDefinition = <ThrowOnError extends boolean = true>(options: Options<GetProcessInstanceStatisticsByDefinitionData, ThrowOnError>) => {
    return (options.client ?? client).post<GetProcessInstanceStatisticsByDefinitionResponses, GetProcessInstanceStatisticsByDefinitionErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/incidents/statistics/process-instances-by-definition',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get process instance statistics by error
 *
 * Returns statistics for active process instances that currently have active incidents,
 * grouped by incident error hash code.
 *
 */
export const getProcessInstanceStatisticsByError = <ThrowOnError extends boolean = true>(options?: Options<GetProcessInstanceStatisticsByErrorData, ThrowOnError>) => {
    return (options?.client ?? client).post<GetProcessInstanceStatisticsByErrorResponses, GetProcessInstanceStatisticsByErrorErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/incidents/statistics/process-instances-by-error',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Activate jobs
 *
 * Iterate through all known partitions and activate jobs up to the requested maximum.
 *
 */
export const activateJobs = <ThrowOnError extends boolean = true>(options: Options<ActivateJobsData, ThrowOnError>) => {
    return (options.client ?? client).post<ActivateJobsResponses, ActivateJobsErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/jobs/activation',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Search jobs
 *
 * Search for jobs based on given criteria.
 */
export const searchJobs = <ThrowOnError extends boolean = true>(options?: Options<SearchJobsData, ThrowOnError>) => {
    return (options?.client ?? client).post<SearchJobsResponses, SearchJobsErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/jobs/search',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Update job
 *
 * Update a job with the given key.
 */
export const updateJob = <ThrowOnError extends boolean = true>(options: Options<UpdateJobData, ThrowOnError>) => {
    return (options.client ?? client).patch<UpdateJobResponses, UpdateJobErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/jobs/{jobKey}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Complete job
 *
 * Complete a job with the given payload, which allows completing the associated service task.
 *
 */
export const completeJob = <ThrowOnError extends boolean = true>(options: Options<CompleteJobData, ThrowOnError>) => {
    return (options.client ?? client).post<CompleteJobResponses, CompleteJobErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/jobs/{jobKey}/completion',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Throw error for job
 *
 * Reports a business error (i.e. non-technical) that occurs while processing a job.
 *
 */
export const throwJobError = <ThrowOnError extends boolean = true>(options: Options<ThrowJobErrorData, ThrowOnError>) => {
    return (options.client ?? client).post<ThrowJobErrorResponses, ThrowJobErrorErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/jobs/{jobKey}/error',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Fail job
 *
 * Mark the job as failed.
 *
 */
export const failJob = <ThrowOnError extends boolean = true>(options: Options<FailJobData, ThrowOnError>) => {
    return (options.client ?? client).post<FailJobResponses, FailJobErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/jobs/{jobKey}/failure',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get license status
 *
 * Obtains the status of the current Camunda license.
 */
export const getLicense = <ThrowOnError extends boolean = true>(options?: Options<GetLicenseData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetLicenseResponses, GetLicenseErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/license',
        ...options
    });
};

/**
 * Create mapping rule
 *
 * Create a new mapping rule
 *
 */
export const createMappingRule = <ThrowOnError extends boolean = true>(options?: Options<CreateMappingRuleData, ThrowOnError>) => {
    return (options?.client ?? client).post<CreateMappingRuleResponses, CreateMappingRuleErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/mapping-rules',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Search mapping rules
 *
 * Search for mapping rules based on given criteria.
 *
 */
export const searchMappingRule = <ThrowOnError extends boolean = true>(options?: Options<SearchMappingRuleData, ThrowOnError>) => {
    return (options?.client ?? client).post<SearchMappingRuleResponses, SearchMappingRuleErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/mapping-rules/search',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Delete a mapping rule
 *
 * Deletes the mapping rule with the given ID.
 *
 */
export const deleteMappingRule = <ThrowOnError extends boolean = true>(options: Options<DeleteMappingRuleData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteMappingRuleResponses, DeleteMappingRuleErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/mapping-rules/{mappingRuleId}',
        ...options
    });
};

/**
 * Get a mapping rule
 *
 * Gets the mapping rule with the given ID.
 *
 */
export const getMappingRule = <ThrowOnError extends boolean = true>(options: Options<GetMappingRuleData, ThrowOnError>) => {
    return (options.client ?? client).get<GetMappingRuleResponses, GetMappingRuleErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/mapping-rules/{mappingRuleId}',
        ...options
    });
};

/**
 * Update mapping rule
 *
 * Update a mapping rule.
 *
 */
export const updateMappingRule = <ThrowOnError extends boolean = true>(options: Options<UpdateMappingRuleData, ThrowOnError>) => {
    return (options.client ?? client).put<UpdateMappingRuleResponses, UpdateMappingRuleErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/mapping-rules/{mappingRuleId}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Search message subscriptions
 *
 * Search for message subscriptions based on given criteria.
 */
export const searchMessageSubscriptions = <ThrowOnError extends boolean = true>(options?: Options<SearchMessageSubscriptionsData, ThrowOnError>) => {
    return (options?.client ?? client).post<SearchMessageSubscriptionsResponses, SearchMessageSubscriptionsErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/message-subscriptions/search',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Correlate message
 *
 * Publishes a message and correlates it to a subscription.
 * If correlation is successful it will return the first process instance key the message correlated with.
 * The message is not buffered.
 * Use the publish message endpoint to send messages that can be buffered.
 *
 */
export const correlateMessage = <ThrowOnError extends boolean = true>(options: Options<CorrelateMessageData, ThrowOnError>) => {
    return (options.client ?? client).post<CorrelateMessageResponses, CorrelateMessageErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/messages/correlation',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Publish message
 *
 * Publishes a single message.
 * Messages are published to specific partitions computed from their correlation keys.
 * Messages can be buffered.
 * The endpoint does not wait for a correlation result.
 * Use the message correlation endpoint for such use cases.
 *
 */
export const publishMessage = <ThrowOnError extends boolean = true>(options: Options<PublishMessageData, ThrowOnError>) => {
    return (options.client ?? client).post<PublishMessageResponses, PublishMessageErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/messages/publication',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Search process definitions
 *
 * Search for process definitions based on given criteria.
 */
export const searchProcessDefinitions = <ThrowOnError extends boolean = true>(options?: Options<SearchProcessDefinitionsData, ThrowOnError>) => {
    return (options?.client ?? client).post<SearchProcessDefinitionsResponses, SearchProcessDefinitionsErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/process-definitions/search',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Get message subscription statistics
 *
 * Get message subscription statistics, grouped by process definition.
 *
 */
export const getProcessDefinitionMessageSubscriptionStatistics = <ThrowOnError extends boolean = true>(options?: Options<GetProcessDefinitionMessageSubscriptionStatisticsData, ThrowOnError>) => {
    return (options?.client ?? client).post<GetProcessDefinitionMessageSubscriptionStatisticsResponses, GetProcessDefinitionMessageSubscriptionStatisticsErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/process-definitions/statistics/message-subscriptions',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Get process instance statistics
 *
 * Get statistics about process instances, grouped by process definition and tenant.
 *
 */
export const getProcessDefinitionInstanceStatistics = <ThrowOnError extends boolean = true>(options?: Options<GetProcessDefinitionInstanceStatisticsData, ThrowOnError>) => {
    return (options?.client ?? client).post<GetProcessDefinitionInstanceStatisticsResponses, GetProcessDefinitionInstanceStatisticsErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/process-definitions/statistics/process-instances',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Get process definition
 *
 * Returns process definition as JSON.
 */
export const getProcessDefinition = <ThrowOnError extends boolean = true>(options: Options<GetProcessDefinitionData, ThrowOnError>) => {
    return (options.client ?? client).get<GetProcessDefinitionResponses, GetProcessDefinitionErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/process-definitions/{processDefinitionKey}',
        ...options
    });
};

/**
 * Get process start form
 *
 * Get the start form of a process.
 * Note that this endpoint will only return linked forms. This endpoint does not support embedded forms.
 *
 */
export const getStartProcessForm = <ThrowOnError extends boolean = true>(options: Options<GetStartProcessFormData, ThrowOnError>) => {
    return (options.client ?? client).get<GetStartProcessFormResponses, GetStartProcessFormErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/process-definitions/{processDefinitionKey}/form',
        ...options
    });
};

/**
 * Get process definition statistics
 *
 * Get statistics about elements in currently running process instances by process definition key and search filter.
 */
export const getProcessDefinitionStatistics = <ThrowOnError extends boolean = true>(options: Options<GetProcessDefinitionStatisticsData, ThrowOnError>) => {
    return (options.client ?? client).post<GetProcessDefinitionStatisticsResponses, GetProcessDefinitionStatisticsErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/process-definitions/{processDefinitionKey}/statistics/element-instances',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get process definition XML
 *
 * Returns process definition as XML.
 */
export const getProcessDefinitionXml = <ThrowOnError extends boolean = true>(options: Options<GetProcessDefinitionXmlData, ThrowOnError>) => {
    return (options.client ?? client).get<GetProcessDefinitionXmlResponses, GetProcessDefinitionXmlErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/process-definitions/{processDefinitionKey}/xml',
        ...options
    });
};

/**
 * Get process instance statistics by version
 *
 * Get statistics about process instances, grouped by version for a given process definition.
 *
 */
export const getProcessDefinitionInstanceVersionStatistics = <ThrowOnError extends boolean = true>(options: Options<GetProcessDefinitionInstanceVersionStatisticsData, ThrowOnError>) => {
    return (options.client ?? client).post<GetProcessDefinitionInstanceVersionStatisticsResponses, GetProcessDefinitionInstanceVersionStatisticsErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/process-definitions/{processDefinitionId}/statistics/process-instances',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Create process instance
 *
 * Creates and starts an instance of the specified process.
 * The process definition to use to create the instance can be specified either using its unique key
 * (as returned by Deploy resources), or using the BPMN process id and a version.
 *
 * Waits for the completion of the process instance before returning a result
 * when awaitCompletion is enabled.
 *
 */
export const createProcessInstance = <ThrowOnError extends boolean = true>(options: Options<CreateProcessInstanceData, ThrowOnError>) => {
    return (options.client ?? client).post<CreateProcessInstanceResponses, CreateProcessInstanceErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/process-instances',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Cancel process instances (batch)
 *
 * Cancels multiple running process instances.
 * Since only ACTIVE root instances can be cancelled, any given filters for state and
 * parentProcessInstanceKey are ignored and overridden during this batch operation.
 * This is done asynchronously, the progress can be tracked using the batchOperationKey from the response and the batch operation status endpoint (/batch-operations/{batchOperationKey}).
 *
 */
export const cancelProcessInstancesBatchOperation = <ThrowOnError extends boolean = true>(options: Options<CancelProcessInstancesBatchOperationData, ThrowOnError>) => {
    return (options.client ?? client).post<CancelProcessInstancesBatchOperationResponses, CancelProcessInstancesBatchOperationErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/process-instances/cancellation',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Delete process instances (batch)
 *
 * Delete multiple process instances. This will delete the historic data from secondary storage.
 * Only process instances in a final state (COMPLETED or TERMINATED) can be deleted.
 * This is done asynchronously, the progress can be tracked using the batchOperationKey from the response and the batch operation status endpoint (/batch-operations/{batchOperationKey}).
 *
 */
export const deleteProcessInstancesBatchOperation = <ThrowOnError extends boolean = true>(options: Options<DeleteProcessInstancesBatchOperationData, ThrowOnError>) => {
    return (options.client ?? client).post<DeleteProcessInstancesBatchOperationResponses, DeleteProcessInstancesBatchOperationErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/process-instances/deletion',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Resolve related incidents (batch)
 *
 * Resolves multiple instances of process instances.
 * Since only process instances with ACTIVE state can have unresolved incidents, any given
 * filters for state are ignored and overridden during this batch operation.
 * This is done asynchronously, the progress can be tracked using the batchOperationKey from the response and the batch operation status endpoint (/batch-operations/{batchOperationKey}).
 *
 */
export const resolveIncidentsBatchOperation = <ThrowOnError extends boolean = true>(options?: Options<ResolveIncidentsBatchOperationData, ThrowOnError>) => {
    return (options?.client ?? client).post<ResolveIncidentsBatchOperationResponses, ResolveIncidentsBatchOperationErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/process-instances/incident-resolution',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Migrate process instances (batch)
 *
 * Migrate multiple process instances.
 * Since only process instances with ACTIVE state can be migrated, any given
 * filters for state are ignored and overridden during this batch operation.
 * This is done asynchronously, the progress can be tracked using the batchOperationKey from the response and the batch operation status endpoint (/batch-operations/{batchOperationKey}).
 *
 */
export const migrateProcessInstancesBatchOperation = <ThrowOnError extends boolean = true>(options: Options<MigrateProcessInstancesBatchOperationData, ThrowOnError>) => {
    return (options.client ?? client).post<MigrateProcessInstancesBatchOperationResponses, MigrateProcessInstancesBatchOperationErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/process-instances/migration',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Modify process instances (batch)
 *
 * Modify multiple process instances.
 * Since only process instances with ACTIVE state can be modified, any given
 * filters for state are ignored and overridden during this batch operation.
 * In contrast to single modification operation, it is not possible to add variable instructions or modify by element key.
 * It is only possible to use the element id of the source and target.
 * This is done asynchronously, the progress can be tracked using the batchOperationKey from the response and the batch operation status endpoint (/batch-operations/{batchOperationKey}).
 *
 */
export const modifyProcessInstancesBatchOperation = <ThrowOnError extends boolean = true>(options: Options<ModifyProcessInstancesBatchOperationData, ThrowOnError>) => {
    return (options.client ?? client).post<ModifyProcessInstancesBatchOperationResponses, ModifyProcessInstancesBatchOperationErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/process-instances/modification',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Search process instances
 *
 * Search for process instances based on given criteria.
 */
export const searchProcessInstances = <ThrowOnError extends boolean = true>(options?: Options<SearchProcessInstancesData, ThrowOnError>) => {
    return (options?.client ?? client).post<SearchProcessInstancesResponses, SearchProcessInstancesErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/process-instances/search',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Get process instance
 *
 * Get the process instance by the process instance key.
 */
export const getProcessInstance = <ThrowOnError extends boolean = true>(options: Options<GetProcessInstanceData, ThrowOnError>) => {
    return (options.client ?? client).get<GetProcessInstanceResponses, GetProcessInstanceErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/process-instances/{processInstanceKey}',
        ...options
    });
};

/**
 * Get call hierarchy
 *
 * Returns the call hierarchy for a given process instance, showing its ancestry up to the root instance.
 */
export const getProcessInstanceCallHierarchy = <ThrowOnError extends boolean = true>(options: Options<GetProcessInstanceCallHierarchyData, ThrowOnError>) => {
    return (options.client ?? client).get<GetProcessInstanceCallHierarchyResponses, GetProcessInstanceCallHierarchyErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/process-instances/{processInstanceKey}/call-hierarchy',
        ...options
    });
};

/**
 * Cancel process instance
 *
 * Cancels a running process instance. As a cancellation includes more than just the removal of the process instance resource, the cancellation resource must be posted.
 */
export const cancelProcessInstance = <ThrowOnError extends boolean = true>(options: Options<CancelProcessInstanceData, ThrowOnError>) => {
    return (options.client ?? client).post<CancelProcessInstanceResponses, CancelProcessInstanceErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/process-instances/{processInstanceKey}/cancellation',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Delete process instance
 *
 * Deletes a process instance. Only instances that are completed or terminated can be deleted.
 */
export const deleteProcessInstance = <ThrowOnError extends boolean = true>(options: Options<DeleteProcessInstanceData, ThrowOnError>) => {
    return (options.client ?? client).post<DeleteProcessInstanceResponses, DeleteProcessInstanceErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/process-instances/{processInstanceKey}/deletion',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Resolve related incidents
 *
 * Creates a batch operation to resolve multiple incidents of a process instance.
 */
export const resolveProcessInstanceIncidents = <ThrowOnError extends boolean = true>(options: Options<ResolveProcessInstanceIncidentsData, ThrowOnError>) => {
    return (options.client ?? client).post<ResolveProcessInstanceIncidentsResponses, ResolveProcessInstanceIncidentsErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/process-instances/{processInstanceKey}/incident-resolution',
        ...options
    });
};

/**
 * Search related incidents
 *
 * Search for incidents caused by the process instance or any of its called process or decision instances.
 *
 * Although the `processInstanceKey` is provided as a path parameter to indicate the root process instance,
 * you may also include a `processInstanceKey` within the filter object to narrow results to specific
 * child process instances. This is useful, for example, if you want to isolate incidents associated with
 * subprocesses or called processes under the root instance while excluding incidents directly tied to the root.
 *
 */
export const searchProcessInstanceIncidents = <ThrowOnError extends boolean = true>(options: Options<SearchProcessInstanceIncidentsData, ThrowOnError>) => {
    return (options.client ?? client).post<SearchProcessInstanceIncidentsResponses, SearchProcessInstanceIncidentsErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/process-instances/{processInstanceKey}/incidents/search',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Migrate process instance
 *
 * Migrates a process instance to a new process definition.
 * This request can contain multiple mapping instructions to define mapping between the active
 * process instance's elements and target process definition elements.
 *
 * Use this to upgrade a process instance to a new version of a process or to
 * a different process definition, e.g. to keep your running instances up-to-date with the
 * latest process improvements.
 *
 */
export const migrateProcessInstance = <ThrowOnError extends boolean = true>(options: Options<MigrateProcessInstanceData, ThrowOnError>) => {
    return (options.client ?? client).post<MigrateProcessInstanceResponses, MigrateProcessInstanceErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/process-instances/{processInstanceKey}/migration',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Modify process instance
 *
 * Modifies a running process instance.
 * This request can contain multiple instructions to activate an element of the process or
 * to terminate an active instance of an element.
 *
 * Use this to repair a process instance that is stuck on an element or took an unintended path.
 * For example, because an external system is not available or doesn't respond as expected.
 *
 */
export const modifyProcessInstance = <ThrowOnError extends boolean = true>(options: Options<ModifyProcessInstanceData, ThrowOnError>) => {
    return (options.client ?? client).post<ModifyProcessInstanceResponses, ModifyProcessInstanceErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/process-instances/{processInstanceKey}/modification',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get sequence flows
 *
 * Get sequence flows taken by the process instance.
 */
export const getProcessInstanceSequenceFlows = <ThrowOnError extends boolean = true>(options: Options<GetProcessInstanceSequenceFlowsData, ThrowOnError>) => {
    return (options.client ?? client).get<GetProcessInstanceSequenceFlowsResponses, GetProcessInstanceSequenceFlowsErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/process-instances/{processInstanceKey}/sequence-flows',
        ...options
    });
};

/**
 * Get element instance statistics
 *
 * Get statistics about elements by the process instance key.
 */
export const getProcessInstanceStatistics = <ThrowOnError extends boolean = true>(options: Options<GetProcessInstanceStatisticsData, ThrowOnError>) => {
    return (options.client ?? client).get<GetProcessInstanceStatisticsResponses, GetProcessInstanceStatisticsErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/process-instances/{processInstanceKey}/statistics/element-instances',
        ...options
    });
};

/**
 * Get resource
 *
 * Returns a deployed resource.
 * :::info
 * Currently, this endpoint only supports RPA resources.
 * :::
 *
 */
export const getResource = <ThrowOnError extends boolean = true>(options: Options<GetResourceData, ThrowOnError>) => {
    return (options.client ?? client).get<GetResourceResponses, GetResourceErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/resources/{resourceKey}',
        ...options
    });
};

/**
 * Get resource content
 *
 * Returns the content of a deployed resource.
 * :::info
 * Currently, this endpoint only supports RPA resources.
 * :::
 *
 */
export const getResourceContent = <ThrowOnError extends boolean = true>(options: Options<GetResourceContentData, ThrowOnError>) => {
    return (options.client ?? client).get<GetResourceContentResponses, GetResourceContentErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/resources/{resourceKey}/content',
        ...options
    });
};

/**
 * Delete resource
 *
 * Deletes a deployed resource.
 * This can be a process definition, decision requirements definition, or form definition
 * deployed using the deploy resources endpoint. Specify the resource you want to delete in the `resourceKey` parameter.
 *
 */
export const deleteResource = <ThrowOnError extends boolean = true>(options: Options<DeleteResourceData, ThrowOnError>) => {
    return (options.client ?? client).post<DeleteResourceResponses, DeleteResourceErrors, ThrowOnError>({
        requestValidator: undefined,
        url: '/resources/{resourceKey}/deletion',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Create role
 *
 * Create a new role.
 */
export const createRole = <ThrowOnError extends boolean = true>(options?: Options<CreateRoleData, ThrowOnError>) => {
    return (options?.client ?? client).post<CreateRoleResponses, CreateRoleErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/roles',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Search roles
 *
 * Search for roles based on given criteria.
 */
export const searchRoles = <ThrowOnError extends boolean = true>(options?: Options<SearchRolesData, ThrowOnError>) => {
    return (options?.client ?? client).post<SearchRolesResponses, SearchRolesErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/roles/search',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Delete role
 *
 * Deletes the role with the given ID.
 */
export const deleteRole = <ThrowOnError extends boolean = true>(options: Options<DeleteRoleData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteRoleResponses, DeleteRoleErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/roles/{roleId}',
        ...options
    });
};

/**
 * Get role
 *
 * Get a role by its ID.
 */
export const getRole = <ThrowOnError extends boolean = true>(options: Options<GetRoleData, ThrowOnError>) => {
    return (options.client ?? client).get<GetRoleResponses, GetRoleErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/roles/{roleId}',
        ...options
    });
};

/**
 * Update role
 *
 * Update a role with the given ID.
 */
export const updateRole = <ThrowOnError extends boolean = true>(options: Options<UpdateRoleData, ThrowOnError>) => {
    return (options.client ?? client).put<UpdateRoleResponses, UpdateRoleErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/roles/{roleId}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Search role clients
 *
 * Search clients with assigned role.
 */
export const searchClientsForRole = <ThrowOnError extends boolean = true>(options: Options<SearchClientsForRoleData, ThrowOnError>) => {
    return (options.client ?? client).post<SearchClientsForRoleResponses, SearchClientsForRoleErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/roles/{roleId}/clients/search',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Unassign a role from a client
 *
 * Unassigns the specified role from the client. The client will no longer inherit the authorizations associated with this role.
 */
export const unassignRoleFromClient = <ThrowOnError extends boolean = true>(options: Options<UnassignRoleFromClientData, ThrowOnError>) => {
    return (options.client ?? client).delete<UnassignRoleFromClientResponses, UnassignRoleFromClientErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/roles/{roleId}/clients/{clientId}',
        ...options
    });
};

/**
 * Assign a role to a client
 *
 * Assigns the specified role to the client. The client will inherit the authorizations associated with this role.
 */
export const assignRoleToClient = <ThrowOnError extends boolean = true>(options: Options<AssignRoleToClientData, ThrowOnError>) => {
    return (options.client ?? client).put<AssignRoleToClientResponses, AssignRoleToClientErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/roles/{roleId}/clients/{clientId}',
        ...options
    });
};

/**
 * Search role groups
 *
 * Search groups with assigned role.
 */
export const searchGroupsForRole = <ThrowOnError extends boolean = true>(options: Options<SearchGroupsForRoleData, ThrowOnError>) => {
    return (options.client ?? client).post<SearchGroupsForRoleResponses, SearchGroupsForRoleErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/roles/{roleId}/groups/search',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Unassign a role from a group
 *
 * Unassigns the specified role from the group. All group members (user or client) no longer inherit the authorizations associated with this role.
 */
export const unassignRoleFromGroup = <ThrowOnError extends boolean = true>(options: Options<UnassignRoleFromGroupData, ThrowOnError>) => {
    return (options.client ?? client).delete<UnassignRoleFromGroupResponses, UnassignRoleFromGroupErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/roles/{roleId}/groups/{groupId}',
        ...options
    });
};

/**
 * Assign a role to a group
 *
 * Assigns the specified role to the group. Every member of the group (user or client) will inherit the authorizations associated with this role.
 */
export const assignRoleToGroup = <ThrowOnError extends boolean = true>(options: Options<AssignRoleToGroupData, ThrowOnError>) => {
    return (options.client ?? client).put<AssignRoleToGroupResponses, AssignRoleToGroupErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/roles/{roleId}/groups/{groupId}',
        ...options
    });
};

/**
 * Search role mapping rules
 *
 * Search mapping rules with assigned role.
 */
export const searchMappingRulesForRole = <ThrowOnError extends boolean = true>(options: Options<SearchMappingRulesForRoleData, ThrowOnError>) => {
    return (options.client ?? client).post<SearchMappingRulesForRoleResponses, SearchMappingRulesForRoleErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/roles/{roleId}/mapping-rules/search',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Unassign a role from a mapping rule
 *
 * Unassigns a role from a mapping rule.
 */
export const unassignRoleFromMappingRule = <ThrowOnError extends boolean = true>(options: Options<UnassignRoleFromMappingRuleData, ThrowOnError>) => {
    return (options.client ?? client).delete<UnassignRoleFromMappingRuleResponses, UnassignRoleFromMappingRuleErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/roles/{roleId}/mapping-rules/{mappingRuleId}',
        ...options
    });
};

/**
 * Assign a role to a mapping rule
 *
 * Assigns a role to a mapping rule.
 */
export const assignRoleToMappingRule = <ThrowOnError extends boolean = true>(options: Options<AssignRoleToMappingRuleData, ThrowOnError>) => {
    return (options.client ?? client).put<AssignRoleToMappingRuleResponses, AssignRoleToMappingRuleErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/roles/{roleId}/mapping-rules/{mappingRuleId}',
        ...options
    });
};

/**
 * Search role users
 *
 * Search users with assigned role.
 */
export const searchUsersForRole = <ThrowOnError extends boolean = true>(options: Options<SearchUsersForRoleData, ThrowOnError>) => {
    return (options.client ?? client).post<SearchUsersForRoleResponses, SearchUsersForRoleErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/roles/{roleId}/users/search',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Unassign a role from a user
 *
 * Unassigns a role from a user. The user will no longer inherit the authorizations associated with this role.
 */
export const unassignRoleFromUser = <ThrowOnError extends boolean = true>(options: Options<UnassignRoleFromUserData, ThrowOnError>) => {
    return (options.client ?? client).delete<UnassignRoleFromUserResponses, UnassignRoleFromUserErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/roles/{roleId}/users/{username}',
        ...options
    });
};

/**
 * Assign a role to a user
 *
 * Assigns the specified role to the user. The user will inherit the authorizations associated with this role.
 */
export const assignRoleToUser = <ThrowOnError extends boolean = true>(options: Options<AssignRoleToUserData, ThrowOnError>) => {
    return (options.client ?? client).put<AssignRoleToUserResponses, AssignRoleToUserErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/roles/{roleId}/users/{username}',
        ...options
    });
};

/**
 * Create admin user
 *
 * Creates a new user and assigns the admin role to it. This endpoint is only usable when users are managed in the Orchestration Cluster and while no user is assigned to the admin role.
 */
export const createAdminUser = <ThrowOnError extends boolean = true>(options: Options<CreateAdminUserData, ThrowOnError>) => {
    return (options.client ?? client).post<CreateAdminUserResponses, CreateAdminUserErrors, ThrowOnError>({
        requestValidator: undefined,
        url: '/setup/user',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Broadcast signal
 *
 * Broadcasts a signal.
 */
export const broadcastSignal = <ThrowOnError extends boolean = true>(options: Options<BroadcastSignalData, ThrowOnError>) => {
    return (options.client ?? client).post<BroadcastSignalResponses, BroadcastSignalErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/signals/broadcast',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get cluster status
 *
 * Checks the health status of the cluster by verifying if there's at least one partition with a healthy leader.
 */
export const getStatus = <ThrowOnError extends boolean = true>(options?: Options<GetStatusData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetStatusResponses, GetStatusErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/status',
        ...options
    });
};

/**
 * Get usage metrics
 *
 * Retrieve the usage metrics based on given criteria.
 */
export const getUsageMetrics = <ThrowOnError extends boolean = true>(options: Options<GetUsageMetricsData, ThrowOnError>) => {
    return (options.client ?? client).get<GetUsageMetricsResponses, GetUsageMetricsErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/system/usage-metrics',
        ...options
    });
};

/**
 * Create tenant
 *
 * Creates a new tenant.
 */
export const createTenant = <ThrowOnError extends boolean = true>(options: Options<CreateTenantData, ThrowOnError>) => {
    return (options.client ?? client).post<CreateTenantResponses, CreateTenantErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/tenants',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Search tenants
 *
 * Retrieves a filtered and sorted list of tenants.
 */
export const searchTenants = <ThrowOnError extends boolean = true>(options?: Options<SearchTenantsData, ThrowOnError>) => {
    return (options?.client ?? client).post<SearchTenantsResponses, SearchTenantsErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/tenants/search',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Delete tenant
 *
 * Deletes an existing tenant.
 */
export const deleteTenant = <ThrowOnError extends boolean = true>(options: Options<DeleteTenantData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteTenantResponses, DeleteTenantErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/tenants/{tenantId}',
        ...options
    });
};

/**
 * Get tenant
 *
 * Retrieves a single tenant by tenant ID.
 */
export const getTenant = <ThrowOnError extends boolean = true>(options: Options<GetTenantData, ThrowOnError>) => {
    return (options.client ?? client).get<GetTenantResponses, GetTenantErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/tenants/{tenantId}',
        ...options
    });
};

/**
 * Update tenant
 *
 * Updates an existing tenant.
 */
export const updateTenant = <ThrowOnError extends boolean = true>(options: Options<UpdateTenantData, ThrowOnError>) => {
    return (options.client ?? client).put<UpdateTenantResponses, UpdateTenantErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/tenants/{tenantId}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Search clients for tenant
 *
 * Retrieves a filtered and sorted list of clients for a specified tenant.
 */
export const searchClientsForTenant = <ThrowOnError extends boolean = true>(options: Options<SearchClientsForTenantData, ThrowOnError>) => {
    return (options.client ?? client).post<SearchClientsForTenantResponses, unknown, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/tenants/{tenantId}/clients/search',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Unassign a client from a tenant
 *
 * Unassigns the client from the specified tenant.
 * The client can no longer access tenant data.
 *
 */
export const unassignClientFromTenant = <ThrowOnError extends boolean = true>(options: Options<UnassignClientFromTenantData, ThrowOnError>) => {
    return (options.client ?? client).delete<UnassignClientFromTenantResponses, UnassignClientFromTenantErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/tenants/{tenantId}/clients/{clientId}',
        ...options
    });
};

/**
 * Assign a client to a tenant
 *
 * Assign the client to the specified tenant.
 * The client can then access tenant data and perform authorized actions.
 *
 */
export const assignClientToTenant = <ThrowOnError extends boolean = true>(options: Options<AssignClientToTenantData, ThrowOnError>) => {
    return (options.client ?? client).put<AssignClientToTenantResponses, AssignClientToTenantErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/tenants/{tenantId}/clients/{clientId}',
        ...options
    });
};

/**
 * Search groups for tenant
 *
 * Retrieves a filtered and sorted list of groups for a specified tenant.
 */
export const searchGroupIdsForTenant = <ThrowOnError extends boolean = true>(options: Options<SearchGroupIdsForTenantData, ThrowOnError>) => {
    return (options.client ?? client).post<SearchGroupIdsForTenantResponses, unknown, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/tenants/{tenantId}/groups/search',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Unassign a group from a tenant
 *
 * Unassigns a group from a specified tenant.
 * Members of the group (users, clients) will no longer have access to the tenant's data - except they are assigned directly to the tenant.
 *
 */
export const unassignGroupFromTenant = <ThrowOnError extends boolean = true>(options: Options<UnassignGroupFromTenantData, ThrowOnError>) => {
    return (options.client ?? client).delete<UnassignGroupFromTenantResponses, UnassignGroupFromTenantErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/tenants/{tenantId}/groups/{groupId}',
        ...options
    });
};

/**
 * Assign a group to a tenant
 *
 * Assigns a group to a specified tenant.
 * Group members (users, clients) can then access tenant data and perform authorized actions.
 *
 */
export const assignGroupToTenant = <ThrowOnError extends boolean = true>(options: Options<AssignGroupToTenantData, ThrowOnError>) => {
    return (options.client ?? client).put<AssignGroupToTenantResponses, AssignGroupToTenantErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/tenants/{tenantId}/groups/{groupId}',
        ...options
    });
};

/**
 * Search mapping rules for tenant
 *
 * Retrieves a filtered and sorted list of MappingRules for a specified tenant.
 */
export const searchMappingRulesForTenant = <ThrowOnError extends boolean = true>(options: Options<SearchMappingRulesForTenantData, ThrowOnError>) => {
    return (options.client ?? client).post<SearchMappingRulesForTenantResponses, unknown, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/tenants/{tenantId}/mapping-rules/search',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Unassign a mapping rule from a tenant
 *
 * Unassigns a single mapping rule from a specified tenant without deleting the rule.
 */
export const unassignMappingRuleFromTenant = <ThrowOnError extends boolean = true>(options: Options<UnassignMappingRuleFromTenantData, ThrowOnError>) => {
    return (options.client ?? client).delete<UnassignMappingRuleFromTenantResponses, UnassignMappingRuleFromTenantErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/tenants/{tenantId}/mapping-rules/{mappingRuleId}',
        ...options
    });
};

/**
 * Assign a mapping rule to a tenant
 *
 * Assign a single mapping rule to a specified tenant.
 */
export const assignMappingRuleToTenant = <ThrowOnError extends boolean = true>(options: Options<AssignMappingRuleToTenantData, ThrowOnError>) => {
    return (options.client ?? client).put<AssignMappingRuleToTenantResponses, AssignMappingRuleToTenantErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/tenants/{tenantId}/mapping-rules/{mappingRuleId}',
        ...options
    });
};

/**
 * Search roles for tenant
 *
 * Retrieves a filtered and sorted list of roles for a specified tenant.
 */
export const searchRolesForTenant = <ThrowOnError extends boolean = true>(options: Options<SearchRolesForTenantData, ThrowOnError>) => {
    return (options.client ?? client).post<SearchRolesForTenantResponses, unknown, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/tenants/{tenantId}/roles/search',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Unassign a role from a tenant
 *
 * Unassigns a role from a specified tenant.
 * Users, Clients or Groups, that have the role assigned, will no longer have access to the
 * tenant's data - unless they are assigned directly to the tenant.
 *
 */
export const unassignRoleFromTenant = <ThrowOnError extends boolean = true>(options: Options<UnassignRoleFromTenantData, ThrowOnError>) => {
    return (options.client ?? client).delete<UnassignRoleFromTenantResponses, UnassignRoleFromTenantErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/tenants/{tenantId}/roles/{roleId}',
        ...options
    });
};

/**
 * Assign a role to a tenant
 *
 * Assigns a role to a specified tenant.
 * Users, Clients or Groups, that have the role assigned, will get access to the tenant's data and can perform actions according to their authorizations.
 *
 */
export const assignRoleToTenant = <ThrowOnError extends boolean = true>(options: Options<AssignRoleToTenantData, ThrowOnError>) => {
    return (options.client ?? client).put<AssignRoleToTenantResponses, AssignRoleToTenantErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/tenants/{tenantId}/roles/{roleId}',
        ...options
    });
};

/**
 * Search users for tenant
 *
 * Retrieves a filtered and sorted list of users for a specified tenant.
 */
export const searchUsersForTenant = <ThrowOnError extends boolean = true>(options: Options<SearchUsersForTenantData, ThrowOnError>) => {
    return (options.client ?? client).post<SearchUsersForTenantResponses, unknown, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/tenants/{tenantId}/users/search',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Unassign a user from a tenant
 *
 * Unassigns the user from the specified tenant.
 * The user can no longer access tenant data.
 *
 */
export const unassignUserFromTenant = <ThrowOnError extends boolean = true>(options: Options<UnassignUserFromTenantData, ThrowOnError>) => {
    return (options.client ?? client).delete<UnassignUserFromTenantResponses, UnassignUserFromTenantErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/tenants/{tenantId}/users/{username}',
        ...options
    });
};

/**
 * Assign a user to a tenant
 *
 * Assign a single user to a specified tenant. The user can then access tenant data and perform authorized actions.
 */
export const assignUserToTenant = <ThrowOnError extends boolean = true>(options: Options<AssignUserToTenantData, ThrowOnError>) => {
    return (options.client ?? client).put<AssignUserToTenantResponses, AssignUserToTenantErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/tenants/{tenantId}/users/{username}',
        ...options
    });
};

/**
 * Get cluster topology
 *
 * Obtains the current topology of the cluster the gateway is part of.
 */
export const getTopology = <ThrowOnError extends boolean = true>(options?: Options<GetTopologyData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetTopologyResponses, GetTopologyErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/topology',
        ...options
    });
};

/**
 * Create user
 *
 * Create a new user.
 */
export const createUser = <ThrowOnError extends boolean = true>(options: Options<CreateUserData, ThrowOnError>) => {
    return (options.client ?? client).post<CreateUserResponses, CreateUserErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/users',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Search users
 *
 * Search for users based on given criteria.
 */
export const searchUsers = <ThrowOnError extends boolean = true>(options?: Options<SearchUsersData, ThrowOnError>) => {
    return (options?.client ?? client).post<SearchUsersResponses, SearchUsersErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/users/search',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Delete user
 *
 * Deletes a user.
 */
export const deleteUser = <ThrowOnError extends boolean = true>(options: Options<DeleteUserData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteUserResponses, DeleteUserErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/users/{username}',
        ...options
    });
};

/**
 * Get user
 *
 * Get a user by its username.
 */
export const getUser = <ThrowOnError extends boolean = true>(options: Options<GetUserData, ThrowOnError>) => {
    return (options.client ?? client).get<GetUserResponses, GetUserErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/users/{username}',
        ...options
    });
};

/**
 * Update user
 *
 * Updates a user.
 */
export const updateUser = <ThrowOnError extends boolean = true>(options: Options<UpdateUserData, ThrowOnError>) => {
    return (options.client ?? client).put<UpdateUserResponses, UpdateUserErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/users/{username}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Search user tasks
 *
 * Search for user tasks based on given criteria.
 */
export const searchUserTasks = <ThrowOnError extends boolean = true>(options?: Options<SearchUserTasksData, ThrowOnError>) => {
    return (options?.client ?? client).post<SearchUserTasksResponses, SearchUserTasksErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/user-tasks/search',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Get user task
 *
 * Get the user task by the user task key.
 */
export const getUserTask = <ThrowOnError extends boolean = true>(options: Options<GetUserTaskData, ThrowOnError>) => {
    return (options.client ?? client).get<GetUserTaskResponses, GetUserTaskErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/user-tasks/{userTaskKey}',
        ...options
    });
};

/**
 * Update user task
 *
 * Update a user task with the given key.
 */
export const updateUserTask = <ThrowOnError extends boolean = true>(options: Options<UpdateUserTaskData, ThrowOnError>) => {
    return (options.client ?? client).patch<UpdateUserTaskResponses, UpdateUserTaskErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/user-tasks/{userTaskKey}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Unassign user task
 *
 * Removes the assignee of a task with the given key.
 */
export const unassignUserTask = <ThrowOnError extends boolean = true>(options: Options<UnassignUserTaskData, ThrowOnError>) => {
    return (options.client ?? client).delete<UnassignUserTaskResponses, UnassignUserTaskErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/user-tasks/{userTaskKey}/assignee',
        ...options
    });
};

/**
 * Assign user task
 *
 * Assigns a user task with the given key to the given assignee.
 */
export const assignUserTask = <ThrowOnError extends boolean = true>(options: Options<AssignUserTaskData, ThrowOnError>) => {
    return (options.client ?? client).post<AssignUserTaskResponses, AssignUserTaskErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/user-tasks/{userTaskKey}/assignment',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Search user task audit logs
 *
 * Search for user task audit logs based on given criteria.
 */
export const searchUserTaskAuditLogs = <ThrowOnError extends boolean = true>(options: Options<SearchUserTaskAuditLogsData, ThrowOnError>) => {
    return (options.client ?? client).post<SearchUserTaskAuditLogsResponses, SearchUserTaskAuditLogsErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/user-tasks/{userTaskKey}/audit-logs/search',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Complete user task
 *
 * Completes a user task with the given key.
 */
export const completeUserTask = <ThrowOnError extends boolean = true>(options: Options<CompleteUserTaskData, ThrowOnError>) => {
    return (options.client ?? client).post<CompleteUserTaskResponses, CompleteUserTaskErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/user-tasks/{userTaskKey}/completion',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get user task form
 *
 * Get the form of a user task.
 * Note that this endpoint will only return linked forms. This endpoint does not support embedded forms.
 *
 */
export const getUserTaskForm = <ThrowOnError extends boolean = true>(options: Options<GetUserTaskFormData, ThrowOnError>) => {
    return (options.client ?? client).get<GetUserTaskFormResponses, GetUserTaskFormErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/user-tasks/{userTaskKey}/form',
        ...options
    });
};

/**
 * Search user task variables
 *
 * Search for user task variables based on given criteria. By default, long variable values in the response are truncated.
 */
export const searchUserTaskVariables = <ThrowOnError extends boolean = true>(options: Options<SearchUserTaskVariablesData, ThrowOnError>) => {
    return (options.client ?? client).post<SearchUserTaskVariablesResponses, SearchUserTaskVariablesErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/user-tasks/{userTaskKey}/variables/search',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Search variables
 *
 * Search for process and local variables based on given criteria. By default, long variable values in the response are truncated.
 */
export const searchVariables = <ThrowOnError extends boolean = true>(options?: Options<SearchVariablesData, ThrowOnError>) => {
    return (options?.client ?? client).post<SearchVariablesResponses, SearchVariablesErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/variables/search',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Get variable
 *
 * Get the variable by the variable key.
 */
export const getVariable = <ThrowOnError extends boolean = true>(options: Options<GetVariableData, ThrowOnError>) => {
    return (options.client ?? client).get<GetVariableResponses, GetVariableErrors, ThrowOnError>({
        requestValidator: undefined,
        responseValidator: undefined,
        url: '/variables/{variableKey}',
        ...options
    });
};
