// This file is auto-generated by @hey-api/openapi-ts

export type CamundaKey< T extends string = string > = string & { readonly __brand: T };
// branding-plugin patch: applied primitive branding

export type ClientOptions = {
    baseUrl: '{schema}://{host}:{port}/v2' | (string & {});
};

/**
 * Audit log item.
 */
export type AuditLogResult = {
    /**
     * The unique key of the audit log entry.
     */
    auditLogKey?: AuditLogKey;
    entityKey?: AuditLogEntityKey;
    entityType?: AuditLogEntityTypeEnum;
    operationType?: AuditLogOperationTypeEnum;
    /**
     * Key of the batch operation.
     */
    batchOperationKey?: BatchOperationKey;
    /**
     * The type of batch operation performed, if this is part of a batch.
     */
    batchOperationType?: BatchOperationTypeEnum;
    /**
     * The timestamp when the operation occurred.
     */
    timestamp?: string;
    /**
     * The ID of the actor who performed the operation.
     */
    actorId?: string;
    actorType?: AuditLogActorTypeEnum;
    /**
     * The element ID of the agent that performed the operation (e.g. ad-hoc subprocess element ID).
     */
    agentElementId?: string;
    /**
     * The tenant ID of the audit log.
     */
    tenantId?: TenantId;
    result?: AuditLogResultEnum;
    /**
     * Additional notes about the operation.
     */
    annotation?: string;
    category?: AuditLogCategoryEnum;
    /**
     * The process definition ID.
     */
    processDefinitionId?: ProcessDefinitionId;
    /**
     * The key of the process definition.
     */
    processDefinitionKey?: ProcessDefinitionKey;
    /**
     * The key of the process instance.
     */
    processInstanceKey?: ProcessInstanceKey;
    rootProcessInstanceKey?: RootProcessInstanceKey;
    /**
     * The key of the element instance.
     */
    elementInstanceKey?: ElementInstanceKey;
    /**
     * The key of the job.
     */
    jobKey?: JobKey;
    /**
     * The key of the user task.
     */
    userTaskKey?: UserTaskKey;
    /**
     * The decision requirements ID.
     */
    decisionRequirementsId?: string;
    /**
     * The assigned key of the decision requirements.
     */
    decisionRequirementsKey?: DecisionRequirementsKey;
    /**
     * The decision definition ID.
     */
    decisionDefinitionId?: DecisionDefinitionId;
    /**
     * The key of the decision definition.
     */
    decisionDefinitionKey?: DecisionDefinitionKey;
    /**
     * The key of the decision evaluation.
     */
    decisionEvaluationKey?: DecisionEvaluationKey;
    /**
     * The key of the deployment.
     */
    deploymentKey?: DeploymentKey;
    /**
     * The key of the form.
     */
    formKey?: FormKey;
    /**
     * The system-assigned key for this resource.
     */
    resourceKey?: ResourceKey;
    /**
     * The key of the related entity. The content depends on the operation type and entity type.
     * For example, for authorization operations, this will contain the ID of the owner (e.g., user or group) the authorization belongs to.
     *
     */
    relatedEntityKey?: AuditLogEntityKey;
    /**
     * The type of the related entity. The content depends on the operation type and entity type.
     * For example, for authorization operations, this will contain the type of the owner (e.g., USER or GROUP) the authorization belongs to.
     *
     */
    relatedEntityType?: AuditLogEntityTypeEnum;
    /**
     * Additional description of the entity affected by the operation.
     * For example, for variable operations, this will contain the variable name.
     *
     */
    entityDescription?: string;
};

export type AuditLogSearchQuerySortRequest = {
    /**
     * The field to sort by.
     */
    field: 'actorId' | 'actorType' | 'annotation' | 'auditLogKey' | 'batchOperationKey' | 'batchOperationType' | 'category' | 'decisionDefinitionId' | 'decisionDefinitionKey' | 'decisionEvaluationKey' | 'decisionRequirementsId' | 'decisionRequirementsKey' | 'elementInstanceKey' | 'entityKey' | 'entityType' | 'jobKey' | 'operationType' | 'processDefinitionId' | 'processDefinitionKey' | 'processInstanceKey' | 'result' | 'tenantId' | 'timestamp' | 'userTaskKey';
    order?: SortOrderEnum;
};

/**
 * Audit log search request.
 */
export type AuditLogSearchQueryRequest = SearchQueryRequest & {
    /**
     * Sort field criteria.
     */
    sort?: Array<AuditLogSearchQuerySortRequest>;
    /**
     * The audit log search filters.
     */
    filter?: AuditLogFilter;
};

/**
 * Audit log filter request
 */
export type AuditLogFilter = {
    /**
     * The audit log key search filter.
     */
    auditLogKey?: AuditLogKeyFilterProperty;
    /**
     * The process definition key search filter.
     */
    processDefinitionKey?: ProcessDefinitionKeyFilterProperty;
    /**
     * The process instance key search filter.
     */
    processInstanceKey?: ProcessInstanceKeyFilterProperty;
    /**
     * The element instance key search filter.
     */
    elementInstanceKey?: ElementInstanceKeyFilterProperty;
    /**
     * The operation type search filter.
     */
    operationType?: OperationTypeFilterProperty;
    /**
     * The result search filter.
     */
    result?: AuditLogResultFilterProperty;
    /**
     * The timestamp search filter.
     */
    timestamp?: DateTimeFilterProperty;
    /**
     * The actor ID search filter.
     */
    actorId?: StringFilterProperty;
    /**
     * The actor type search filter.
     */
    actorType?: AuditLogActorTypeFilterProperty;
    /**
     * The agent element ID search filter.
     */
    agentElementId?: StringFilterProperty;
    /**
     * The entity key search filter.
     */
    entityKey?: AuditLogEntityKeyFilterProperty;
    /**
     * The entity type search filter.
     */
    entityType?: EntityTypeFilterProperty;
    /**
     * The tenant ID search filter.
     */
    tenantId?: StringFilterProperty;
    /**
     * The category search filter.
     */
    category?: CategoryFilterProperty;
    /**
     * The deployment key search filter.
     */
    deploymentKey?: DeploymentKeyFilterProperty;
    /**
     * The form key search filter.
     */
    formKey?: FormKeyFilterProperty;
    /**
     * The resource key search filter.
     */
    resourceKey?: ResourceKeyFilterProperty;
    /**
     * The batch operation type search filter.
     */
    batchOperationType?: BatchOperationTypeFilterProperty;
    /**
     * The process definition ID search filter.
     */
    processDefinitionId?: StringFilterProperty;
    /**
     * The job key search filter.
     */
    jobKey?: JobKeyFilterProperty;
    /**
     * The user task key search filter.
     */
    userTaskKey?: BasicStringFilterProperty;
    /**
     * The decision requirements ID search filter.
     */
    decisionRequirementsId?: StringFilterProperty;
    /**
     * The decision requirements key search filter.
     */
    decisionRequirementsKey?: DecisionRequirementsKeyFilterProperty;
    /**
     * The decision definition ID search filter.
     */
    decisionDefinitionId?: StringFilterProperty;
    /**
     * The decision definition key search filter.
     */
    decisionDefinitionKey?: DecisionDefinitionKeyFilterProperty;
    /**
     * The decision evaluation key search filter.
     */
    decisionEvaluationKey?: DecisionEvaluationKeyFilterProperty;
    /**
     * The related entity key search filter.
     */
    relatedEntityKey?: AuditLogEntityKeyFilterProperty;
    /**
     * The related entity type search filter.
     */
    relatedEntityType?: EntityTypeFilterProperty;
    /**
     * The entity description filter.
     */
    entityDescription?: StringFilterProperty;
};

/**
 * Audit log search response.
 */
export type AuditLogSearchQueryResult = SearchQueryResponse & {
    /**
     * The matching audit logs.
     */
    items?: Array<AuditLogResult>;
};

/**
 * System-generated entity key for an audit log entry.
 */
export type AuditLogEntityKey = CamundaKey<'AuditLogEntityKey'>;

/**
 * The type of entity affected by the operation.
 */
export type AuditLogEntityTypeEnum = 'AUTHORIZATION' | 'BATCH' | 'DECISION' | 'GROUP' | 'INCIDENT' | 'MAPPING_RULE' | 'PROCESS_INSTANCE' | 'RESOURCE' | 'ROLE' | 'TENANT' | 'USER' | 'USER_TASK' | 'VARIABLE' | 'CLIENT';

/**
 * The type of operation performed.
 */
export type AuditLogOperationTypeEnum = 'ASSIGN' | 'CANCEL' | 'COMPLETE' | 'CREATE' | 'DELETE' | 'EVALUATE' | 'MIGRATE' | 'MODIFY' | 'RESOLVE' | 'RESUME' | 'SUSPEND' | 'UNASSIGN' | 'UNKNOWN' | 'UPDATE';

/**
 * The type of actor who performed the operation.
 */
export type AuditLogActorTypeEnum = 'ANONYMOUS' | 'CLIENT' | 'UNKNOWN' | 'USER';

/**
 * The result status of the operation.
 */
export type AuditLogResultEnum = 'FAIL' | 'SUCCESS';

/**
 * The category of the audit log operation.
 */
export type AuditLogCategoryEnum = 'ADMIN' | 'DEPLOYED_RESOURCES' | 'USER_TASKS';

/**
 * EntityKey property with full advanced search capabilities.
 */
export type AuditLogEntityKeyFilterProperty = AuditLogEntityKeyExactMatch | AdvancedAuditLogEntityKeyFilter;

/**
 * Advanced filter
 *
 * Advanced entityKey filter.
 */
export type AdvancedAuditLogEntityKeyFilter = {
    /**
     * Checks for equality with the provided value.
     */
    $eq?: AuditLogEntityKey;
    /**
     * Checks for inequality with the provided value.
     */
    $neq?: AuditLogEntityKey;
    /**
     * Checks if the current property exists.
     */
    $exists?: boolean;
    /**
     * Checks if the property matches any of the provided values.
     */
    $in?: Array<AuditLogEntityKey>;
    /**
     * Checks if the property matches none of the provided values.
     */
    $notIn?: Array<AuditLogEntityKey>;
};

/**
 * AuditLogEntityTypeEnum property with full advanced search capabilities.
 */
export type EntityTypeFilterProperty = EntityTypeExactMatch | AdvancedEntityTypeFilter;

/**
 * Advanced filter
 *
 * Advanced AuditLogEntityTypeEnum filter.
 */
export type AdvancedEntityTypeFilter = {
    /**
     * Checks for equality with the provided value.
     */
    $eq?: AuditLogEntityTypeEnum;
    /**
     * Checks for inequality with the provided value.
     */
    $neq?: AuditLogEntityTypeEnum;
    /**
     * Checks if the current property exists.
     */
    $exists?: boolean;
    /**
     * Checks if the property matches any of the provided values.
     */
    $in?: Array<AuditLogEntityTypeEnum>;
    $like?: LikeFilter;
};

/**
 * AuditLogOperationTypeEnum property with full advanced search capabilities.
 */
export type OperationTypeFilterProperty = OperationTypeExactMatch | AdvancedOperationTypeFilter;

/**
 * Advanced filter
 *
 * Advanced AuditLogOperationTypeEnum filter.
 */
export type AdvancedOperationTypeFilter = {
    /**
     * Checks for equality with the provided value.
     */
    $eq?: AuditLogOperationTypeEnum;
    /**
     * Checks for inequality with the provided value.
     */
    $neq?: AuditLogOperationTypeEnum;
    /**
     * Checks if the current property exists.
     */
    $exists?: boolean;
    /**
     * Checks if the property matches any of the provided values.
     */
    $in?: Array<AuditLogOperationTypeEnum>;
    $like?: LikeFilter;
};

/**
 * AuditLogCategoryEnum property with full advanced search capabilities.
 */
export type CategoryFilterProperty = CategoryExactMatch | AdvancedCategoryFilter;

/**
 * Advanced filter
 *
 * Advanced AuditLogCategoryEnum filter.
 */
export type AdvancedCategoryFilter = {
    /**
     * Checks for equality with the provided value.
     */
    $eq?: AuditLogCategoryEnum;
    /**
     * Checks for inequality with the provided value.
     */
    $neq?: AuditLogCategoryEnum;
    /**
     * Checks if the current property exists.
     */
    $exists?: boolean;
    /**
     * Checks if the property matches any of the provided values.
     */
    $in?: Array<AuditLogCategoryEnum>;
    $like?: LikeFilter;
};

/**
 * AuditLogResultEnum property with full advanced search capabilities.
 */
export type AuditLogResultFilterProperty = AuditLogResultExactMatch | AdvancedResultFilter;

/**
 * Advanced filter
 *
 * Advanced AuditLogResultEnum filter.
 */
export type AdvancedResultFilter = {
    /**
     * Checks for equality with the provided value.
     */
    $eq?: AuditLogResultEnum;
    /**
     * Checks for inequality with the provided value.
     */
    $neq?: AuditLogResultEnum;
    /**
     * Checks if the current property exists.
     */
    $exists?: boolean;
    /**
     * Checks if the property matches any of the provided values.
     */
    $in?: Array<AuditLogResultEnum>;
    $like?: LikeFilter;
};

/**
 * AuditLogActorTypeEnum property with full advanced search capabilities.
 */
export type AuditLogActorTypeFilterProperty = AuditLogActorTypeExactMatch | AdvancedActorTypeFilter;

/**
 * Advanced filter
 *
 * Advanced AuditLogActorTypeEnum filter.
 */
export type AdvancedActorTypeFilter = {
    /**
     * Checks for equality with the provided value.
     */
    $eq?: AuditLogActorTypeEnum;
    /**
     * Checks for inequality with the provided value.
     */
    $neq?: AuditLogActorTypeEnum;
    /**
     * Checks if the current property exists.
     */
    $exists?: boolean;
    /**
     * Checks if the property matches any of the provided values.
     */
    $in?: Array<AuditLogActorTypeEnum>;
    $like?: LikeFilter;
};

export type CamundaUserResult = {
    /**
     * The username of the user.
     */
    username?: Username | null;
    /**
     * The display name of the user.
     */
    displayName?: string | null;
    /**
     * The email of the user.
     */
    email?: string | null;
    /**
     * The web components the user is authorized to use.
     */
    authorizedComponents?: Array<string>;
    /**
     * The tenants the user is a member of.
     */
    tenants: Array<TenantResult>;
    /**
     * The groups assigned to the user.
     */
    groups: Array<string>;
    /**
     * The roles assigned to the user.
     */
    roles: Array<string>;
    /**
     * The plan of the user.
     */
    salesPlanType: string;
    /**
     * The links to the components in the C8 stack.
     */
    c8Links: {
        [key: string]: string;
    };
    /**
     * Flag for understanding if the user is able to perform logout.
     */
    canLogout: boolean;
};

export type AuthorizationIdBasedRequest = {
    /**
     * The ID of the owner of the permissions.
     */
    ownerId: string;
    ownerType: OwnerTypeEnum;
    /**
     * The ID of the resource to add permissions to.
     */
    resourceId: string;
    /**
     * The type of resource to add permissions to.
     */
    resourceType: ResourceTypeEnum;
    /**
     * The permission types to add.
     */
    permissionTypes: Array<PermissionTypeEnum>;
};

export type AuthorizationPropertyBasedRequest = {
    /**
     * The ID of the owner of the permissions.
     */
    ownerId: string;
    ownerType: OwnerTypeEnum;
    /**
     * The name of the resource property on which this authorization is based.
     */
    resourcePropertyName: string;
    /**
     * The type of resource to add permissions to.
     */
    resourceType: ResourceTypeEnum;
    /**
     * The permission types to add.
     */
    permissionTypes: Array<PermissionTypeEnum>;
};

/**
 * Defines an authorization request.
 * Either an id-based or a property-based authorization can be provided.
 *
 */
export type AuthorizationRequest = AuthorizationIdBasedRequest | AuthorizationPropertyBasedRequest;

export type AuthorizationSearchQuerySortRequest = {
    /**
     * The field to sort by.
     */
    field: 'ownerId' | 'ownerType' | 'resourceId' | 'resourcePropertyName' | 'resourceType';
    order?: SortOrderEnum;
};

export type AuthorizationSearchQuery = SearchQueryRequest & {
    /**
     * Sort field criteria.
     */
    sort?: Array<AuthorizationSearchQuerySortRequest>;
    /**
     * The authorization search filters.
     */
    filter?: AuthorizationFilter;
};

/**
 * Authorization search filter.
 */
export type AuthorizationFilter = {
    /**
     * The ID of the owner of permissions.
     */
    ownerId?: string;
    ownerType?: OwnerTypeEnum;
    /**
     * The IDs of the resource to search permissions for.
     */
    resourceIds?: Array<string>;
    /**
     * The names of the resource properties to search permissions for.
     */
    resourcePropertyNames?: Array<string>;
    /**
     * The type of resource to search permissions for.
     */
    resourceType?: ResourceTypeEnum;
};

export type AuthorizationResult = {
    /**
     * The ID of the owner of permissions.
     */
    ownerId?: string;
    ownerType?: OwnerTypeEnum;
    /**
     * The type of resource that the permissions relate to.
     */
    resourceType?: ResourceTypeEnum;
    /**
     * ID of the resource the permission relates to (mutually exclusive with `resourcePropertyName`).
     */
    resourceId?: string;
    /**
     * The name of the resource property the permission relates to (mutually exclusive with `resourceId`).
     */
    resourcePropertyName?: string;
    /**
     * Specifies the types of the permissions.
     */
    permissionTypes?: Array<PermissionTypeEnum>;
    /**
     * The key of the authorization.
     */
    authorizationKey?: AuthorizationKey;
};

export type AuthorizationSearchResult = SearchQueryResponse & {
    /**
     * The matching authorizations.
     */
    items?: Array<AuthorizationResult>;
};

export type AuthorizationCreateResult = {
    /**
     * The key of the created authorization.
     */
    authorizationKey?: AuthorizationKey;
};

/**
 * Specifies the type of permissions.
 */
export type PermissionTypeEnum = 'ACCESS' | 'CANCEL_PROCESS_INSTANCE' | 'CLAIM' | 'COMPLETE' | 'CREATE' | 'CREATE_BATCH_OPERATION_CANCEL_PROCESS_INSTANCE' | 'CREATE_BATCH_OPERATION_DELETE_DECISION_DEFINITION' | 'CREATE_BATCH_OPERATION_DELETE_DECISION_INSTANCE' | 'CREATE_BATCH_OPERATION_DELETE_PROCESS_DEFINITION' | 'CREATE_BATCH_OPERATION_DELETE_PROCESS_INSTANCE' | 'CREATE_BATCH_OPERATION_MIGRATE_PROCESS_INSTANCE' | 'CREATE_BATCH_OPERATION_MODIFY_PROCESS_INSTANCE' | 'CREATE_BATCH_OPERATION_RESOLVE_INCIDENT' | 'CREATE_DECISION_INSTANCE' | 'CREATE_PROCESS_INSTANCE' | 'CREATE_TASK_LISTENER' | 'DELETE' | 'DELETE_DECISION_INSTANCE' | 'DELETE_DRD' | 'DELETE_FORM' | 'DELETE_PROCESS' | 'DELETE_PROCESS_INSTANCE' | 'DELETE_RESOURCE' | 'DELETE_TASK_LISTENER' | 'EVALUATE' | 'MODIFY_PROCESS_INSTANCE' | 'READ' | 'READ_DECISION_DEFINITION' | 'READ_DECISION_INSTANCE' | 'READ_JOB_METRIC' | 'READ_PROCESS_DEFINITION' | 'READ_PROCESS_INSTANCE' | 'READ_USAGE_METRIC' | 'READ_USER_TASK' | 'READ_TASK_LISTENER' | 'UPDATE' | 'UPDATE_PROCESS_INSTANCE' | 'UPDATE_USER_TASK' | 'UPDATE_TASK_LISTENER';

/**
 * The type of resource to add/remove permissions to/from.
 */
export type ResourceTypeEnum = 'AUDIT_LOG' | 'AUTHORIZATION' | 'BATCH' | 'CLUSTER_VARIABLE' | 'COMPONENT' | 'DECISION_DEFINITION' | 'DECISION_REQUIREMENTS_DEFINITION' | 'DOCUMENT' | 'EXPRESSION' | 'GLOBAL_LISTENER' | 'GROUP' | 'MAPPING_RULE' | 'MESSAGE' | 'PROCESS_DEFINITION' | 'RESOURCE' | 'ROLE' | 'SYSTEM' | 'TENANT' | 'USER' | 'USER_TASK';

/**
 * The type of the owner of permissions.
 */
export type OwnerTypeEnum = 'USER' | 'CLIENT' | 'ROLE' | 'GROUP' | 'MAPPING_RULE' | 'UNSPECIFIED';

/**
 * System-generated key for an authorization.
 */
export type AuthorizationKey = CamundaKey<'AuthorizationKey'>;

/**
 * The created batch operation.
 */
export type BatchOperationCreatedResult = {
    /**
     * Key of the batch operation.
     */
    batchOperationKey?: BatchOperationKey;
    batchOperationType?: BatchOperationTypeEnum;
};

export type BatchOperationSearchQuerySortRequest = {
    /**
     * The field to sort by.
     */
    field: 'batchOperationKey' | 'operationType' | 'state' | 'startDate' | 'endDate' | 'actorType' | 'actorId';
    order?: SortOrderEnum;
};

/**
 * Batch operation search request.
 */
export type BatchOperationSearchQuery = SearchQueryRequest & {
    /**
     * Sort field criteria.
     */
    sort?: Array<BatchOperationSearchQuerySortRequest>;
    /**
     * The batch operation search filters.
     */
    filter?: BatchOperationFilter;
};

/**
 * Batch operation filter request.
 */
export type BatchOperationFilter = {
    /**
     * The key (or operate legacy ID) of the batch operation.
     */
    batchOperationKey?: BasicStringFilterProperty;
    /**
     * The type of the batch operation.
     */
    operationType?: BatchOperationTypeFilterProperty;
    /**
     * The state of the batch operation.
     */
    state?: BatchOperationStateFilterProperty;
    /**
     * The type of the actor who performed the operation.
     */
    actorType?: AuditLogActorTypeEnum;
    /**
     * The ID of the actor who performed the operation.
     */
    actorId?: StringFilterProperty;
};

/**
 * The batch operation search query result.
 */
export type BatchOperationSearchQueryResult = SearchQueryResponse & {
    /**
     * The matching batch operations.
     */
    items?: Array<BatchOperationResponse>;
};

export type BatchOperationResponse = {
    /**
     * Key or (Operate Legacy ID = UUID) of the batch operation.
     */
    batchOperationKey?: BatchOperationKey;
    state?: BatchOperationStateEnum;
    batchOperationType?: BatchOperationTypeEnum;
    /**
     * The start date of the batch operation.
     */
    startDate?: string;
    /**
     * The end date of the batch operation.
     */
    endDate?: string;
    actorType?: AuditLogActorTypeEnum;
    /**
     * The ID of the actor who performed the operation. Available for batch operations created since 8.9.
     */
    actorId?: string;
    /**
     * The total number of items contained in this batch operation.
     */
    operationsTotalCount?: number;
    /**
     * The number of items which failed during execution of the batch operation. (e.g. because they are rejected by the Zeebe engine).
     */
    operationsFailedCount?: number;
    /**
     * The number of successfully completed tasks.
     */
    operationsCompletedCount?: number;
    /**
     * The errors that occurred per partition during the batch operation.
     */
    errors?: Array<BatchOperationError>;
};

export type BatchOperationError = {
    /**
     * The partition ID where the error occurred.
     */
    partitionId?: number;
    /**
     * The type of the error that occurred during the batch operation.
     */
    type?: 'QUERY_FAILED' | 'RESULT_BUFFER_SIZE_EXCEEDED';
    /**
     * The error message that occurred during the batch operation.
     */
    message?: string;
};

export type BatchOperationItemSearchQuerySortRequest = {
    /**
     * The field to sort by.
     */
    field: 'batchOperationKey' | 'itemKey' | 'processInstanceKey' | 'processedDate' | 'state';
    order?: SortOrderEnum;
};

/**
 * Batch operation item search request.
 */
export type BatchOperationItemSearchQuery = SearchQueryRequest & {
    /**
     * Sort field criteria.
     */
    sort?: Array<BatchOperationItemSearchQuerySortRequest>;
    /**
     * The batch operation item search filters.
     */
    filter?: BatchOperationItemFilter;
};

/**
 * Batch operation item filter request.
 */
export type BatchOperationItemFilter = {
    /**
     * The key (or operate legacy ID) of the batch operation.
     */
    batchOperationKey?: BasicStringFilterProperty;
    /**
     * The key of the item, e.g. a process instance key.
     */
    itemKey?: BasicStringFilterProperty;
    /**
     * The process instance key of the processed item.
     */
    processInstanceKey?: ProcessInstanceKeyFilterProperty;
    /**
     * The state of the batch operation.
     */
    state?: BatchOperationItemStateFilterProperty;
    /**
     * The type of the batch operation.
     */
    operationType?: BatchOperationTypeFilterProperty;
};

export type BatchOperationItemSearchQueryResult = SearchQueryResponse & {
    /**
     * The matching batch operation items.
     */
    items?: Array<BatchOperationItemResponse>;
};

export type BatchOperationItemResponse = {
    operationType?: BatchOperationTypeEnum;
    /**
     * The key (or operate legacy ID) of the batch operation.
     */
    batchOperationKey?: BatchOperationKey;
    /**
     * Key of the item, e.g. a process instance key.
     */
    itemKey?: string;
    /**
     * the process instance key of the processed item.
     */
    processInstanceKey?: ProcessInstanceKey;
    rootProcessInstanceKey?: RootProcessInstanceKey;
    /**
     * State of the item.
     */
    state?: 'ACTIVE' | 'COMPLETED' | 'SKIPPED' | 'CANCELED' | 'FAILED';
    /**
     * the date this item was processed.
     */
    processedDate?: string;
    /**
     * the error message from the engine in case of a failed operation.
     */
    errorMessage?: string;
};

/**
 * The decision instance filter that defines which decision instances should be deleted.
 */
export type DecisionInstanceDeletionBatchOperationRequest = {
    /**
     * The decision instance filter.
     */
    filter: DecisionInstanceFilter;
    operationReference?: OperationReference;
};

/**
 * The process instance filter that defines which process instances should be canceled.
 */
export type ProcessInstanceCancellationBatchOperationRequest = {
    /**
     * The process instance filter.
     */
    filter: ProcessInstanceFilter;
    operationReference?: OperationReference;
};

/**
 * The process instance filter that defines which process instances should have their incidents resolved.
 */
export type ProcessInstanceIncidentResolutionBatchOperationRequest = {
    /**
     * The process instance filter.
     */
    filter: ProcessInstanceFilter;
    operationReference?: OperationReference;
};

/**
 * The process instance filter that defines which process instances should be deleted.
 */
export type ProcessInstanceDeletionBatchOperationRequest = {
    /**
     * The process instance filter.
     */
    filter: ProcessInstanceFilter;
    operationReference?: OperationReference;
};

export type ProcessInstanceMigrationBatchOperationRequest = {
    /**
     * The process instance filter.
     */
    filter: ProcessInstanceFilter;
    /**
     * The migration plan.
     */
    migrationPlan: ProcessInstanceMigrationBatchOperationPlan;
    operationReference?: OperationReference;
};

/**
 * The migration instructions describe how to migrate a process instance from one process definition to another.
 *
 */
export type ProcessInstanceMigrationBatchOperationPlan = {
    /**
     * The target process definition key.
     */
    targetProcessDefinitionKey: ProcessDefinitionKey;
    /**
     * The mapping instructions.
     */
    mappingInstructions: Array<MigrateProcessInstanceMappingInstruction>;
};

/**
 * The process instance filter to define on which process instances tokens should be moved,
 * and new element instances should be activated or terminated.
 *
 */
export type ProcessInstanceModificationBatchOperationRequest = {
    /**
     * The process instance filter.
     */
    filter: ProcessInstanceFilter;
    /**
     * Instructions for moving tokens between elements.
     */
    moveInstructions: Array<ProcessInstanceModificationMoveBatchOperationInstruction>;
    operationReference?: OperationReference;
};

/**
 * Instructions describing a move operation. This instruction will terminate all active
 * element instances at `sourceElementId` and activate a new element instance for each
 * terminated one at `targetElementId`. The new element instances are created in the parent
 * scope of the source element instances.
 *
 */
export type ProcessInstanceModificationMoveBatchOperationInstruction = {
    /**
     * The source element ID.
     */
    sourceElementId: ElementId;
    /**
     * The target element ID.
     */
    targetElementId: ElementId;
};

/**
 * The batch operation item state.
 */
export type BatchOperationItemStateEnum = 'ACTIVE' | 'COMPLETED' | 'CANCELED' | 'FAILED';

/**
 * The batch operation state.
 */
export type BatchOperationStateEnum = 'ACTIVE' | 'CANCELED' | 'COMPLETED' | 'CREATED' | 'FAILED' | 'PARTIALLY_COMPLETED' | 'SUSPENDED';

/**
 * The type of the batch operation.
 */
export type BatchOperationTypeEnum = 'ADD_VARIABLE' | 'CANCEL_PROCESS_INSTANCE' | 'DELETE_DECISION_DEFINITION' | 'DELETE_DECISION_INSTANCE' | 'DELETE_PROCESS_DEFINITION' | 'DELETE_PROCESS_INSTANCE' | 'MIGRATE_PROCESS_INSTANCE' | 'MODIFY_PROCESS_INSTANCE' | 'RESOLVE_INCIDENT' | 'UPDATE_VARIABLE';

/**
 * BatchOperationTypeEnum property with full advanced search capabilities.
 */
export type BatchOperationTypeFilterProperty = BatchOperationTypeExactMatch | AdvancedBatchOperationTypeFilter;

/**
 * Advanced filter
 *
 * Advanced BatchOperationTypeEnum filter.
 */
export type AdvancedBatchOperationTypeFilter = {
    /**
     * Checks for equality with the provided value.
     */
    $eq?: BatchOperationTypeEnum;
    /**
     * Checks for inequality with the provided value.
     */
    $neq?: BatchOperationTypeEnum;
    /**
     * Checks if the current property exists.
     */
    $exists?: boolean;
    /**
     * Checks if the property matches any of the provided values.
     */
    $in?: Array<BatchOperationTypeEnum>;
    $like?: LikeFilter;
};

/**
 * BatchOperationStateEnum property with full advanced search capabilities.
 */
export type BatchOperationStateFilterProperty = BatchOperationStateExactMatch | AdvancedBatchOperationStateFilter;

/**
 * Advanced filter
 *
 * Advanced BatchOperationStateEnum filter.
 */
export type AdvancedBatchOperationStateFilter = {
    /**
     * Checks for equality with the provided value.
     */
    $eq?: BatchOperationStateEnum;
    /**
     * Checks for inequality with the provided value.
     */
    $neq?: BatchOperationStateEnum;
    /**
     * Checks if the current property exists.
     */
    $exists?: boolean;
    /**
     * Checks if the property matches any of the provided values.
     */
    $in?: Array<BatchOperationStateEnum>;
    $like?: LikeFilter;
};

/**
 * BatchOperationItemStateEnum property with full advanced search capabilities.
 */
export type BatchOperationItemStateFilterProperty = BatchOperationItemStateExactMatch | AdvancedBatchOperationItemStateFilter;

/**
 * Advanced filter
 *
 * Advanced BatchOperationItemStateEnum filter.
 */
export type AdvancedBatchOperationItemStateFilter = {
    /**
     * Checks for equality with the provided value.
     */
    $eq?: BatchOperationItemStateEnum;
    /**
     * Checks for inequality with the provided value.
     */
    $neq?: BatchOperationItemStateEnum;
    /**
     * Checks if the current property exists.
     */
    $exists?: boolean;
    /**
     * Checks if the property matches any of the provided values.
     */
    $in?: Array<BatchOperationItemStateEnum>;
    $like?: LikeFilter;
};

export type ClockPinRequest = {
    /**
     * The exact time in epoch milliseconds to which the clock should be pinned.
     */
    timestamp: number;
};

/**
 * The scope of a cluster variable.
 */
export type ClusterVariableScopeEnum = 'GLOBAL' | 'TENANT';

export type CreateClusterVariableRequest = {
    /**
     * The name of the cluster variable. Must be unique within its scope (global or tenant-specific).
     */
    name: string;
    /**
     * The value of the cluster variable. Can be any JSON object or primitive value. Will be serialized as a JSON string in responses.
     */
    value: {
        [key: string]: unknown;
    };
};

export type UpdateClusterVariableRequest = {
    /**
     * The new value of the cluster variable. Can be any JSON object or primitive value. Will be serialized as a JSON string in responses.
     */
    value: {
        [key: string]: unknown;
    };
};

export type ClusterVariableResult = ClusterVariableResultBase & {
    /**
     * Full value of this cluster variable.
     */
    value?: string;
};

/**
 * Cluster variable search response item.
 */
export type ClusterVariableSearchResult = ClusterVariableResultBase & {
    /**
     * Value of this cluster variable. Can be truncated.
     */
    value?: string;
    /**
     * Whether the value is truncated or not.
     */
    isTruncated?: boolean;
};

/**
 * Cluster variable response item.
 */
export type ClusterVariableResultBase = {
    /**
     * The name of the cluster variable. Unique within its scope (global or tenant-specific).
     */
    name: string;
    scope: ClusterVariableScopeEnum;
    /**
     * Only provided if the cluster variable scope is TENANT.
     */
    tenantId?: string;
};

/**
 * Cluster variable search query request.
 */
export type ClusterVariableSearchQueryRequest = SearchQueryRequest & {
    /**
     * Sort field criteria.
     */
    sort?: Array<ClusterVariableSearchQuerySortRequest>;
    /**
     * The cluster variable search filters.
     */
    filter?: ClusterVariableSearchQueryFilterRequest;
};

export type ClusterVariableSearchQuerySortRequest = {
    /**
     * The field to sort by.
     */
    field: 'name' | 'value' | 'tenantId' | 'scope';
    order?: SortOrderEnum;
};

/**
 * Cluster variable filter request.
 */
export type ClusterVariableSearchQueryFilterRequest = {
    /**
     * Name of the cluster variable.
     */
    name?: StringFilterProperty;
    /**
     * The value of the cluster variable.
     */
    value?: StringFilterProperty;
    /**
     * The scope filter for cluster variables.
     */
    scope?: ClusterVariableScopeFilterProperty;
    /**
     * Tenant ID of this variable.
     */
    tenantId?: StringFilterProperty;
    /**
     * Filter cluster variables by truncation status of their stored values. When true, returns only variables whose stored values are truncated (i.e., the value exceeds the storage size limit and is truncated in storage). When false, returns only variables with non-truncated stored values. This filter is based on the underlying storage characteristic, not the response format.
     *
     */
    isTruncated?: boolean;
};

/**
 * ClusterVariableScopeEnum property with full advanced search capabilities.
 */
export type ClusterVariableScopeFilterProperty = ClusterVariableScopeExactMatch | AdvancedClusterVariableScopeFilter;

/**
 * Advanced filter
 *
 * Advanced ClusterVariableScopeEnum filter.
 */
export type AdvancedClusterVariableScopeFilter = {
    /**
     * Checks for equality with the provided value.
     */
    $eq?: ClusterVariableScopeEnum;
    /**
     * Checks for inequality with the provided value.
     */
    $neq?: ClusterVariableScopeEnum;
    /**
     * Checks if the current property exists.
     */
    $exists?: boolean;
    /**
     * Checks if the property matches any of the provided values.
     */
    $in?: Array<ClusterVariableScopeEnum>;
    $like?: LikeFilter;
};

/**
 * Cluster variable search query response.
 */
export type ClusterVariableSearchQueryResult = SearchQueryResponse & {
    /**
     * The matching cluster variables.
     */
    items?: Array<ClusterVariableSearchResult>;
};

/**
 * The response of a topology request.
 */
export type TopologyResponse = {
    /**
     * A list of brokers that are part of this cluster.
     */
    brokers: Array<BrokerInfo>;
    /**
     * The cluster Id.
     */
    clusterId?: string | null;
    /**
     * The number of brokers in the cluster.
     */
    clusterSize: number;
    /**
     * The number of partitions are spread across the cluster.
     */
    partitionsCount: number;
    /**
     * The configured replication factor for this cluster.
     */
    replicationFactor: number;
    /**
     * The version of the Zeebe Gateway.
     */
    gatewayVersion: string;
    /**
     * ID of the last completed change
     */
    lastCompletedChangeId: string;
};

/**
 * Provides information on a broker node.
 */
export type BrokerInfo = {
    /**
     * The unique (within a cluster) node ID for the broker.
     */
    nodeId: number;
    /**
     * The hostname for reaching the broker.
     */
    host: string;
    /**
     * The port for reaching the broker.
     */
    port: number;
    /**
     * A list of partitions managed or replicated on this broker.
     */
    partitions: Array<Partition>;
    /**
     * The broker version.
     */
    version: string;
};

/**
 * Provides information on a partition within a broker node.
 */
export type Partition = {
    /**
     * The unique ID of this partition.
     */
    partitionId: number;
    /**
     * Describes the Raft role of the broker for a given partition.
     */
    role: 'leader' | 'follower' | 'inactive';
    /**
     * Describes the current health of the partition.
     */
    health: 'healthy' | 'unhealthy' | 'dead';
};

export type ConditionalEvaluationInstruction = {
    /**
     * Used to evaluate root-level conditional start events for a tenant with the given ID.
     * This will only evaluate root-level conditional start events of process definitions which belong to the tenant.
     *
     */
    tenantId?: TenantId;
    /**
     * Used to evaluate root-level conditional start events of the process definition with the given key.
     *
     */
    processDefinitionKey?: ProcessDefinitionKey;
    /**
     * JSON object representing the variables to use for evaluation of the conditions and to pass to the process instances that have been triggered.
     *
     */
    variables: {
        [key: string]: unknown;
    };
};

export type EvaluateConditionalResult = {
    /**
     * The unique key of the conditional evaluation operation.
     */
    conditionalEvaluationKey: ConditionalEvaluationKey;
    /**
     * The tenant ID of the conditional evaluation operation.
     */
    tenantId: TenantId;
    /**
     * List of process instances created. If no root-level conditional start events evaluated to true, the list will be empty.
     */
    processInstances: Array<ProcessInstanceReference>;
};

/**
 * System-generated key for a conditional evaluation.
 */
export type ConditionalEvaluationKey = CamundaKey<'ConditionalEvaluationKey'>;

export type ProcessInstanceReference = {
    /**
     * The key of the process definition.
     */
    processDefinitionKey?: ProcessDefinitionKey;
    /**
     * The key of the created process instance.
     */
    processInstanceKey?: ProcessInstanceKey;
};

/**
 * The start cursor in a search query result set.
 */
export type StartCursor = CamundaKey<'StartCursor'>;

/**
 * The end cursor in a search query result set.
 */
export type EndCursor = CamundaKey<'EndCursor'>;

export type DecisionDefinitionSearchQuerySortRequest = {
    /**
     * The field to sort by.
     */
    field: 'decisionDefinitionKey' | 'decisionDefinitionId' | 'name' | 'version' | 'decisionRequirementsId' | 'decisionRequirementsKey' | 'decisionRequirementsName' | 'decisionRequirementsVersion' | 'tenantId';
    order?: SortOrderEnum;
};

export type DecisionDefinitionSearchQuery = SearchQueryRequest & {
    /**
     * Sort field criteria.
     */
    sort?: Array<DecisionDefinitionSearchQuerySortRequest>;
    /**
     * The decision definition search filters.
     */
    filter?: DecisionDefinitionFilter;
};

/**
 * Decision definition search filter.
 */
export type DecisionDefinitionFilter = {
    /**
     * The DMN ID of the decision definition.
     */
    decisionDefinitionId?: DecisionDefinitionId;
    /**
     * The DMN name of the decision definition.
     */
    name?: string;
    /**
     * Whether to only return the latest version of each decision definition.
     * When using this filter, pagination functionality is limited, you can only paginate forward using `after` and `limit`.
     * The response contains no `startCursor` in the `page`, and requests ignore the `from` and `before` in the `page`.
     *
     */
    isLatestVersion?: boolean;
    /**
     * The assigned version of the decision definition.
     */
    version?: number;
    /**
     * the DMN ID of the decision requirements graph that the decision definition is part of.
     */
    decisionRequirementsId?: string;
    /**
     * The tenant ID of the decision definition.
     */
    tenantId?: TenantId;
    /**
     * The assigned key, which acts as a unique identifier for this decision definition.
     */
    decisionDefinitionKey?: DecisionDefinitionKey;
    /**
     * The assigned key of the decision requirements graph that the decision definition is part of.
     */
    decisionRequirementsKey?: DecisionRequirementsKey;
    /**
     * The DMN name of the decision requirements that the decision definition is part of.
     */
    decisionRequirementsName?: string;
    /**
     * The assigned version of the decision requirements that the decision definition is part of.
     */
    decisionRequirementsVersion?: number;
};

export type DecisionDefinitionSearchQueryResult = SearchQueryResponse & {
    /**
     * The matching decision definitions.
     */
    items?: Array<DecisionDefinitionResult>;
};

export type DecisionDefinitionResult = {
    /**
     * The DMN ID of the decision definition.
     */
    decisionDefinitionId?: DecisionDefinitionId;
    /**
     * The DMN name of the decision definition.
     */
    name?: string;
    /**
     * The assigned version of the decision definition.
     */
    version?: number;
    /**
     * the DMN ID of the decision requirements graph that the decision definition is part of.
     */
    decisionRequirementsId?: string;
    /**
     * The tenant ID of the decision definition.
     */
    tenantId?: TenantId;
    /**
     * The assigned key, which acts as a unique identifier for this decision definition.
     */
    decisionDefinitionKey?: DecisionDefinitionKey;
    /**
     * The assigned key of the decision requirements graph that the decision definition is part of.
     */
    decisionRequirementsKey?: DecisionRequirementsKey;
    /**
     * The DMN name of the decision requirements that the decision definition is part of.
     */
    decisionRequirementsName?: string;
    /**
     * The assigned version of the decision requirements that the decision definition is part of.
     */
    decisionRequirementsVersion?: number;
};

export type DecisionEvaluationInstruction = DecisionEvaluationById | DecisionEvaluationByKey;

/**
 * Decision evaluation by ID
 */
export type DecisionEvaluationById = {
    /**
     * The ID of the decision to be evaluated.
     * When using the decision ID, the latest
     * deployed version of the decision is used.
     *
     */
    decisionDefinitionId: DecisionDefinitionId;
    /**
     * The message variables as JSON document.
     */
    variables?: {
        [key: string]: unknown;
    };
    /**
     * The tenant ID of the decision.
     */
    tenantId?: TenantId;
};

/**
 * Decision evaluation by key
 */
export type DecisionEvaluationByKey = {
    decisionDefinitionKey: DecisionDefinitionKey;
    /**
     * The message variables as JSON document.
     */
    variables?: {
        [key: string]: unknown;
    };
    /**
     * The tenant ID of the decision.
     */
    tenantId?: TenantId;
};

export type EvaluateDecisionResult = {
    /**
     * The ID of the decision which was evaluated.
     */
    decisionDefinitionId: DecisionDefinitionId;
    /**
     * The name of the decision which was evaluated.
     */
    decisionDefinitionName: string;
    /**
     * The version of the decision which was evaluated.
     */
    decisionDefinitionVersion: number;
    /**
     * The ID of the decision requirements graph that the decision which was evaluated is part of.
     */
    decisionRequirementsId: string;
    /**
     * JSON document that will instantiate the result of the decision which was evaluated.
     *
     */
    output: string;
    /**
     * The ID of the decision which failed during evaluation.
     */
    failedDecisionDefinitionId: DecisionDefinitionId;
    /**
     * Message describing why the decision which was evaluated failed.
     */
    failureMessage: string;
    /**
     * The tenant ID of the evaluated decision.
     */
    tenantId: TenantId;
    /**
     * The unique key identifying the decision which was evaluated.
     */
    decisionDefinitionKey: DecisionDefinitionKey;
    /**
     * The unique key identifying the decision requirements graph that the decision which was evaluated is part of.
     */
    decisionRequirementsKey: DecisionRequirementsKey;
    /**
     * Deprecated, please refer to `decisionEvaluationKey`.
     *
     * @deprecated
     */
    decisionInstanceKey?: DecisionInstanceKey;
    /**
     * The unique key identifying this decision evaluation.
     */
    decisionEvaluationKey: DecisionEvaluationKey;
    /**
     * Decisions that were evaluated within the requested decision evaluation.
     */
    evaluatedDecisions: Array<EvaluatedDecisionResult>;
};

/**
 * A decision that was evaluated.
 */
export type EvaluatedDecisionResult = {
    /**
     * The ID of the decision which was evaluated.
     */
    decisionDefinitionId?: DecisionDefinitionId;
    /**
     * The name of the decision which was evaluated.
     */
    decisionDefinitionName?: string;
    /**
     * The version of the decision which was evaluated.
     */
    decisionDefinitionVersion?: number;
    /**
     * The type of the decision which was evaluated.
     */
    decisionDefinitionType?: string;
    /**
     * JSON document that will instantiate the result of the decision which was evaluated.
     *
     */
    output?: string;
    /**
     * The tenant ID of the evaluated decision.
     */
    tenantId?: TenantId;
    /**
     * The decision rules that matched within this decision evaluation.
     */
    matchedRules?: Array<MatchedDecisionRuleItem>;
    /**
     * The decision inputs that were evaluated within this decision evaluation.
     */
    evaluatedInputs?: Array<EvaluatedDecisionInputItem>;
    /**
     * The unique key identifying the decision which was evaluate.
     */
    decisionDefinitionKey?: DecisionDefinitionKey;
    /**
     * The unique key identifying this decision evaluation instance.
     */
    decisionEvaluationInstanceKey?: DecisionEvaluationInstanceKey;
};

export type DecisionInstanceSearchQuerySortRequest = {
    /**
     * The field to sort by.
     */
    field: 'decisionDefinitionId' | 'decisionDefinitionKey' | 'decisionDefinitionName' | 'decisionDefinitionType' | 'decisionDefinitionVersion' | 'decisionEvaluationInstanceKey' | 'decisionEvaluationKey' | 'elementInstanceKey' | 'evaluationDate' | 'evaluationFailure' | 'processDefinitionKey' | 'processInstanceKey' | 'rootDecisionDefinitionKey' | 'state' | 'tenantId';
    order?: SortOrderEnum;
};

export type DecisionInstanceSearchQuery = SearchQueryRequest & {
    /**
     * Sort field criteria.
     */
    sort?: Array<DecisionInstanceSearchQuerySortRequest>;
    /**
     * The decision instance search filters.
     */
    filter?: DecisionInstanceFilter;
};

/**
 * Decision instance search filter.
 */
export type DecisionInstanceFilter = {
    /**
     * The key of the decision evaluation instance.
     */
    decisionEvaluationInstanceKey?: DecisionEvaluationInstanceKeyFilterProperty;
    /**
     * The state of the decision instance.
     */
    state?: DecisionInstanceStateFilterProperty;
    /**
     * The evaluation failure of the decision instance.
     */
    evaluationFailure?: string;
    /**
     * The evaluation date of the decision instance.
     */
    evaluationDate?: DateTimeFilterProperty;
    /**
     * The ID of the DMN decision.
     */
    decisionDefinitionId?: DecisionDefinitionId;
    /**
     * The name of the DMN decision.
     */
    decisionDefinitionName?: string;
    /**
     * The version of the decision.
     */
    decisionDefinitionVersion?: number;
    decisionDefinitionType?: DecisionDefinitionTypeEnum;
    /**
     * The tenant ID of the decision instance.
     */
    tenantId?: TenantId;
    /**
     * The key of the parent decision evaluation. Note that this is not the identifier of an individual decision instance; the `decisionEvaluationInstanceKey` is the identifier for a decision instance.
     *
     */
    decisionEvaluationKey?: DecisionEvaluationKey;
    /**
     * The key of the process definition.
     */
    processDefinitionKey?: ProcessDefinitionKey;
    /**
     * The key of the process instance.
     */
    processInstanceKey?: ProcessInstanceKey;
    /**
     * The key of the decision.
     */
    decisionDefinitionKey?: DecisionDefinitionKeyFilterProperty;
    /**
     * The key of the element instance this decision instance is linked to.
     */
    elementInstanceKey?: ElementInstanceKeyFilterProperty;
    /**
     * The key of the root decision definition.
     */
    rootDecisionDefinitionKey?: DecisionDefinitionKeyFilterProperty;
    /**
     * The key of the decision requirements definition.
     */
    decisionRequirementsKey?: DecisionRequirementsKeyFilterProperty;
};

export type DeleteDecisionInstanceRequest = {
    operationReference?: OperationReference;
} | null;

export type DecisionInstanceSearchQueryResult = SearchQueryResponse & {
    /**
     * The matching decision instances.
     */
    items?: Array<DecisionInstanceResult>;
};

export type DecisionInstanceResult = {
    decisionEvaluationInstanceKey?: DecisionEvaluationInstanceKey;
    state?: DecisionInstanceStateEnum;
    /**
     * The evaluation date of the decision instance.
     */
    evaluationDate?: string;
    /**
     * The evaluation failure of the decision instance.
     */
    evaluationFailure?: string;
    /**
     * The ID of the DMN decision.
     */
    decisionDefinitionId?: DecisionDefinitionId;
    /**
     * The name of the DMN decision.
     */
    decisionDefinitionName?: string;
    /**
     * The version of the decision.
     */
    decisionDefinitionVersion?: number;
    decisionDefinitionType?: DecisionDefinitionTypeEnum;
    /**
     * The result of the decision instance.
     */
    result?: string;
    /**
     * The tenant ID of the decision instance.
     */
    tenantId?: TenantId;
    /**
     * The key of the decision evaluation where this instance was created.
     */
    decisionEvaluationKey?: DecisionEvaluationKey;
    /**
     * The key of the process definition.
     */
    processDefinitionKey?: ProcessDefinitionKey;
    /**
     * The key of the process instance.
     */
    processInstanceKey?: ProcessInstanceKey;
    rootProcessInstanceKey?: RootProcessInstanceKey;
    /**
     * The key of the decision.
     */
    decisionDefinitionKey?: DecisionDefinitionKey;
    /**
     * The key of the element instance this decision instance is linked to.
     */
    elementInstanceKey?: ElementInstanceKey;
    /**
     * The key of the root decision definition.
     */
    rootDecisionDefinitionKey?: DecisionDefinitionKey;
};

export type DecisionInstanceGetQueryResult = DecisionInstanceResult & {
    /**
     * The evaluated inputs of the decision instance.
     *
     */
    evaluatedInputs?: Array<EvaluatedDecisionInputItem>;
    /**
     * The matched rules of the decision instance.
     *
     */
    matchedRules?: Array<MatchedDecisionRuleItem>;
};

/**
 * A decision input that was evaluated within this decision evaluation.
 */
export type EvaluatedDecisionInputItem = {
    inputId?: string;
    inputName?: string;
    inputValue?: string;
};

/**
 * The evaluated decision outputs.
 */
export type EvaluatedDecisionOutputItem = {
    outputId?: string;
    outputName?: string;
    outputValue?: string;
    ruleId?: string;
    ruleIndex?: number;
};

/**
 * A decision rule that matched within this decision evaluation.
 */
export type MatchedDecisionRuleItem = {
    /**
     * The ID of the matched rule.
     */
    ruleId?: string;
    /**
     * The index of the matched rule.
     */
    ruleIndex?: number;
    /**
     * The evaluated decision outputs.
     */
    evaluatedOutputs?: Array<EvaluatedDecisionOutputItem>;
};

/**
 * The type of the decision.
 */
export type DecisionDefinitionTypeEnum = 'DECISION_TABLE' | 'LITERAL_EXPRESSION' | 'UNKNOWN';

/**
 * The state of the decision instance.
 */
export type DecisionInstanceStateEnum = 'EVALUATED' | 'FAILED' | 'UNSPECIFIED';

/**
 * Advanced filter
 *
 * Advanced DecisionInstanceStateEnum filter.
 */
export type AdvancedDecisionInstanceStateFilter = {
    /**
     * Checks for equality with the provided value.
     */
    $eq?: DecisionInstanceStateEnum;
    /**
     * Checks for inequality with the provided value.
     */
    $neq?: DecisionInstanceStateEnum;
    /**
     * Checks if the current property exists.
     */
    $exists?: boolean;
    /**
     * Checks if the property matches any of the provided values.
     */
    $in?: Array<DecisionInstanceStateEnum>;
    /**
     * Checks if the property matches none of the provided values.
     */
    $notIn?: Array<DecisionInstanceStateEnum>;
    $like?: LikeFilter;
};

/**
 * DecisionInstanceStateEnum property with full advanced search capabilities.
 */
export type DecisionInstanceStateFilterProperty = DecisionInstanceStateExactMatch | AdvancedDecisionInstanceStateFilter;

export type DecisionRequirementsSearchQuerySortRequest = {
    /**
     * The field to sort by.
     */
    field: 'decisionRequirementsKey' | 'decisionRequirementsName' | 'version' | 'decisionRequirementsId' | 'tenantId';
    order?: SortOrderEnum;
};

export type DecisionRequirementsSearchQuery = SearchQueryRequest & {
    /**
     * Sort field criteria.
     */
    sort?: Array<DecisionRequirementsSearchQuerySortRequest>;
    /**
     * The decision definition search filters.
     */
    filter?: DecisionRequirementsFilter;
};

/**
 * Decision requirements search filter.
 */
export type DecisionRequirementsFilter = {
    /**
     * The DMN name of the decision requirements.
     */
    decisionRequirementsName?: string;
    /**
     * the DMN ID of the decision requirements.
     */
    decisionRequirementsId?: string;
    decisionRequirementsKey?: DecisionRequirementsKey;
    /**
     * The assigned version of the decision requirements.
     */
    version?: number;
    /**
     * The tenant ID of the decision requirements.
     */
    tenantId?: TenantId;
    /**
     * The name of the resource from which the decision requirements were parsed
     */
    resourceName?: string;
};

export type DecisionRequirementsSearchQueryResult = SearchQueryResponse & {
    /**
     * The matching decision requirements.
     */
    items?: Array<DecisionRequirementsResult>;
};

export type DecisionRequirementsResult = {
    /**
     * The DMN name of the decision requirements.
     */
    decisionRequirementsName?: string;
    /**
     * The assigned version of the decision requirements.
     */
    version?: number;
    /**
     * The DMN ID of the decision requirements.
     */
    decisionRequirementsId?: string;
    /**
     * The name of the resource from which this decision requirements was parsed.
     */
    resourceName?: string;
    /**
     * The tenant ID of the decision requirements.
     */
    tenantId?: TenantId;
    /**
     * The assigned key, which acts as a unique identifier for this decision requirements.
     */
    decisionRequirementsKey?: DecisionRequirementsKey;
};

export type DeploymentResult = {
    /**
     * The unique key identifying the deployment.
     */
    deploymentKey: DeploymentKey;
    /**
     * The tenant ID associated with the deployment.
     */
    tenantId: TenantId;
    /**
     * Items deployed by the request.
     */
    deployments: Array<DeploymentMetadataResult>;
};

export type DeploymentMetadataResult = {
    processDefinition?: DeploymentProcessResult;
    decisionDefinition?: DeploymentDecisionResult;
    decisionRequirements?: DeploymentDecisionRequirementsResult;
    form?: DeploymentFormResult;
    resource?: DeploymentResourceResult;
};

/**
 * A deployed process.
 */
export type DeploymentProcessResult = {
    /**
     * The bpmn process ID, as parsed during deployment, together with the version forms a
     * unique identifier for a specific process definition.
     *
     */
    processDefinitionId: ProcessDefinitionId;
    /**
     * The assigned process version.
     */
    processDefinitionVersion: number;
    /**
     * The resource name from which this process was parsed.
     */
    resourceName: string;
    /**
     * The tenant ID of the deployed process.
     */
    tenantId: TenantId;
    /**
     * The assigned key, which acts as a unique identifier for this process.
     */
    processDefinitionKey: ProcessDefinitionKey;
};

/**
 * A deployed decision.
 */
export type DeploymentDecisionResult = {
    /**
     * The dmn decision ID, as parsed during deployment, together with the version forms a
     * unique identifier for a specific decision.
     *
     */
    decisionDefinitionId?: DecisionDefinitionId;
    /**
     * The assigned decision version.
     */
    version?: number;
    /**
     * The DMN name of the decision, as parsed during deployment.
     */
    name?: string;
    /**
     * The tenant ID of the deployed decision.
     */
    tenantId?: TenantId;
    /**
     * The dmn ID of the decision requirements graph that this decision is part of, as parsed during deployment.
     *
     */
    decisionRequirementsId?: string;
    /**
     * The assigned decision key, which acts as a unique identifier for this decision.
     *
     */
    decisionDefinitionKey?: DecisionDefinitionKey;
    /**
     * The assigned key of the decision requirements graph that this decision is part of.
     *
     */
    decisionRequirementsKey?: DecisionRequirementsKey;
};

/**
 * Deployed decision requirements.
 */
export type DeploymentDecisionRequirementsResult = {
    decisionRequirementsId?: string;
    decisionRequirementsName?: string;
    version?: number;
    resourceName?: string;
    /**
     * The tenant ID of the deployed decision requirements.
     */
    tenantId?: TenantId;
    /**
     * The assigned decision requirements key, which acts as a unique identifier for this decision requirements.
     *
     */
    decisionRequirementsKey?: DecisionRequirementsKey;
};

/**
 * A deployed form.
 */
export type DeploymentFormResult = {
    /**
     * The form ID, as parsed during deployment, together with the version forms a
     * unique identifier for a specific form.
     *
     */
    formId?: FormId;
    version?: number;
    resourceName?: string;
    tenantId?: TenantId;
    /**
     * The assigned key, which acts as a unique identifier for this form.
     */
    formKey?: FormKey;
};

/**
 * A deployed Resource.
 */
export type DeploymentResourceResult = {
    resourceId?: string;
    resourceName?: string;
    version?: number;
    tenantId?: TenantId;
    /**
     * The assigned key, which acts as a unique identifier for this Resource.
     */
    resourceKey?: ResourceKey;
};

export type DeleteResourceRequest = {
    operationReference?: OperationReference;
    /**
     * Indicates if the historic data of a process resource should be deleted via a
     * batch operation asynchronously.
     *
     * This flag is only effective for process resources. For other resource types
     * (decisions, forms, generic resources), this flag is ignored and no history
     * will be deleted. In those cases, the `batchOperation` field in the response
     * will not be populated.
     *
     */
    deleteHistory?: boolean;
} | null;

export type DeleteResourceResponse = {
    /**
     * The system-assigned key for this resource, requested to be deleted.
     */
    resourceKey: ResourceKey;
    /**
     * The batch operation created for asynchronously deleting the historic data.
     *
     * This field is only populated when the request `deleteHistory` is set to `true` and the resource
     * is a process definition. For other resource types (decisions, forms, generic resources),
     * this field will not be present in the response.
     *
     */
    batchOperation?: BatchOperationCreatedResult;
};

export type ResourceResult = {
    /**
     * The resource name from which this resource was parsed.
     */
    resourceName?: string;
    /**
     * The assigned resource version.
     */
    version?: number;
    /**
     * The version tag of this resource.
     */
    versionTag?: string;
    /**
     * The resource ID of this resource.
     */
    resourceId?: string;
    /**
     * The tenant ID of this resource.
     */
    tenantId?: TenantId;
    /**
     * The unique key of this resource.
     */
    resourceKey?: ResourceKey;
};

/**
 * Key for a deployment.
 */
export type DeploymentKey = CamundaKey<'DeploymentKey'>;

/**
 * The system-assigned key for this resource.
 */
export type ResourceKey = ProcessDefinitionKey | DecisionRequirementsKey | FormKey | DecisionDefinitionKey;

/**
 * DeploymentKey property with full advanced search capabilities.
 */
export type DeploymentKeyFilterProperty = DeploymentKeyExactMatch | AdvancedDeploymentKeyFilter;

/**
 * Advanced filter
 *
 * Advanced DeploymentKey filter.
 */
export type AdvancedDeploymentKeyFilter = {
    /**
     * Checks for equality with the provided value.
     */
    $eq?: DeploymentKey;
    /**
     * Checks for inequality with the provided value.
     */
    $neq?: DeploymentKey;
    /**
     * Checks if the current property exists.
     */
    $exists?: boolean;
    /**
     * Checks if the property matches any of the provided values.
     */
    $in?: Array<DeploymentKey>;
    /**
     * Checks if the property matches none of the provided values.
     */
    $notIn?: Array<DeploymentKey>;
};

/**
 * ResourceKey property with full advanced search capabilities.
 */
export type ResourceKeyFilterProperty = ResourceKeyExactMatch | AdvancedResourceKeyFilter;

/**
 * Advanced filter
 *
 * Advanced ResourceKey filter.
 */
export type AdvancedResourceKeyFilter = {
    /**
     * Checks for equality with the provided value.
     */
    $eq?: ResourceKey;
    /**
     * Checks for inequality with the provided value.
     */
    $neq?: ResourceKey;
    /**
     * Checks if the current property exists.
     */
    $exists?: boolean;
    /**
     * Checks if the property matches any of the provided values.
     */
    $in?: Array<ResourceKey>;
    /**
     * Checks if the property matches none of the provided values.
     */
    $notIn?: Array<ResourceKey>;
};

export type DocumentReference = {
    /**
     * Document discriminator. Always set to "camunda".
     */
    'camunda.document.type'?: 'camunda';
    /**
     * The ID of the document store.
     */
    storeId?: string;
    /**
     * The ID of the document.
     */
    documentId?: DocumentId;
    /**
     * The hash of the document.
     */
    contentHash?: string;
    metadata?: DocumentMetadata;
};

export type DocumentCreationFailureDetail = {
    /**
     * The name of the file that failed to upload.
     */
    fileName?: string;
    /**
     * The HTTP status code of the failure.
     */
    status?: number;
    /**
     * A short, human-readable summary of the problem type.
     */
    title?: string;
    /**
     * A human-readable explanation specific to this occurrence of the problem.
     */
    detail?: string;
};

export type DocumentCreationBatchResponse = {
    /**
     * Documents that were successfully created.
     */
    failedDocuments?: Array<DocumentCreationFailureDetail>;
    /**
     * Documents that failed creation.
     */
    createdDocuments?: Array<DocumentReference>;
};

/**
 * Information about the document.
 */
export type DocumentMetadata = {
    /**
     * The content type of the document.
     */
    contentType?: string;
    /**
     * The name of the file.
     */
    fileName?: string;
    /**
     * The date and time when the document expires.
     */
    expiresAt?: string;
    /**
     * The size of the document in bytes.
     */
    size?: number;
    /**
     * The ID of the process definition that created the document.
     */
    processDefinitionId?: ProcessDefinitionId;
    /**
     * The key of the process instance that created the document.
     */
    processInstanceKey?: ProcessInstanceKey;
    /**
     * Custom properties of the document.
     */
    customProperties?: {
        [key: string]: unknown;
    };
};

export type DocumentLinkRequest = {
    /**
     * The time-to-live of the document link in ms.
     */
    timeToLive?: number;
};

export type DocumentLink = {
    /**
     * The link to the document.
     */
    url?: string;
    /**
     * The date and time when the link expires.
     */
    expiresAt?: string;
};

/**
 * Document Id that uniquely identifies a document.
 */
export type DocumentId = CamundaKey<'DocumentId'>;

export type ElementInstanceSearchQuerySortRequest = {
    /**
     * The field to sort by.
     */
    field: 'elementInstanceKey' | 'processInstanceKey' | 'processDefinitionKey' | 'processDefinitionId' | 'startDate' | 'endDate' | 'elementId' | 'elementName' | 'type' | 'state' | 'incidentKey' | 'tenantId';
    order?: SortOrderEnum;
};

/**
 * Element instance search request.
 */
export type ElementInstanceSearchQuery = SearchQueryRequest & {
    /**
     * Sort field criteria.
     */
    sort?: Array<ElementInstanceSearchQuerySortRequest>;
    /**
     * The element instance search filters.
     */
    filter?: ElementInstanceFilter;
};

/**
 * Element instance filter.
 */
export type ElementInstanceFilter = {
    /**
     * The process definition ID associated to this element instance.
     */
    processDefinitionId?: ProcessDefinitionId;
    /**
     * State of element instance as defined set of values.
     */
    state?: ElementInstanceStateFilterProperty;
    /**
     * Type of element as defined set of values.
     */
    type?: 'UNSPECIFIED' | 'PROCESS' | 'SUB_PROCESS' | 'EVENT_SUB_PROCESS' | 'AD_HOC_SUB_PROCESS' | 'AD_HOC_SUB_PROCESS_INNER_INSTANCE' | 'START_EVENT' | 'INTERMEDIATE_CATCH_EVENT' | 'INTERMEDIATE_THROW_EVENT' | 'BOUNDARY_EVENT' | 'END_EVENT' | 'SERVICE_TASK' | 'RECEIVE_TASK' | 'USER_TASK' | 'MANUAL_TASK' | 'TASK' | 'EXCLUSIVE_GATEWAY' | 'INCLUSIVE_GATEWAY' | 'PARALLEL_GATEWAY' | 'EVENT_BASED_GATEWAY' | 'SEQUENCE_FLOW' | 'MULTI_INSTANCE_BODY' | 'CALL_ACTIVITY' | 'BUSINESS_RULE_TASK' | 'SCRIPT_TASK' | 'SEND_TASK' | 'UNKNOWN';
    /**
     * The element ID for this element instance.
     */
    elementId?: ElementId;
    /**
     * The element name. This only works for data created with 8.8 and onwards. Instances from prior versions don't contain this data and cannot be found.
     *
     */
    elementName?: string;
    /**
     * Shows whether this element instance has an incident related to.
     */
    hasIncident?: boolean;
    tenantId?: TenantId;
    /**
     * The assigned key, which acts as a unique identifier for this element instance.
     */
    elementInstanceKey?: ElementInstanceKey;
    /**
     * The process instance key associated to this element instance.
     */
    processInstanceKey?: ProcessInstanceKey;
    /**
     * The process definition key associated to this element instance.
     */
    processDefinitionKey?: ProcessDefinitionKey;
    /**
     * The key of incident if field incident is true.
     */
    incidentKey?: IncidentKey;
    /**
     * The start date of this element instance.
     */
    startDate?: DateTimeFilterProperty;
    /**
     * The end date of this element instance.
     */
    endDate?: DateTimeFilterProperty;
    /**
     * The scope key of this element instance. If provided with a process instance key it will return element instances that are immediate children of the process instance. If provided with an element instance key it will return element instances that are immediate children of the element instance.
     *
     */
    elementInstanceScopeKey?: ElementInstanceKey | ProcessInstanceKey;
};

/**
 * ElementInstanceStateEnum property with full advanced search capabilities.
 */
export type ElementInstanceStateFilterProperty = ElementInstanceStateExactMatch | AdvancedElementInstanceStateFilter;

/**
 * Advanced filter
 *
 * Advanced ElementInstanceStateEnum filter.
 */
export type AdvancedElementInstanceStateFilter = {
    /**
     * Checks for equality with the provided value.
     */
    $eq?: ElementInstanceStateEnum;
    /**
     * Checks for inequality with the provided value.
     */
    $neq?: ElementInstanceStateEnum;
    /**
     * Checks if the current property exists.
     */
    $exists?: boolean;
    /**
     * Checks if the property matches any of the provided values.
     */
    $in?: Array<ElementInstanceStateEnum>;
    $like?: LikeFilter;
};

export type ElementInstanceSearchQueryResult = SearchQueryResponse & {
    /**
     * The matching element instances.
     */
    items?: Array<ElementInstanceResult>;
};

export type ElementInstanceResult = {
    /**
     * The process definition ID associated to this element instance.
     */
    processDefinitionId: ProcessDefinitionId;
    /**
     * Date when element instance started.
     */
    startDate: string;
    /**
     * Date when element instance finished.
     */
    endDate?: string;
    /**
     * The element ID for this element instance.
     */
    elementId: ElementId;
    /**
     * The element name for this element instance.
     */
    elementName: string;
    /**
     * Type of element as defined set of values.
     */
    type: 'UNSPECIFIED' | 'PROCESS' | 'SUB_PROCESS' | 'EVENT_SUB_PROCESS' | 'AD_HOC_SUB_PROCESS' | 'AD_HOC_SUB_PROCESS_INNER_INSTANCE' | 'START_EVENT' | 'INTERMEDIATE_CATCH_EVENT' | 'INTERMEDIATE_THROW_EVENT' | 'BOUNDARY_EVENT' | 'END_EVENT' | 'SERVICE_TASK' | 'RECEIVE_TASK' | 'USER_TASK' | 'MANUAL_TASK' | 'TASK' | 'EXCLUSIVE_GATEWAY' | 'INCLUSIVE_GATEWAY' | 'PARALLEL_GATEWAY' | 'EVENT_BASED_GATEWAY' | 'SEQUENCE_FLOW' | 'MULTI_INSTANCE_BODY' | 'CALL_ACTIVITY' | 'BUSINESS_RULE_TASK' | 'SCRIPT_TASK' | 'SEND_TASK' | 'UNKNOWN';
    /**
     * State of element instance as defined set of values.
     */
    state: ElementInstanceStateEnum;
    /**
     * Shows whether this element instance has an incident. If true also an incidentKey is provided.
     */
    hasIncident: boolean;
    /**
     * The tenant ID of the incident.
     */
    tenantId: TenantId;
    /**
     * The assigned key, which acts as a unique identifier for this element instance.
     */
    elementInstanceKey: ElementInstanceKey;
    /**
     * The process instance key associated to this element instance.
     */
    processInstanceKey: ProcessInstanceKey;
    rootProcessInstanceKey?: RootProcessInstanceKey;
    /**
     * The process definition key associated to this element instance.
     */
    processDefinitionKey: ProcessDefinitionKey;
    /**
     * Incident key associated with this element instance.
     */
    incidentKey?: IncidentKey;
};

/**
 * Element states
 */
export type ElementInstanceStateEnum = 'ACTIVE' | 'COMPLETED' | 'TERMINATED';

export type AdHocSubProcessActivateActivitiesInstruction = {
    /**
     * Activities to activate.
     */
    elements: Array<AdHocSubProcessActivateActivityReference>;
    /**
     * Whether to cancel remaining instances of the ad-hoc sub-process.
     */
    cancelRemainingInstances?: boolean;
};

export type AdHocSubProcessActivateActivityReference = {
    /**
     * The ID of the element that should be activated.
     */
    elementId: ElementId;
    /**
     * Variables to be set when activating the element.
     */
    variables?: {
        [key: string]: unknown;
    };
};

export type ExpressionEvaluationRequest = {
    /**
     * The expression to evaluate (e.g., "=x + y")
     */
    expression: string;
    /**
     * Required when the expression references tenant-scoped cluster variables
     */
    tenantId?: string;
};

export type ExpressionEvaluationResult = {
    /**
     * The evaluated expression
     */
    expression: string;
    /**
     * The result value. Its type can vary.
     */
    result: unknown;
    /**
     * List of warnings generated during expression evaluation
     */
    warnings: Array<string>;
};

/**
 * Checks if the property matches the provided like value.
 *
 * Supported wildcard characters are:
 *
 * * `*`: matches zero, one, or multiple characters.
 * * `?`: matches one, single character.
 *
 * Wildcard characters can be escaped with backslash, for instance: `\*`.
 *
 */
export type LikeFilter = string;

/**
 * Advanced filter
 *
 * Basic advanced string filter.
 */
export type BasicStringFilter = {
    /**
     * Checks for equality with the provided value.
     */
    $eq?: string;
    /**
     * Checks for inequality with the provided value.
     */
    $neq?: string;
    /**
     * Checks if the current property exists.
     */
    $exists?: boolean;
    /**
     * Checks if the property matches any of the provided values.
     */
    $in?: Array<string>;
    /**
     * Checks if the property matches none of the provided values.
     */
    $notIn?: Array<string>;
};

/**
 * Advanced filter
 *
 * Advanced string filter.
 */
export type AdvancedStringFilter = BasicStringFilter & {
    $like?: LikeFilter;
};

/**
 * String property with basic advanced search capabilities.
 */
export type BasicStringFilterProperty = string | BasicStringFilter;

/**
 * String property with full advanced search capabilities.
 */
export type StringFilterProperty = string | AdvancedStringFilter;

/**
 * Advanced filter
 *
 * Advanced integer (int32) filter.
 */
export type AdvancedIntegerFilter = {
    /**
     * Checks for equality with the provided value.
     */
    $eq?: number;
    /**
     * Checks for inequality with the provided value.
     */
    $neq?: number;
    /**
     * Checks if the current property exists.
     */
    $exists?: boolean;
    /**
     * Greater than comparison with the provided value.
     */
    $gt?: number;
    /**
     * Greater than or equal comparison with the provided value.
     */
    $gte?: number;
    /**
     * Lower than comparison with the provided value.
     */
    $lt?: number;
    /**
     * Lower than or equal comparison with the provided value.
     */
    $lte?: number;
    /**
     * Checks if the property matches any of the provided values.
     */
    $in?: Array<number>;
};

/**
 * Integer property with advanced search capabilities.
 */
export type IntegerFilterProperty = number | AdvancedIntegerFilter;

/**
 * Advanced filter
 *
 * Advanced date-time filter.
 */
export type AdvancedDateTimeFilter = {
    /**
     * Checks for equality with the provided value.
     */
    $eq?: string;
    /**
     * Checks for inequality with the provided value.
     */
    $neq?: string;
    /**
     * Checks if the current property exists.
     */
    $exists?: boolean;
    /**
     * Greater than comparison with the provided value.
     */
    $gt?: string;
    /**
     * Greater than or equal comparison with the provided value.
     */
    $gte?: string;
    /**
     * Lower than comparison with the provided value.
     */
    $lt?: string;
    /**
     * Lower than or equal comparison with the provided value.
     */
    $lte?: string;
    /**
     * Checks if the property matches any of the provided values.
     */
    $in?: Array<string>;
};

/**
 * Date-time property with full advanced search capabilities.
 */
export type DateTimeFilterProperty = string | AdvancedDateTimeFilter;

export type FormResult = {
    /**
     * The tenant ID of the form.
     */
    tenantId?: TenantId;
    /**
     * The user-provided identifier of the form.
     */
    formId?: FormId;
    /**
     * The form content.
     */
    schema?: {
        [key: string]: unknown;
    };
    /**
     * The version of the the deployed form.
     */
    version?: number;
    /**
     * The assigned key, which acts as a unique identifier for this form.
     */
    formKey?: FormKey;
};

/**
 * How the global listener was defined.
 */
export type GlobalListenerSourceEnum = 'CONFIGURATION' | 'API';

/**
 * The event type that triggers the user task listener.
 */
export type GlobalTaskListenerEventTypeEnum = 'all' | 'creating' | 'assigning' | 'updating' | 'completing' | 'canceling';

export type GlobalListenerBase = {
    /**
     * The name of the job type, used as a reference to specify which job workers request the respective listener job.
     */
    type?: string;
    /**
     * Number of retries for the listener job.
     */
    retries?: number;
    /**
     * Whether the listener should run after model-level listeners.
     */
    afterNonGlobal?: boolean;
    /**
     * The priority of the listener. Higher priority listeners are executed before lower priority ones.
     */
    priority?: number;
};

export type GlobalTaskListenerBase = GlobalListenerBase & {
    eventTypes?: GlobalTaskListenerEventTypes;
};

/**
 * List of user task event types that trigger the listener.
 */
export type GlobalTaskListenerEventTypes = Array<GlobalTaskListenerEventTypeEnum>;

export type CreateGlobalTaskListenerRequest = GlobalTaskListenerBase & {
    id: GlobalListenerId;
    eventTypes: GlobalTaskListenerEventTypes;
};

export type UpdateGlobalTaskListenerRequest = GlobalTaskListenerBase;

export type GlobalTaskListenerResult = GlobalTaskListenerBase & {
    id?: GlobalListenerId;
    source?: GlobalListenerSourceEnum;
};

export type GroupCreateRequest = {
    /**
     * The ID of the new group.
     */
    groupId: string;
    /**
     * The display name of the new group.
     */
    name: string;
    /**
     * The description of the new group.
     */
    description?: string;
};

export type GroupCreateResult = {
    /**
     * The ID of the created group.
     */
    groupId?: string;
    /**
     * The display name of the created group.
     */
    name?: string;
    /**
     * The description of the created group.
     */
    description?: string;
};

export type GroupUpdateRequest = {
    /**
     * The new name of the group.
     */
    name: string;
    /**
     * The new description of the group.
     */
    description?: string;
};

export type GroupUpdateResult = {
    /**
     * The unique external group ID.
     */
    groupId?: string;
    /**
     * The name of the group.
     */
    name?: string;
    /**
     * The description of the group.
     */
    description?: string;
};

/**
 * Group search response item.
 */
export type GroupResult = {
    /**
     * The group name.
     */
    name?: string;
    /**
     * The group ID.
     */
    groupId?: string;
    /**
     * The group description.
     */
    description?: string;
};

export type GroupSearchQuerySortRequest = {
    /**
     * The field to sort by.
     */
    field: 'name' | 'groupId';
    order?: SortOrderEnum;
};

/**
 * Group search request.
 */
export type GroupSearchQueryRequest = SearchQueryRequest & {
    /**
     * Sort field criteria.
     */
    sort?: Array<GroupSearchQuerySortRequest>;
    /**
     * The group search filters.
     */
    filter?: GroupFilter;
};

/**
 * Group filter request
 */
export type GroupFilter = {
    /**
     * The group ID search filters.
     */
    groupId?: StringFilterProperty;
    /**
     * The group name search filters.
     */
    name?: string;
};

/**
 * Group search response.
 */
export type GroupSearchQueryResult = SearchQueryResponse & {
    /**
     * The matching groups.
     */
    items?: Array<GroupResult>;
};

export type GroupUserResult = {
    username?: Username;
};

export type GroupUserSearchResult = SearchQueryResponse & {
    /**
     * The matching members.
     */
    items?: Array<GroupUserResult>;
};

export type GroupUserSearchQueryRequest = SearchQueryRequest & {
    /**
     * Sort field criteria.
     */
    sort?: Array<GroupUserSearchQuerySortRequest>;
};

export type GroupUserSearchQuerySortRequest = {
    /**
     * The field to sort by.
     */
    field: 'username';
    order?: SortOrderEnum;
};

export type GroupClientResult = {
    /**
     * The ID of the client.
     */
    clientId?: string;
};

export type GroupClientSearchResult = SearchQueryResponse & {
    /**
     * The matching client IDs.
     */
    items?: Array<GroupClientResult>;
};

export type GroupClientSearchQueryRequest = SearchQueryRequest & {
    /**
     * Sort field criteria.
     */
    sort?: Array<GroupClientSearchQuerySortRequest>;
};

export type GroupClientSearchQuerySortRequest = {
    /**
     * The field to sort by.
     */
    field: 'clientId';
    order?: SortOrderEnum;
};

/**
 * Id of a process definition, from the model. Only ids of process definitions that are deployed are useful.
 */
export type ProcessDefinitionId = CamundaKey<'ProcessDefinitionId'>;

/**
 * The model-defined id of an element.
 */
export type ElementId = CamundaKey<'ElementId'>;

/**
 * The user-defined id for the form
 */
export type FormId = CamundaKey<'FormId'>;

/**
 * Id of a decision definition, from the model. Only ids of decision definitions that are deployed are useful.
 */
export type DecisionDefinitionId = CamundaKey<'DecisionDefinitionId'>;

/**
 * The user-defined id for the global listener
 */
export type GlobalListenerId = CamundaKey<'GlobalListenerId'>;

/**
 * The unique identifier of the tenant.
 */
export type TenantId = CamundaKey<'TenantId'>;

/**
 * The unique name of a user.
 */
export type Username = CamundaKey<'Username'>;

/**
 * A tag. Needs to start with a letter; then alphanumerics, `_`, `-`, `:`, or `.`; length  100.
 */
export type Tag = CamundaKey<'Tag'>;

/**
 * List of tags. Tags need to start with a letter; then alphanumerics, `_`, `-`, `:`, or `.`; length  100.
 */
export type TagSet = Array<Tag> & { readonly length: 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 }; // minItems=0 maxItems=10; uniqueItems=true;

export type IncidentSearchQuery = SearchQueryRequest & {
    /**
     * Sort field criteria.
     */
    sort?: Array<IncidentSearchQuerySortRequest>;
    /**
     * The incident search filters.
     */
    filter?: IncidentFilter;
};

/**
 * Incident search filter.
 */
export type IncidentFilter = {
    /**
     * The process definition ID associated to this incident.
     */
    processDefinitionId?: StringFilterProperty;
    /**
     * Incident error type with a defined set of values.
     */
    errorType?: IncidentErrorTypeFilterProperty;
    /**
     * The error message of this incident.
     */
    errorMessage?: StringFilterProperty;
    /**
     * The element ID associated to this incident.
     */
    elementId?: StringFilterProperty;
    /**
     * Date of incident creation.
     */
    creationTime?: DateTimeFilterProperty;
    /**
     * State of this incident with a defined set of values.
     */
    state?: IncidentStateFilterProperty;
    /**
     * The tenant ID of the incident.
     */
    tenantId?: StringFilterProperty;
    /**
     * The assigned key, which acts as a unique identifier for this incident.
     */
    incidentKey?: BasicStringFilterProperty;
    /**
     * The process definition key associated to this incident.
     */
    processDefinitionKey?: ProcessDefinitionKeyFilterProperty;
    /**
     * The process instance key associated to this incident.
     */
    processInstanceKey?: ProcessInstanceKeyFilterProperty;
    /**
     * The element instance key associated to this incident.
     */
    elementInstanceKey?: ElementInstanceKeyFilterProperty;
    /**
     * The job key, if exists, associated with this incident.
     */
    jobKey?: JobKeyFilterProperty;
};

/**
 * IncidentErrorTypeEnum with full advanced search capabilities.
 */
export type IncidentErrorTypeFilterProperty = IncidentErrorTypeExactMatch | AdvancedIncidentErrorTypeFilter;

/**
 * Advanced filter
 *
 * Advanced IncidentErrorTypeEnum filter
 */
export type AdvancedIncidentErrorTypeFilter = {
    /**
     * Checks for equality with the provided value.
     */
    $eq?: IncidentErrorTypeEnum;
    /**
     * Checks for inequality with the provided value.
     */
    $neq?: IncidentErrorTypeEnum;
    /**
     * Checks if the current property exists.
     */
    $exists?: boolean;
    /**
     * Checks if the property matches any of the provided values.
     */
    $in?: Array<IncidentErrorTypeEnum>;
    /**
     * Checks if the property does not match any of the provided values.
     */
    $notIn?: Array<IncidentErrorTypeEnum>;
    $like?: LikeFilter;
};

/**
 * Incident error type with a defined set of values.
 */
export type IncidentErrorTypeEnum = 'AD_HOC_SUB_PROCESS_NO_RETRIES' | 'CALLED_DECISION_ERROR' | 'CALLED_ELEMENT_ERROR' | 'CONDITION_ERROR' | 'DECISION_EVALUATION_ERROR' | 'EXECUTION_LISTENER_NO_RETRIES' | 'EXTRACT_VALUE_ERROR' | 'FORM_NOT_FOUND' | 'IO_MAPPING_ERROR' | 'JOB_NO_RETRIES' | 'MESSAGE_SIZE_EXCEEDED' | 'RESOURCE_NOT_FOUND' | 'TASK_LISTENER_NO_RETRIES' | 'UNHANDLED_ERROR_EVENT' | 'UNKNOWN' | 'UNSPECIFIED';

/**
 * IncidentStateEnum with full advanced search capabilities.
 */
export type IncidentStateFilterProperty = IncidentStateExactMatch | AdvancedIncidentStateFilter;

/**
 * Advanced filter
 *
 * Advanced IncidentStateEnum filter
 */
export type AdvancedIncidentStateFilter = {
    /**
     * Checks for equality with the provided value.
     */
    $eq?: IncidentStateEnum;
    /**
     * Checks for inequality with the provided value.
     */
    $neq?: IncidentStateEnum;
    /**
     * Checks if the current property exists.
     */
    $exists?: boolean;
    /**
     * Checks if the property matches any of the provided values.
     */
    $in?: Array<IncidentStateEnum>;
    /**
     * Checks if the property does not match any of the provided values.
     */
    $notIn?: Array<IncidentStateEnum>;
    $like?: LikeFilter;
};

/**
 * Incident states with a defined set of values.
 */
export type IncidentStateEnum = 'ACTIVE' | 'MIGRATED' | 'PENDING' | 'RESOLVED';

export type IncidentSearchQuerySortRequest = {
    /**
     * The field to sort by.
     */
    field: 'incidentKey' | 'processDefinitionKey' | 'processDefinitionId' | 'processInstanceKey' | 'errorType' | 'errorMessage' | 'elementId' | 'elementInstanceKey' | 'creationTime' | 'state' | 'jobKey' | 'tenantId';
    order?: SortOrderEnum;
};

export type IncidentSearchQueryResult = SearchQueryResponse & {
    /**
     * The matching incidents.
     */
    items?: Array<IncidentResult>;
};

export type IncidentResult = {
    /**
     * The process definition ID associated to this incident.
     */
    processDefinitionId?: ProcessDefinitionId;
    errorType?: IncidentErrorTypeEnum;
    /**
     * Error message which describes the error in more detail.
     */
    errorMessage?: string;
    /**
     * The element ID associated to this incident.
     */
    elementId?: ElementId;
    creationTime?: string;
    state?: IncidentStateEnum;
    /**
     * The tenant ID of the incident.
     */
    tenantId?: TenantId;
    /**
     * The assigned key, which acts as a unique identifier for this incident.
     */
    incidentKey?: IncidentKey;
    /**
     * The process definition key associated to this incident.
     */
    processDefinitionKey?: ProcessDefinitionKey;
    /**
     * The process instance key associated to this incident.
     */
    processInstanceKey?: ProcessInstanceKey;
    rootProcessInstanceKey?: RootProcessInstanceKey;
    /**
     * The element instance key associated to this incident.
     */
    elementInstanceKey?: ElementInstanceKey;
    /**
     * The job key, if exists, associated with this incident.
     */
    jobKey?: JobKey;
};

export type IncidentResolutionRequest = {
    operationReference?: OperationReference;
};

export type IncidentProcessInstanceStatisticsByErrorQuery = {
    /**
     * Pagination parameters for process instance statistics grouped by incident error.
     *
     */
    page?: OffsetPagination;
    /**
     * Sorting criteria for process instance statistics grouped by incident error.
     */
    sort?: Array<IncidentProcessInstanceStatisticsByErrorQuerySortRequest>;
};

export type IncidentProcessInstanceStatisticsByErrorQueryResult = SearchQueryResponse & {
    /**
     * Statistics of active process instances grouped by incident error.
     *
     */
    items?: Array<IncidentProcessInstanceStatisticsByErrorResult>;
};

export type IncidentProcessInstanceStatisticsByErrorResult = {
    /**
     * The hash code identifying a specific incident error..
     */
    errorHashCode?: number;
    /**
     * The error message associated with the incident error hash code.
     */
    errorMessage?: string;
    /**
     * The number of active process instances that currently have an active incident with this error.
     *
     */
    activeInstancesWithErrorCount?: number;
};

export type IncidentProcessInstanceStatisticsByErrorQuerySortRequest = {
    /**
     * The field to sort the incident error statistics by.
     */
    field: 'errorMessage' | 'activeInstancesWithErrorCount';
    order?: SortOrderEnum;
};

export type IncidentProcessInstanceStatisticsByDefinitionQuery = {
    /**
     * Filter criteria for the aggregated process instance statistics.
     */
    filter: IncidentProcessInstanceStatisticsByDefinitionFilter;
    /**
     * Pagination parameters for the aggregated process instance statistics.
     */
    page?: OffsetPagination;
    /**
     * Sorting criteria for process instance statistics grouped by process definition.
     */
    sort?: Array<IncidentProcessInstanceStatisticsByDefinitionQuerySortRequest>;
};

export type IncidentProcessInstanceStatisticsByDefinitionQueryResult = SearchQueryResponse & {
    /**
     * Statistics of active process instances with incidents, grouped by process
     * definition for the specified error hash code.
     *
     */
    items?: Array<IncidentProcessInstanceStatisticsByDefinitionResult>;
};

export type IncidentProcessInstanceStatisticsByDefinitionResult = {
    processDefinitionId?: ProcessDefinitionId;
    processDefinitionKey?: ProcessDefinitionKey;
    /**
     * The name of the process definition.
     */
    processDefinitionName?: string;
    /**
     * The version of the process definition.
     */
    processDefinitionVersion?: number;
    tenantId?: TenantId;
    /**
     * The number of active process instances that currently have an incident
     * with the specified error hash code.
     *
     */
    activeInstancesWithErrorCount?: number;
};

/**
 * Filter for the incident process instance statistics by definition query.
 */
export type IncidentProcessInstanceStatisticsByDefinitionFilter = {
    /**
     * The error hash code of the incidents to filter the process instance statistics by.
     *
     */
    errorHashCode: number;
};

export type IncidentProcessInstanceStatisticsByDefinitionQuerySortRequest = {
    /**
     * The aggregated field by which the process instance statistics are sorted.
     */
    field: 'activeInstancesWithErrorCount' | 'processDefinitionKey' | 'tenantId';
    order?: SortOrderEnum;
};

/**
 * Global job statistics query result.
 */
export type GlobalJobStatisticsQueryResult = {
    created: StatusMetric;
    completed: StatusMetric;
    failed: StatusMetric;
    /**
     * True if some data is missing because internal limits were reached and some metrics were not recorded.
     */
    isIncomplete: boolean;
};

/**
 * Metric for a single job status.
 */
export type StatusMetric = {
    /**
     * Number of jobs in this status.
     */
    count: number;
    /**
     * ISO 8601 timestamp of the last update for this status.
     */
    lastUpdatedAt: string;
};

export type JobActivationRequest = {
    /**
     * The job type, as defined in the BPMN process (e.g. <zeebe:taskDefinition type="payment-service" />)
     */
    type: string;
    /**
     * The name of the worker activating the jobs, mostly used for logging purposes.
     */
    worker?: string;
    /**
     * A job returned after this call will not be activated by another call until the timeout (in ms) has been reached.
     *
     */
    timeout: number;
    /**
     * The maximum jobs to activate by this request.
     */
    maxJobsToActivate: number;
    /**
     * A list of variables to fetch as the job variables; if empty, all visible variables at the time of activation for the scope of the job will be returned.
     */
    fetchVariable?: Array<string>;
    /**
     * The request will be completed when at least one job is activated or after the requestTimeout (in ms). If the requestTimeout = 0, a default timeout is used. If the requestTimeout < 0, long polling is disabled and the request is completed immediately, even when no job is activated.
     *
     */
    requestTimeout?: number;
    /**
     * A list of IDs of tenants for which to activate jobs.
     */
    tenantIds?: Array<TenantId>;
    /**
     * The tenant filtering strategy - determines whether to use provided tenant IDs or assigned tenant IDs from the authenticated principal's authorized tenants.
     *
     */
    tenantFilter?: TenantFilterEnum;
};

/**
 * The list of activated jobs
 */
export type JobActivationResult = {
    /**
     * The activated jobs.
     */
    jobs: Array<ActivatedJobResult>;
};

export type ActivatedJobResult = {
    /**
     * The type of the job (should match what was requested).
     */
    type: string;
    /**
     * The bpmn process ID of the job's process definition.
     */
    processDefinitionId: ProcessDefinitionId;
    /**
     * The version of the job's process definition.
     */
    processDefinitionVersion: number;
    /**
     * The associated task element ID.
     */
    elementId: ElementId;
    /**
     * A set of custom headers defined during modelling; returned as a serialized JSON document.
     */
    customHeaders: {
        [key: string]: unknown;
    };
    /**
     * The name of the worker which activated this job.
     */
    worker: string;
    /**
     * The amount of retries left to this job (should always be positive).
     */
    retries: number;
    /**
     * When the job can be activated again, sent as a UNIX epoch timestamp.
     */
    deadline: number;
    /**
     * All variables visible to the task scope, computed at activation time.
     */
    variables: {
        [key: string]: unknown;
    };
    /**
     * The ID of the tenant that owns the job.
     */
    tenantId: TenantId;
    /**
     * The key, a unique identifier for the job.
     */
    jobKey: JobKey;
    /**
     * The job's process instance key.
     */
    processInstanceKey: ProcessInstanceKey;
    /**
     * The key of the job's process definition.
     */
    processDefinitionKey: ProcessDefinitionKey;
    elementInstanceKey: ElementInstanceKey;
    kind: JobKindEnum;
    listenerEventType: JobListenerEventTypeEnum;
    userTask?: UserTaskProperties;
    tags?: TagSet;
};

/**
 * Contains properties of a user task.
 */
export type UserTaskProperties = {
    /**
     * The action performed on the user task.
     */
    action?: string;
    /**
     * The user assigned to the task.
     */
    assignee?: string | null;
    /**
     * The groups eligible to claim the task.
     */
    candidateGroups?: Array<string>;
    /**
     * The users eligible to claim the task.
     */
    candidateUsers?: Array<string>;
    /**
     * The attributes that were changed in the task.
     */
    changedAttributes?: Array<string>;
    /**
     * The due date of the user task in ISO 8601 format.
     */
    dueDate?: string | null;
    /**
     * The follow-up date of the user task in ISO 8601 format.
     */
    followUpDate?: string | null;
    /**
     * The key of the form associated with the user task.
     */
    formKey?: FormKey;
    /**
     * The priority of the user task.
     */
    priority?: number | null;
    /**
     * The unique key identifying the user task.
     */
    userTaskKey?: UserTaskKey | null;
};

/**
 * Job search request.
 */
export type JobSearchQuery = SearchQueryRequest & {
    /**
     * Sort field criteria.
     */
    sort?: Array<JobSearchQuerySortRequest>;
    /**
     * The job search filters.
     */
    filter?: JobFilter;
};

export type JobSearchQuerySortRequest = {
    /**
     * The field to sort by.
     */
    field: 'deadline' | 'deniedReason' | 'elementId' | 'elementInstanceKey' | 'endTime' | 'errorCode' | 'errorMessage' | 'hasFailedWithRetriesLeft' | 'isDenied' | 'jobKey' | 'kind' | 'listenerEventType' | 'processDefinitionId' | 'processDefinitionKey' | 'processInstanceKey' | 'retries' | 'state' | 'tenantId' | 'type' | 'worker';
    order?: SortOrderEnum;
};

/**
 * Job search filter.
 */
export type JobFilter = {
    /**
     * When the job can next be activated.
     */
    deadline?: DateTimeFilterProperty | null;
    /**
     * The reason provided by the user task listener for denying the work.
     */
    deniedReason?: StringFilterProperty;
    /**
     * The element ID associated with the job.
     */
    elementId?: StringFilterProperty;
    /**
     * The element instance key associated with the job.
     */
    elementInstanceKey?: ElementInstanceKeyFilterProperty;
    /**
     * When the job ended.
     */
    endTime?: DateTimeFilterProperty;
    /**
     * The error code provided for the failed job.
     */
    errorCode?: StringFilterProperty;
    /**
     * The error message that provides additional context for a failed job.
     */
    errorMessage?: StringFilterProperty;
    /**
     * Indicates whether the job has failed with retries left.
     */
    hasFailedWithRetriesLeft?: boolean;
    /**
     * Indicates whether the user task listener denies the work.
     */
    isDenied?: boolean | null;
    /**
     * The key, a unique identifier for the job.
     */
    jobKey?: JobKeyFilterProperty;
    /**
     * The kind of the job.
     */
    kind?: JobKindFilterProperty;
    /**
     * The listener event type of the job.
     */
    listenerEventType?: JobListenerEventTypeFilterProperty;
    /**
     * The process definition ID associated with the job.
     */
    processDefinitionId?: StringFilterProperty;
    /**
     * The process definition key associated with the job.
     */
    processDefinitionKey?: ProcessDefinitionKeyFilterProperty;
    /**
     * The process instance key associated with the job.
     */
    processInstanceKey?: ProcessInstanceKeyFilterProperty;
    /**
     * The number of retries left.
     */
    retries?: IntegerFilterProperty;
    /**
     * The state of the job.
     */
    state?: JobStateFilterProperty;
    /**
     * The tenant ID.
     */
    tenantId?: StringFilterProperty;
    /**
     * The type of the job.
     */
    type?: StringFilterProperty;
    /**
     * The name of the worker for this job.
     */
    worker?: StringFilterProperty;
    /**
     * When the job was created. Field is present for jobs created after 8.9.
     */
    creationTime?: DateTimeFilterProperty;
    /**
     * When the job was last updated. Field is present for jobs created after 8.9.
     */
    lastUpdateTime?: DateTimeFilterProperty;
};

/**
 * Job search response.
 */
export type JobSearchQueryResult = SearchQueryResponse & {
    /**
     * The matching jobs.
     */
    items?: Array<JobSearchResult>;
};

export type JobSearchResult = {
    /**
     * A set of custom headers defined during modelling.
     */
    customHeaders: {
        [key: string]: string;
    };
    /**
     * If the job has been activated, when it will next be available to be activated.
     */
    deadline?: string | null;
    /**
     * The reason provided by the user task listener for denying the work.
     */
    deniedReason?: string | null;
    /**
     * The element ID associated with the job.
     */
    elementId: ElementId;
    /**
     * The element instance key associated with the job.
     */
    elementInstanceKey: ElementInstanceKey;
    /**
     * When the job ended.
     */
    endTime?: string;
    /**
     * The error code provided for a failed job.
     */
    errorCode?: string | null;
    /**
     * The error message that provides additional context for a failed job.
     */
    errorMessage?: string | null;
    /**
     * Indicates whether the job has failed with retries left.
     */
    hasFailedWithRetriesLeft: boolean;
    /**
     * Indicates whether the user task listener denies the work.
     */
    isDenied?: boolean | null;
    /**
     * The key, a unique identifier for the job.
     */
    jobKey: JobKey;
    kind: JobKindEnum;
    listenerEventType: JobListenerEventTypeEnum;
    /**
     * The process definition ID associated with the job.
     */
    processDefinitionId: ProcessDefinitionId;
    /**
     * The process definition key associated with the job.
     */
    processDefinitionKey: ProcessDefinitionKey;
    /**
     * The process instance key associated with the job.
     */
    processInstanceKey: ProcessInstanceKey;
    rootProcessInstanceKey?: RootProcessInstanceKey;
    /**
     * The amount of retries left to this job.
     */
    retries: number;
    state: JobStateEnum;
    tenantId: TenantId;
    /**
     * The type of the job.
     */
    type: string;
    /**
     * The name of the worker of this job.
     */
    worker: string;
    /**
     * When the job was created. Field is present for jobs created after 8.9.
     */
    creationTime?: string;
    /**
     * When the job was last updated. Field is present for jobs created after 8.9.
     */
    lastUpdateTime?: string;
};

export type JobFailRequest = {
    /**
     * The amount of retries the job should have left
     */
    retries?: number;
    /**
     * An optional error message describing why the job failed; if not provided, an empty string is used.
     */
    errorMessage?: string;
    /**
     * An optional retry back off for the failed job. The job will not be retryable before the current time plus the back off time. The default is 0 which means the job is retryable immediately.
     */
    retryBackOff?: number;
    /**
     * JSON object that will instantiate the variables at the local scope of the job's associated task.
     *
     */
    variables?: {
        [key: string]: unknown;
    };
};

export type JobErrorRequest = {
    /**
     * The error code that will be matched with an error catch event.
     *
     */
    errorCode: string;
    /**
     * An error message that provides additional context.
     *
     */
    errorMessage?: string | null;
    /**
     * JSON object that will instantiate the variables at the local scope of the error catch event that catches the thrown error.
     *
     */
    variables?: {
        [key: string]: unknown;
    } | null;
};

export type JobCompletionRequest = {
    /**
     * The variables to complete the job with.
     */
    variables?: {
        [key: string]: unknown;
    } | null;
    result?: JobResult;
};

/**
 * The result of the completed job as determined by the worker.
 *
 */
export type JobResult = ({
    type: 'userTask';
} & JobResultUserTask) | ({
    type: 'adHocSubProcess';
} & JobResultAdHocSubProcess);

/**
 * Job result details for a user task completion, optionally including a denial reason and corrected task properties.
 *
 */
export type JobResultUserTask = {
    /**
     * Indicates whether the worker denies the work, i.e. explicitly doesn't approve it. For example, a user task listener can deny the completion of a task by setting this flag to true. In this example, the completion of a task is represented by a job that the worker can complete as denied. As a result, the completion request is rejected and the task remains active. Defaults to false.
     *
     */
    denied?: boolean | null;
    /**
     * The reason provided by the user task listener for denying the work.
     */
    deniedReason?: string | null;
    corrections?: JobResultCorrections;
    /**
     * Used to distinguish between different types of job results.
     */
    type?: string;
} | null;

/**
 * JSON object with attributes that were corrected by the worker.
 *
 * The following attributes can be corrected, additional attributes will be ignored:
 *
 * * `assignee` - clear by providing an empty String
 * * `dueDate` - clear by providing an empty String
 * * `followUpDate` - clear by providing an empty String
 * * `candidateGroups` - clear by providing an empty list
 * * `candidateUsers` - clear by providing an empty list
 * * `priority` - minimum 0, maximum 100, default 50
 *
 * Providing any of those attributes with a `null` value or omitting it preserves
 * the persisted attribute's value.
 *
 */
export type JobResultCorrections = {
    /**
     * Assignee of the task.
     */
    assignee?: string | null;
    /**
     * The due date of the task.
     */
    dueDate?: string | null;
    /**
     * The follow-up date of the task.
     */
    followUpDate?: string | null;
    /**
     * The list of candidate users of the task.
     */
    candidateUsers?: Array<string> | null;
    /**
     * The list of candidate groups of the task.
     */
    candidateGroups?: Array<string> | null;
    /**
     * The priority of the task.
     */
    priority?: number | null;
} | null;

/**
 * Job result details for an adhoc subprocess, including elements to activate and flags indicating completion or cancellation behavior.
 *
 */
export type JobResultAdHocSubProcess = {
    /**
     * Indicates which elements need to be activated in the ad-hoc subprocess.
     */
    activateElements?: Array<JobResultActivateElement>;
    /**
     * Indicates whether the completion condition of the ad-hoc subprocess is fulfilled.
     */
    isCompletionConditionFulfilled?: boolean;
    /**
     * Indicates whether the remaining instances of the ad-hoc subprocess should be canceled.
     */
    isCancelRemainingInstances?: boolean;
    /**
     * Used to distinguish between different types of job results.
     */
    type?: string;
} | null;

/**
 * Instruction to activate a single BPMN element within an adhoc subprocess, optionally providing variables scoped to that element.
 */
export type JobResultActivateElement = {
    /**
     * The element ID to activate.
     */
    elementId?: ElementId;
    /**
     * Variables for the element.
     */
    variables?: {
        [key: string]: unknown;
    };
};

export type JobUpdateRequest = {
    changeset: JobChangeset;
    operationReference?: OperationReference;
};

/**
 * JSON object with changed job attribute values. The job cannot be completed or failed with this endpoint, use the complete job or fail job endpoints instead.
 */
export type JobChangeset = {
    /**
     * The new number of retries for the job.
     */
    retries?: number | null;
    /**
     * The new timeout for the job in milliseconds.
     */
    timeout?: number | null;
};

/**
 * The tenant filtering strategy for job activation. Determines whether to use tenant IDs provided in the request or tenant IDs assigned to the authenticated principal.
 *
 */
export type TenantFilterEnum = 'PROVIDED' | 'ASSIGNED';

/**
 * The state of the job.
 */
export type JobStateEnum = 'CANCELED' | 'COMPLETED' | 'CREATED' | 'ERROR_THROWN' | 'FAILED' | 'MIGRATED' | 'RETRIES_UPDATED' | 'TIMED_OUT';

/**
 * The job kind.
 */
export type JobKindEnum = 'BPMN_ELEMENT' | 'EXECUTION_LISTENER' | 'TASK_LISTENER' | 'AD_HOC_SUB_PROCESS';

/**
 * The listener event type of the job.
 */
export type JobListenerEventTypeEnum = 'ASSIGNING' | 'CANCELING' | 'COMPLETING' | 'CREATING' | 'END' | 'START' | 'UNSPECIFIED' | 'UPDATING';

/**
 * JobKindEnum property with full advanced search capabilities.
 */
export type JobKindFilterProperty = JobKindExactMatch | AdvancedJobKindFilter;

/**
 * Advanced filter
 *
 * Advanced JobKindEnum filter.
 */
export type AdvancedJobKindFilter = {
    /**
     * Checks for equality with the provided value.
     */
    $eq?: JobKindEnum;
    /**
     * Checks for inequality with the provided value.
     */
    $neq?: JobKindEnum;
    /**
     * Checks if the current property exists.
     */
    $exists?: boolean;
    /**
     * Checks if the property matches any of the provided values.
     */
    $in?: Array<JobKindEnum>;
    $like?: LikeFilter;
};

/**
 * JobListenerEventTypeEnum property with full advanced search capabilities.
 */
export type JobListenerEventTypeFilterProperty = JobListenerEventTypeExactMatch | AdvancedJobListenerEventTypeFilter;

/**
 * Advanced filter
 *
 * Advanced JobListenerEventTypeEnum filter.
 */
export type AdvancedJobListenerEventTypeFilter = {
    /**
     * Checks for equality with the provided value.
     */
    $eq?: JobListenerEventTypeEnum;
    /**
     * Checks for inequality with the provided value.
     */
    $neq?: JobListenerEventTypeEnum;
    /**
     * Checks if the current property exists.
     */
    $exists?: boolean;
    /**
     * Checks if the property matches any of the provided values.
     */
    $in?: Array<JobListenerEventTypeEnum>;
    $like?: LikeFilter;
};

/**
 * JobStateEnum property with full advanced search capabilities.
 */
export type JobStateFilterProperty = JobStateExactMatch | AdvancedJobStateFilter;

/**
 * Advanced filter
 *
 * Advanced JobStateEnum filter.
 */
export type AdvancedJobStateFilter = {
    /**
     * Checks for equality with the provided value.
     */
    $eq?: JobStateEnum;
    /**
     * Checks for inequality with the provided value.
     */
    $neq?: JobStateEnum;
    /**
     * Checks if the current property exists.
     */
    $exists?: boolean;
    /**
     * Checks if the property matches any of the provided values.
     */
    $in?: Array<JobStateEnum>;
    $like?: LikeFilter;
};

/**
 * Zeebe Engine resource key (Java long serialized as string)
 */
export type LongKey = string;

/**
 * System-generated key for a process instance.
 */
export type ProcessInstanceKey = CamundaKey<'ProcessInstanceKey'>;

/**
 * The key of the root process instance. The root process instance is the top-level
 * ancestor in the process instance hierarchy. This field is only present for data
 * belonging to process instance hierarchies created in version 8.9 or later.
 *
 */
export type RootProcessInstanceKey = CamundaKey<'RootProcessInstanceKey'>;

/**
 * System-generated key for a deployed process definition.
 */
export type ProcessDefinitionKey = CamundaKey<'ProcessDefinitionKey'>;

/**
 * System-generated key for a element instance.
 */
export type ElementInstanceKey = CamundaKey<'ElementInstanceKey'>;

/**
 * System-generated key for a user task.
 */
export type UserTaskKey = CamundaKey<'UserTaskKey'>;

/**
 * System-generated key for a deployed form.
 */
export type FormKey = CamundaKey<'FormKey'>;

/**
 * System-generated key for a variable.
 */
export type VariableKey = CamundaKey<'VariableKey'>;

/**
 * System-generated key for a scope.
 */
export type ScopeKey = CamundaKey<'ScopeKey'>;

/**
 * System-generated key for a incident.
 */
export type IncidentKey = CamundaKey<'IncidentKey'>;

/**
 * System-generated key for a job.
 */
export type JobKey = CamundaKey<'JobKey'>;

/**
 * System-generated key for a decision definition.
 */
export type DecisionDefinitionKey = CamundaKey<'DecisionDefinitionKey'>;

/**
 * System-generated key for a decision evaluation instance.
 */
export type DecisionEvaluationInstanceKey = CamundaKey<'DecisionEvaluationInstanceKey'>;

/**
 * System-generated key for a decision evaluation.
 */
export type DecisionEvaluationKey = CamundaKey<'DecisionEvaluationKey'>;

/**
 * System-generated key for a deployed decision requirements definition.
 */
export type DecisionRequirementsKey = CamundaKey<'DecisionRequirementsKey'>;

/**
 * System-generated key for a deployed decision instance.
 */
export type DecisionInstanceKey = CamundaKey<'DecisionInstanceKey'>;

/**
 * System-generated key for an batch operation.
 */
export type BatchOperationKey = CamundaKey<'BatchOperationKey'>;

/**
 * A reference key chosen by the user that will be part of all records resulting from this operation.
 * Must be > 0 if provided.
 *
 */
export type OperationReference = number;

/**
 * System-generated key for an audit log entry.
 */
export type AuditLogKey = CamundaKey<'AuditLogKey'>;

/**
 * ProcessDefinitionKey property with full advanced search capabilities.
 */
export type ProcessDefinitionKeyFilterProperty = ProcessDefinitionKeyExactMatch | AdvancedProcessDefinitionKeyFilter;

/**
 * Advanced filter
 *
 * Advanced ProcessDefinitionKey filter.
 */
export type AdvancedProcessDefinitionKeyFilter = {
    /**
     * Checks for equality with the provided value.
     */
    $eq?: ProcessDefinitionKey;
    /**
     * Checks for inequality with the provided value.
     */
    $neq?: ProcessDefinitionKey;
    /**
     * Checks if the current property exists.
     */
    $exists?: boolean;
    /**
     * Checks if the property matches any of the provided values.
     */
    $in?: Array<ProcessDefinitionKey>;
    /**
     * Checks if the property matches none of the provided values.
     */
    $notIn?: Array<ProcessDefinitionKey>;
};

/**
 * ProcessInstanceKey property with full advanced search capabilities.
 */
export type ProcessInstanceKeyFilterProperty = ProcessInstanceKeyExactMatch | AdvancedProcessInstanceKeyFilter;

/**
 * Advanced filter
 *
 * Advanced ProcessInstanceKey filter.
 */
export type AdvancedProcessInstanceKeyFilter = {
    /**
     * Checks for equality with the provided value.
     */
    $eq?: ProcessInstanceKey;
    /**
     * Checks for inequality with the provided value.
     */
    $neq?: ProcessInstanceKey;
    /**
     * Checks if the current property exists.
     */
    $exists?: boolean;
    /**
     * Checks if the property matches any of the provided values.
     */
    $in?: Array<ProcessInstanceKey>;
    /**
     * Checks if the property matches none of the provided values.
     */
    $notIn?: Array<ProcessInstanceKey>;
};

/**
 * ElementInstanceKey property with full advanced search capabilities.
 */
export type ElementInstanceKeyFilterProperty = ElementInstanceKeyExactMatch | AdvancedElementInstanceKeyFilter;

/**
 * Advanced filter
 *
 * Advanced ElementInstanceKey filter.
 */
export type AdvancedElementInstanceKeyFilter = {
    /**
     * Checks for equality with the provided value.
     */
    $eq?: ElementInstanceKey;
    /**
     * Checks for inequality with the provided value.
     */
    $neq?: ElementInstanceKey;
    /**
     * Checks if the current property exists.
     */
    $exists?: boolean;
    /**
     * Checks if the property matches any of the provided values.
     */
    $in?: Array<ElementInstanceKey>;
    /**
     * Checks if the property matches none of the provided values.
     */
    $notIn?: Array<ElementInstanceKey>;
};

/**
 * JobKey property with full advanced search capabilities.
 */
export type JobKeyFilterProperty = JobKeyExactMatch | AdvancedJobKeyFilter;

/**
 * Advanced filter
 *
 * Advanced JobKey filter.
 */
export type AdvancedJobKeyFilter = {
    /**
     * Checks for equality with the provided value.
     */
    $eq?: JobKey;
    /**
     * Checks for inequality with the provided value.
     */
    $neq?: JobKey;
    /**
     * Checks if the current property exists.
     */
    $exists?: boolean;
    /**
     * Checks if the property matches any of the provided values.
     */
    $in?: Array<JobKey>;
    /**
     * Checks if the property matches none of the provided values.
     */
    $notIn?: Array<JobKey>;
};

/**
 * DecisionDefinitionKey property with full advanced search capabilities.
 */
export type DecisionDefinitionKeyFilterProperty = DecisionDefinitionKeyExactMatch | AdvancedDecisionDefinitionKeyFilter;

/**
 * Advanced filter
 *
 * Advanced DecisionDefinitionKey filter.
 */
export type AdvancedDecisionDefinitionKeyFilter = {
    /**
     * Checks for equality with the provided value.
     */
    $eq?: DecisionDefinitionKey;
    /**
     * Checks for inequality with the provided value.
     */
    $neq?: DecisionDefinitionKey;
    /**
     * Checks if the current property exists.
     */
    $exists?: boolean;
    /**
     * Checks if the property matches any of the provided values.
     */
    $in?: Array<DecisionDefinitionKey>;
    /**
     * Checks if the property matches none of the provided values.
     */
    $notIn?: Array<DecisionDefinitionKey>;
};

/**
 * ScopeKey property with full advanced search capabilities.
 */
export type ScopeKeyFilterProperty = ScopeKeyExactMatch | AdvancedScopeKeyFilter;

/**
 * Advanced filter
 *
 * Advanced ScopeKey filter.
 */
export type AdvancedScopeKeyFilter = {
    /**
     * Checks for equality with the provided value.
     */
    $eq?: ScopeKey;
    /**
     * Checks for inequality with the provided value.
     */
    $neq?: ScopeKey;
    /**
     * Checks if the current property exists.
     */
    $exists?: boolean;
    /**
     * Checks if the property matches any of the provided values.
     */
    $in?: Array<ScopeKey>;
    /**
     * Checks if the property matches none of the provided values.
     */
    $notIn?: Array<ScopeKey>;
};

/**
 * VariableKey property with full advanced search capabilities.
 */
export type VariableKeyFilterProperty = VariableKeyExactMatch | AdvancedVariableKeyFilter;

/**
 * Advanced filter
 *
 * Advanced VariableKey filter.
 */
export type AdvancedVariableKeyFilter = {
    /**
     * Checks for equality with the provided value.
     */
    $eq?: VariableKey;
    /**
     * Checks for inequality with the provided value.
     */
    $neq?: VariableKey;
    /**
     * Checks if the current property exists.
     */
    $exists?: boolean;
    /**
     * Checks if the property matches any of the provided values.
     */
    $in?: Array<VariableKey>;
    /**
     * Checks if the property matches none of the provided values.
     */
    $notIn?: Array<VariableKey>;
};

/**
 * DecisionEvaluationInstanceKey property with full advanced search capabilities.
 */
export type DecisionEvaluationInstanceKeyFilterProperty = DecisionEvaluationInstanceKeyExactMatch | AdvancedDecisionEvaluationInstanceKeyFilter;

/**
 * Advanced filter
 *
 * Advanced DecisionEvaluationInstanceKey filter.
 */
export type AdvancedDecisionEvaluationInstanceKeyFilter = {
    /**
     * Checks for equality with the provided value.
     */
    $eq?: DecisionEvaluationInstanceKey;
    /**
     * Checks for inequality with the provided value.
     */
    $neq?: DecisionEvaluationInstanceKey;
    /**
     * Checks if the current property exists.
     */
    $exists?: boolean;
    /**
     * Checks if the property matches any of the provided values.
     */
    $in?: Array<DecisionEvaluationInstanceKey>;
    /**
     * Checks if the property matches none of the provided values.
     */
    $notIn?: Array<DecisionEvaluationInstanceKey>;
};

/**
 * AuditLogKey property with full advanced search capabilities.
 */
export type AuditLogKeyFilterProperty = AuditLogKeyExactMatch | AdvancedAuditLogKeyFilter;

/**
 * Advanced filter
 *
 * Advanced AuditLogKey filter.
 */
export type AdvancedAuditLogKeyFilter = {
    /**
     * Checks for equality with the provided value.
     */
    $eq?: AuditLogKey;
    /**
     * Checks for inequality with the provided value.
     */
    $neq?: AuditLogKey;
    /**
     * Checks if the current property exists.
     */
    $exists?: boolean;
    /**
     * Checks if the property matches any of the provided values.
     */
    $in?: Array<AuditLogKey>;
    /**
     * Checks if the property matches none of the provided values.
     */
    $notIn?: Array<AuditLogKey>;
};

/**
 * FormKey property with full advanced search capabilities.
 */
export type FormKeyFilterProperty = FormKeyExactMatch | AdvancedFormKeyFilter;

/**
 * Advanced filter
 *
 * Advanced FormKey filter.
 */
export type AdvancedFormKeyFilter = {
    /**
     * Checks for equality with the provided value.
     */
    $eq?: FormKey;
    /**
     * Checks for inequality with the provided value.
     */
    $neq?: FormKey;
    /**
     * Checks if the current property exists.
     */
    $exists?: boolean;
    /**
     * Checks if the property matches any of the provided values.
     */
    $in?: Array<FormKey>;
    /**
     * Checks if the property matches none of the provided values.
     */
    $notIn?: Array<FormKey>;
};

/**
 * DecisionEvaluationKey property with full advanced search capabilities.
 */
export type DecisionEvaluationKeyFilterProperty = DecisionEvaluationKeyExactMatch | AdvancedDecisionEvaluationKeyFilter;

/**
 * Advanced filter
 *
 * Advanced DecisionEvaluationKey filter.
 */
export type AdvancedDecisionEvaluationKeyFilter = {
    /**
     * Checks for equality with the provided value.
     */
    $eq?: DecisionEvaluationKey;
    /**
     * Checks for inequality with the provided value.
     */
    $neq?: DecisionEvaluationKey;
    /**
     * Checks if the current property exists.
     */
    $exists?: boolean;
    /**
     * Checks if the property matches any of the provided values.
     */
    $in?: Array<DecisionEvaluationKey>;
    /**
     * Checks if the property matches none of the provided values.
     */
    $notIn?: Array<DecisionEvaluationKey>;
};

/**
 * DecisionRequirementsKey property with full advanced search capabilities.
 */
export type DecisionRequirementsKeyFilterProperty = DecisionRequirementsKeyExactMatch | AdvancedDecisionRequirementsKeyFilter;

/**
 * Advanced filter
 *
 * Advanced DecisionRequirementsKey filter.
 */
export type AdvancedDecisionRequirementsKeyFilter = {
    /**
     * Checks for equality with the provided value.
     */
    $eq?: DecisionRequirementsKey;
    /**
     * Checks for inequality with the provided value.
     */
    $neq?: DecisionRequirementsKey;
    /**
     * Checks if the current property exists.
     */
    $exists?: boolean;
    /**
     * Checks if the property matches any of the provided values.
     */
    $in?: Array<DecisionRequirementsKey>;
    /**
     * Checks if the property matches none of the provided values.
     */
    $notIn?: Array<DecisionRequirementsKey>;
};

/**
 * The response of a license request.
 */
export type LicenseResponse = {
    /**
     * True if the Camunda license is valid, false if otherwise
     */
    validLicense: boolean;
    /**
     * Will return the license type property of the Camunda license
     */
    licenseType: string;
    /**
     * Will be false when a license contains a non-commerical=true property
     */
    isCommercial: boolean;
    /**
     * The date when the Camunda license expires
     */
    expiresAt?: string | null;
};

export type MappingRuleCreateUpdateRequest = {
    /**
     * The name of the claim to map.
     */
    claimName: string;
    /**
     * The value of the claim to map.
     */
    claimValue: string;
    /**
     * The name of the mapping rule.
     */
    name: string;
};

export type MappingRuleCreateRequest = MappingRuleCreateUpdateRequest & {
    /**
     * The unique ID of the mapping rule.
     */
    mappingRuleId: string;
};

export type MappingRuleUpdateRequest = MappingRuleCreateUpdateRequest;

export type MappingRuleCreateUpdateResult = {
    /**
     * The name of the claim to map.
     */
    claimName?: string;
    /**
     * The value of the claim to map.
     */
    claimValue?: string;
    /**
     * The name of the mapping rule.
     */
    name?: string;
    /**
     * The unique ID of the mapping rule.
     */
    mappingRuleId?: string;
};

export type MappingRuleCreateResult = MappingRuleCreateUpdateResult;

export type MappingRuleUpdateResult = MappingRuleCreateUpdateResult;

export type MappingRuleSearchQueryResult = SearchQueryResponse & {
    /**
     * The matching mapping rules.
     */
    items?: Array<MappingRuleResult>;
};

export type MappingRuleResult = {
    /**
     * The name of the claim to map.
     */
    claimName?: string;
    /**
     * The value of the claim to map.
     */
    claimValue?: string;
    /**
     * The name of the mapping rule.
     */
    name?: string;
    /**
     * The ID of the mapping rule.
     */
    mappingRuleId?: string;
};

export type MappingRuleSearchQuerySortRequest = {
    /**
     * The field to sort by.
     */
    field: 'mappingRuleId' | 'claimName' | 'claimValue' | 'name';
    order?: SortOrderEnum;
};

export type MappingRuleSearchQueryRequest = SearchQueryRequest & {
    /**
     * Sort field criteria.
     */
    sort?: Array<MappingRuleSearchQuerySortRequest>;
    /**
     * The mapping rule search filters.
     */
    filter?: MappingRuleFilter;
};

/**
 * Mapping rule search filter.
 */
export type MappingRuleFilter = {
    /**
     * The claim name to match against a token.
     */
    claimName?: string;
    /**
     * The value of the claim to match.
     */
    claimValue?: string;
    /**
     * The name of the mapping rule.
     */
    name?: string;
    /**
     * The ID of the mapping rule.
     */
    mappingRuleId?: string;
};

export type MessageCorrelationRequest = {
    /**
     * The message name as defined in the BPMN process
     *
     */
    name: string;
    /**
     * The correlation key of the message.
     */
    correlationKey?: string;
    /**
     * The message variables as JSON document
     */
    variables?: {
        [key: string]: unknown;
    };
    /**
     * the tenant for which the message is published
     */
    tenantId?: TenantId;
};

/**
 * The message key of the correlated message, as well as the first process instance key it
 * correlated with.
 *
 */
export type MessageCorrelationResult = {
    /**
     * The tenant ID of the correlated message
     */
    tenantId?: TenantId;
    /**
     * The key of the correlated message.
     */
    messageKey?: MessageKey;
    /**
     * The key of the first process instance the message correlated with
     */
    processInstanceKey?: ProcessInstanceKey;
};

export type MessagePublicationRequest = {
    /**
     * The name of the message.
     */
    name: string;
    /**
     * The correlation key of the message.
     */
    correlationKey?: string;
    /**
     * Timespan (in ms) to buffer the message on the broker.
     */
    timeToLive?: number;
    /**
     * The unique ID of the message. This is used to ensure only one message with the given ID
     * will be published during the lifetime of the message (if `timeToLive` is set).
     *
     */
    messageId?: string;
    /**
     * The message variables as JSON document.
     */
    variables?: {
        [key: string]: unknown;
    };
    /**
     * The tenant of the message sender.
     */
    tenantId?: TenantId;
};

/**
 * The message key of the published message.
 */
export type MessagePublicationResult = {
    /**
     * The tenant ID of the message.
     */
    tenantId?: TenantId;
    /**
     * The key of the published message.
     */
    messageKey?: MessageKey;
};

export type MessageSubscriptionSearchQueryResult = SearchQueryResponse & {
    /**
     * The matching message subscriptions.
     */
    items?: Array<MessageSubscriptionResult>;
};

export type MessageSubscriptionResult = {
    /**
     * The message subscription key associated with this message subscription.
     */
    messageSubscriptionKey?: MessageSubscriptionKey;
    /**
     * The process definition ID associated with this message subscription.
     */
    processDefinitionId?: ProcessDefinitionId;
    /**
     * The process definition key associated with this message subscription.
     */
    processDefinitionKey?: ProcessDefinitionKey;
    /**
     * The process instance key associated with this message subscription.
     */
    processInstanceKey?: ProcessInstanceKey;
    rootProcessInstanceKey?: RootProcessInstanceKey;
    /**
     * The element ID associated with this message subscription.
     */
    elementId?: ElementId;
    /**
     * The element instance key associated with this message subscription.
     */
    elementInstanceKey?: ElementInstanceKey;
    messageSubscriptionState?: MessageSubscriptionStateEnum;
    /**
     * The last updated date of the message subscription.
     */
    lastUpdatedDate?: string;
    /**
     * The name of the message associated with the message subscription.
     */
    messageName?: string;
    /**
     * The correlation key of the message subscription.
     */
    correlationKey?: string;
    tenantId?: TenantId;
};

export type MessageSubscriptionSearchQuerySortRequest = {
    /**
     * The field to sort by.
     */
    field: 'messageSubscriptionKey' | 'processDefinitionId' | 'processInstanceKey' | 'elementId' | 'elementInstanceKey' | 'messageSubscriptionState' | 'lastUpdatedDate' | 'messageName' | 'correlationKey' | 'tenantId';
    order?: SortOrderEnum;
};

export type MessageSubscriptionSearchQuery = SearchQueryRequest & {
    /**
     * Sort field criteria.
     */
    sort?: Array<MessageSubscriptionSearchQuerySortRequest>;
    /**
     * The incident search filters.
     */
    filter?: MessageSubscriptionFilter;
};

/**
 * Message subscription search filter.
 */
export type MessageSubscriptionFilter = {
    /**
     * The message subscription key associated with this message subscription.
     */
    messageSubscriptionKey?: MessageSubscriptionKeyFilterProperty;
    /**
     * The process definition key associated with this correlated message subscription. This only works for data created with 8.9 and later.
     */
    processDefinitionKey?: ProcessDefinitionKeyFilterProperty;
    /**
     * The process definition ID associated with this message subscription.
     */
    processDefinitionId?: StringFilterProperty;
    /**
     * The process instance key associated with this message subscription.
     */
    processInstanceKey?: ProcessInstanceKeyFilterProperty;
    /**
     * The element ID associated with this message subscription.
     */
    elementId?: StringFilterProperty;
    /**
     * The element instance key associated with this message subscription.
     */
    elementInstanceKey?: ElementInstanceKeyFilterProperty;
    /**
     * The message subscription state.
     */
    messageSubscriptionState?: MessageSubscriptionStateFilterProperty;
    /**
     * The last updated date of the message subscription.
     */
    lastUpdatedDate?: DateTimeFilterProperty;
    /**
     * The name of the message associated with the message subscription.
     */
    messageName?: StringFilterProperty;
    /**
     * The correlation key of the message subscription.
     */
    correlationKey?: StringFilterProperty;
    /**
     * The unique external tenant ID.
     */
    tenantId?: StringFilterProperty;
};

export type CorrelatedMessageSubscriptionSearchQueryResult = SearchQueryResponse & {
    /**
     * The matching correlated message subscriptions.
     */
    items?: Array<CorrelatedMessageSubscriptionResult>;
};

export type CorrelatedMessageSubscriptionResult = {
    /**
     * The correlation key of the message.
     */
    correlationKey: string;
    /**
     * The time when the message was correlated.
     */
    correlationTime: string;
    /**
     * The element ID that received the message.
     */
    elementId: string;
    /**
     * The element instance key that received the message.
     */
    elementInstanceKey?: ElementInstanceKey;
    /**
     * The message key.
     */
    messageKey: MessageKey;
    /**
     * The name of the message.
     */
    messageName: string;
    /**
     * The partition ID that correlated the message.
     */
    partitionId: number;
    /**
     * The process definition ID associated with this correlated message subscription.
     */
    processDefinitionId: ProcessDefinitionId;
    /**
     * The process definition key associated with this correlated message subscription.
     */
    processDefinitionKey?: ProcessDefinitionKey;
    /**
     * The process instance key associated with this correlated message subscription.
     */
    processInstanceKey: ProcessInstanceKey;
    rootProcessInstanceKey?: RootProcessInstanceKey;
    /**
     * The subscription key that received the message.
     */
    subscriptionKey: MessageSubscriptionKey;
    /**
     * The tenant ID associated with this correlated message subscription.
     */
    tenantId: TenantId;
};

export type CorrelatedMessageSubscriptionSearchQuery = SearchQueryRequest & {
    /**
     * Sort field criteria.
     */
    sort?: Array<CorrelatedMessageSubscriptionSearchQuerySortRequest>;
    /**
     * The correlated message subscriptions search filters.
     */
    filter?: CorrelatedMessageSubscriptionFilter;
};

export type CorrelatedMessageSubscriptionSearchQuerySortRequest = {
    /**
     * The field to sort by.
     */
    field: 'correlationKey' | 'correlationTime' | 'elementId' | 'elementInstanceKey' | 'messageKey' | 'messageName' | 'partitionId' | 'processDefinitionId' | 'processDefinitionKey' | 'processInstanceKey' | 'subscriptionKey' | 'tenantId';
    order?: SortOrderEnum;
};

/**
 * The state of message subscription.
 */
export type MessageSubscriptionStateEnum = 'CORRELATED' | 'CREATED' | 'DELETED' | 'MIGRATED';

/**
 * Correlated message subscriptions search filter.
 */
export type CorrelatedMessageSubscriptionFilter = {
    /**
     * The correlation key of the message.
     */
    correlationKey?: StringFilterProperty;
    /**
     * The time when the message was correlated.
     */
    correlationTime?: DateTimeFilterProperty;
    /**
     * The element ID that received the message.
     */
    elementId?: StringFilterProperty;
    /**
     * The element instance key that received the message.
     */
    elementInstanceKey?: ElementInstanceKeyFilterProperty;
    /**
     * The message key.
     */
    messageKey?: BasicStringFilterProperty;
    /**
     * The name of the message.
     */
    messageName?: StringFilterProperty;
    /**
     * The partition ID that correlated the message.
     */
    partitionId?: IntegerFilterProperty;
    /**
     * The process definition ID associated with this correlated message subscription.
     */
    processDefinitionId?: StringFilterProperty;
    /**
     * The process definition key associated with this correlated message subscription. For intermediate message events, this only works for data created with 8.9 and later.
     */
    processDefinitionKey?: ProcessDefinitionKeyFilterProperty;
    /**
     * The process instance key associated with this correlated message subscription.
     */
    processInstanceKey?: ProcessInstanceKeyFilterProperty;
    /**
     * The subscription key that received the message.
     */
    subscriptionKey?: MessageSubscriptionKeyFilterProperty;
    /**
     * The tenant ID associated with this correlated message subscription.
     */
    tenantId?: StringFilterProperty;
};

/**
 * MessageSubscriptionStateEnum with full advanced search capabilities.
 */
export type MessageSubscriptionStateFilterProperty = MessageSubscriptionStateExactMatch | AdvancedMessageSubscriptionStateFilter;

/**
 * Advanced filter
 *
 * Advanced MessageSubscriptionStateEnum filter
 */
export type AdvancedMessageSubscriptionStateFilter = {
    /**
     * Checks for equality with the provided value.
     */
    $eq?: MessageSubscriptionStateEnum;
    /**
     * Checks for inequality with the provided value.
     */
    $neq?: MessageSubscriptionStateEnum;
    /**
     * Checks if the current property exists.
     */
    $exists?: boolean;
    /**
     * Checks if the property matches any of the provided values.
     */
    $in?: Array<MessageSubscriptionStateEnum>;
    $like?: LikeFilter;
};

/**
 * Advanced filter
 *
 * Advanced MessageSubscriptionKey filter.
 */
export type AdvancedMessageSubscriptionKeyFilter = {
    /**
     * Checks for equality with the provided value.
     */
    $eq?: MessageSubscriptionKey;
    /**
     * Checks for equality with the provided value.
     */
    $neq?: MessageSubscriptionKey;
    /**
     * Checks if the current property exists.
     */
    $exists?: boolean;
    /**
     * Checks if the property matches any of the provided values.
     */
    $in?: Array<MessageSubscriptionKey>;
    /**
     * Checks if the property matches none of the provided values.
     */
    $notIn?: Array<MessageSubscriptionKey>;
};

/**
 * MessageSubscriptionKey property with full advanced search capabilities.
 */
export type MessageSubscriptionKeyFilterProperty = MessageSubscriptionKeyExactMatch | AdvancedMessageSubscriptionKeyFilter;

/**
 * System-generated key for a message subscription.
 */
export type MessageSubscriptionKey = CamundaKey<'MessageSubscriptionKey'>;

/**
 * System-generated key for an message.
 */
export type MessageKey = CamundaKey<'MessageKey'>;

/**
 * A Problem detail object as described in [RFC 9457](https://www.rfc-editor.org/rfc/rfc9457). There may be additional properties specific to the problem type.
 *
 */
export type ProblemDetail = {
    /**
     * A URI identifying the problem type.
     */
    type?: string;
    /**
     * A summary of the problem type.
     */
    title?: string;
    /**
     * The HTTP status code for this problem.
     */
    status?: number;
    /**
     * An explanation of the problem in more detail.
     */
    detail?: string;
    /**
     * A URI path identifying the origin of the problem.
     */
    instance?: string;
};

export type ProcessDefinitionSearchQuerySortRequest = {
    /**
     * The field to sort by.
     */
    field: 'processDefinitionKey' | 'name' | 'resourceName' | 'version' | 'versionTag' | 'processDefinitionId' | 'tenantId';
    order?: SortOrderEnum;
};

export type ProcessDefinitionSearchQuery = SearchQueryRequest & {
    /**
     * Sort field criteria.
     */
    sort?: Array<ProcessDefinitionSearchQuerySortRequest>;
    /**
     * The process definition search filters.
     */
    filter?: ProcessDefinitionFilter;
};

/**
 * Process definition search filter.
 */
export type ProcessDefinitionFilter = {
    /**
     * Name of this process definition.
     */
    name?: StringFilterProperty;
    /**
     * Whether to only return the latest version of each process definition.
     * When using this filter, pagination functionality is limited, you can only paginate forward using `after` and `limit`.
     * The response contains no `startCursor` in the `page`, and requests ignore the `from` and `before` in the `page`.
     *
     */
    isLatestVersion?: boolean;
    /**
     * Resource name of this process definition.
     */
    resourceName?: string;
    /**
     * Version of this process definition.
     */
    version?: number;
    /**
     * Version tag of this process definition.
     */
    versionTag?: string;
    /**
     * Process definition ID of this process definition.
     */
    processDefinitionId?: StringFilterProperty;
    /**
     * Tenant ID of this process definition.
     */
    tenantId?: TenantId;
    /**
     * The key for this process definition.
     */
    processDefinitionKey?: ProcessDefinitionKey;
    /**
     * Indicates whether the start event of the process has an associated Form Key.
     */
    hasStartForm?: boolean;
};

export type ProcessDefinitionSearchQueryResult = SearchQueryResponse & {
    /**
     * The matching process definitions.
     */
    items?: Array<ProcessDefinitionResult>;
};

export type ProcessDefinitionResult = {
    /**
     * Name of this process definition.
     */
    name?: string;
    /**
     * Resource name for this process definition.
     */
    resourceName?: string;
    /**
     * Version of this process definition.
     */
    version?: number;
    /**
     * Version tag of this process definition.
     */
    versionTag?: string;
    /**
     * Process definition ID of this process definition.
     */
    processDefinitionId?: ProcessDefinitionId;
    /**
     * Tenant ID of this process definition.
     */
    tenantId?: TenantId;
    /**
     * The key for this process definition.
     */
    processDefinitionKey?: ProcessDefinitionKey;
    /**
     * Indicates whether the start event of the process has an associated Form Key.
     */
    hasStartForm?: boolean;
};

/**
 * Process definition element statistics request.
 */
export type ProcessDefinitionElementStatisticsQuery = {
    /**
     * The process definition statistics search filters.
     */
    filter?: ProcessDefinitionStatisticsFilter;
};

/**
 * Process definition element statistics query response.
 */
export type ProcessDefinitionElementStatisticsQueryResult = {
    /**
     * The element statistics.
     */
    items?: Array<ProcessElementStatisticsResult>;
};

/**
 * Process element statistics response.
 */
export type ProcessElementStatisticsResult = {
    /**
     * The element ID for which the results are aggregated.
     */
    elementId?: ElementId;
    /**
     * The total number of active instances of the element.
     */
    active?: number;
    /**
     * The total number of canceled instances of the element.
     */
    canceled?: number;
    /**
     * The total number of incidents for the element.
     */
    incidents?: number;
    /**
     * The total number of completed instances of the element.
     */
    completed?: number;
};

export type ProcessDefinitionMessageSubscriptionStatisticsQuery = {
    page?: CursorForwardPagination;
    /**
     * The message subscription filters.
     */
    filter?: MessageSubscriptionFilter;
};

export type ProcessDefinitionMessageSubscriptionStatisticsQueryResult = SearchQueryResponse & {
    /**
     * The matching process definition message subscription statistics.
     */
    items?: Array<ProcessDefinitionMessageSubscriptionStatisticsResult>;
};

export type ProcessDefinitionMessageSubscriptionStatisticsResult = {
    /**
     * The process definition ID associated with this message subscription.
     */
    processDefinitionId?: ProcessDefinitionId;
    /**
     * The tenant ID associated with this message subscription.
     */
    tenantId?: TenantId;
    /**
     * The process definition key associated with this message subscription.
     */
    processDefinitionKey?: ProcessDefinitionKey;
    /**
     * The number of process instances with active message subscriptions.
     */
    processInstancesWithActiveSubscriptions?: number;
    /**
     * The total number of active message subscriptions for this process definition key.
     */
    activeSubscriptions?: number;
};

export type ProcessDefinitionInstanceStatisticsQuery = {
    page?: OffsetPagination;
    /**
     * Sort field criteria.
     */
    sort?: Array<ProcessDefinitionInstanceStatisticsQuerySortRequest>;
};

export type ProcessDefinitionInstanceStatisticsQueryResult = SearchQueryResponse & {
    /**
     * The process definition instance statistics result.
     */
    items?: Array<ProcessDefinitionInstanceStatisticsResult>;
};

/**
 * Process definition instance statistics response.
 */
export type ProcessDefinitionInstanceStatisticsResult = {
    processDefinitionId?: ProcessDefinitionId;
    tenantId?: TenantId;
    /**
     * Name of the latest deployed process definition instance version.
     */
    latestProcessDefinitionName?: string;
    /**
     * Indicates whether multiple versions of this process definition instance are deployed.
     */
    hasMultipleVersions?: boolean;
    /**
     * Total number of currently active process instances of this definition that do not have incidents.
     */
    activeInstancesWithoutIncidentCount?: number;
    /**
     * Total number of currently active process instances of this definition that have at least one incident.
     */
    activeInstancesWithIncidentCount?: number;
};

export type ProcessDefinitionInstanceStatisticsQuerySortRequest = {
    /**
     * The field to sort by.
     */
    field: 'processDefinitionId' | 'activeInstancesWithIncidentCount' | 'activeInstancesWithoutIncidentCount';
    order?: SortOrderEnum;
};

export type ProcessDefinitionInstanceVersionStatisticsQuery = {
    /**
     * Pagination criteria.
     */
    page?: OffsetPagination;
    /**
     * Sort field criteria.
     */
    sort?: Array<ProcessDefinitionInstanceVersionStatisticsQuerySortRequest>;
    /**
     * The process definition instance version statistics search filters.
     */
    filter: ProcessDefinitionInstanceVersionStatisticsFilter;
};

/**
 * Process definition instance version statistics search filter.
 */
export type ProcessDefinitionInstanceVersionStatisticsFilter = {
    /**
     * The ID of the process definition to retrieve version statistics for.
     */
    processDefinitionId: ProcessDefinitionId;
    /**
     * Tenant ID of this process definition.
     */
    tenantId?: TenantId;
};

export type ProcessDefinitionInstanceVersionStatisticsQueryResult = SearchQueryResponse & {
    /**
     * The process definition instance version statistics result.
     */
    items?: Array<ProcessDefinitionInstanceVersionStatisticsResult>;
};

/**
 * Process definition instance version statistics response.
 */
export type ProcessDefinitionInstanceVersionStatisticsResult = {
    /**
     * The ID associated with the process definition.
     */
    processDefinitionId: ProcessDefinitionId;
    /**
     * The unique key of the process definition.
     */
    processDefinitionKey: ProcessDefinitionKey;
    /**
     * The name of the process definition.
     */
    processDefinitionName: string;
    /**
     * The tenant ID associated with the process definition.
     */
    tenantId: TenantId;
    /**
     * The version number of the process definition.
     */
    processDefinitionVersion: number;
    /**
     * The number of active process instances for this version that currently have incidents.
     */
    activeInstancesWithIncidentCount: number;
    /**
     * The number of active process instances for this version that do not have any incidents.
     */
    activeInstancesWithoutIncidentCount: number;
};

export type ProcessDefinitionInstanceVersionStatisticsQuerySortRequest = {
    /**
     * The field to sort by.
     */
    field: 'processDefinitionId' | 'processDefinitionKey' | 'processDefinitionName' | 'processDefinitionVersion' | 'activeInstancesWithIncidentCount' | 'activeInstancesWithoutIncidentCount';
    order?: SortOrderEnum;
};

/**
 * Instructions for creating a process instance. The process definition can be specified
 * either by id or by key.
 *
 */
export type ProcessInstanceCreationInstruction = ProcessInstanceCreationInstructionById | ProcessInstanceCreationInstructionByKey;

/**
 * Process creation by id
 */
export type ProcessInstanceCreationInstructionById = {
    /**
     * The BPMN process id of the process definition to start an instance of.
     *
     */
    processDefinitionId: ProcessDefinitionId;
    /**
     * The version of the process. By default, the latest version of the process is used.
     *
     */
    processDefinitionVersion?: number;
    /**
     * JSON object that will instantiate the variables for the root variable scope
     * of the process instance.
     *
     */
    variables?: {
        [key: string]: unknown;
    };
    /**
     * The tenant id of the process definition.
     */
    tenantId?: TenantId;
    operationReference?: OperationReference;
    /**
     * List of start instructions. By default, the process instance will start at
     * the start event. If provided, the process instance will apply start instructions
     * after it has been created.
     *
     */
    startInstructions?: Array<ProcessInstanceCreationStartInstruction>;
    /**
     * Runtime instructions (alpha). List of instructions that affect the runtime behavior of
     * the process instance. Refer to specific instruction types for more details.
     *
     * This parameter is an alpha feature and may be subject to change
     * in future releases.
     *
     */
    runtimeInstructions?: Array<ProcessInstanceCreationRuntimeInstruction>;
    /**
     * Wait for the process instance to complete. If the process instance completion does
     * not occur within the requestTimeout, the request will be closed. This can lead to a 504
     * response status. Disabled by default.
     *
     */
    awaitCompletion?: boolean;
    /**
     * List of variables by name to be included in the response when awaitCompletion is set to true.
     * If empty, all visible variables in the root scope will be returned.
     *
     */
    fetchVariables?: Array<string>;
    /**
     * Timeout (in ms) the request waits for the process to complete. By default or
     * when set to 0, the generic request timeout configured in the cluster is applied.
     *
     */
    requestTimeout?: number;
    tags?: TagSet;
};

/**
 * Process creation by key
 */
export type ProcessInstanceCreationInstructionByKey = {
    /**
     * The unique key identifying the process definition, for example, returned for a process in the
     * deploy resources endpoint.
     *
     */
    processDefinitionKey: ProcessDefinitionKey;
    /**
     * As the version is already identified by the `processDefinitionKey`, the value of this field is ignored.
     * It's here for backwards-compatibility only as previous releases accepted it in request bodies.
     *
     */
    processDefinitionVersion?: number;
    /**
     * JSON object that will instantiate the variables for the root variable scope
     * of the process instance.
     *
     */
    variables?: {
        [key: string]: unknown;
    };
    /**
     * List of start instructions. By default, the process instance will start at
     * the start event. If provided, the process instance will apply start instructions
     * after it has been created.
     *
     */
    startInstructions?: Array<ProcessInstanceCreationStartInstruction>;
    /**
     * Runtime instructions (alpha). List of instructions that affect the runtime behavior of
     * the process instance. Refer to specific instruction types for more details.
     *
     * This parameter is an alpha feature and may be subject to change
     * in future releases.
     *
     */
    runtimeInstructions?: Array<ProcessInstanceCreationRuntimeInstruction>;
    /**
     * The tenant id of the process definition.
     */
    tenantId?: TenantId;
    operationReference?: OperationReference;
    /**
     * Wait for the process instance to complete. If the process instance completion does
     * not occur within the requestTimeout, the request will be closed. This can lead to a 504
     * response status. Disabled by default.
     *
     */
    awaitCompletion?: boolean;
    /**
     * Timeout (in ms) the request waits for the process to complete. By default or
     * when set to 0, the generic request timeout configured in the cluster is applied.
     *
     */
    requestTimeout?: number;
    /**
     * List of variables by name to be included in the response when awaitCompletion is set to true.
     * If empty, all visible variables in the root scope will be returned.
     *
     */
    fetchVariables?: Array<string>;
    tags?: TagSet;
};

export type ProcessInstanceCreationStartInstruction = {
    /**
     * Future extensions might include:
     * - different types of start instructions
     * - ability to set local variables for different flow scopes
     *
     * For now, however, the start instruction is implicitly a "startBeforeElement" instruction
     *
     */
    elementId: ElementId;
};

export type ProcessInstanceCreationRuntimeInstruction = {
    type: 'TERMINATE_PROCESS_INSTANCE';
} & ProcessInstanceCreationTerminateInstruction;

/**
 * Terminates the process instance after a specific BPMN element is completed or terminated.
 *
 */
export type ProcessInstanceCreationTerminateInstruction = {
    /**
     * The type of the runtime instruction
     */
    type?: string;
    /**
     * The id of the element that, once completed or terminated, will cause the process to be terminated.
     *
     */
    afterElementId: ElementId;
};

export type CreateProcessInstanceResult = {
    /**
     * The BPMN process id of the process definition which was used to create the process.
     * instance
     *
     */
    processDefinitionId: ProcessDefinitionId;
    /**
     * The version of the process definition which was used to create the process instance.
     *
     */
    processDefinitionVersion: number;
    /**
     * The tenant id of the created process instance.
     */
    tenantId: TenantId;
    /**
     * All the variables visible in the root scope.
     */
    variables: {
        [key: string]: unknown;
    };
    /**
     * The key of the process definition which was used to create the process instance.
     *
     */
    processDefinitionKey: ProcessDefinitionKey;
    /**
     * The unique identifier of the created process instance; to be used wherever a request
     * needs a process instance key (e.g. CancelProcessInstanceRequest).
     *
     */
    processInstanceKey: ProcessInstanceKey;
    tags?: TagSet;
};

export type ProcessInstanceSearchQuerySortRequest = {
    /**
     * The field to sort by.
     */
    field: 'processInstanceKey' | 'processDefinitionId' | 'processDefinitionName' | 'processDefinitionVersion' | 'processDefinitionVersionTag' | 'processDefinitionKey' | 'parentProcessInstanceKey' | 'parentElementInstanceKey' | 'startDate' | 'endDate' | 'state' | 'hasIncident' | 'tenantId';
    order?: SortOrderEnum;
};

/**
 * Process instance search request.
 */
export type ProcessInstanceSearchQuery = SearchQueryRequest & {
    /**
     * Sort field criteria.
     */
    sort?: Array<ProcessInstanceSearchQuerySortRequest>;
    /**
     * The process instance search filters.
     */
    filter?: ProcessInstanceFilter;
};

/**
 * Base process instance search filter.
 */
export type BaseProcessInstanceFilterFields = {
    /**
     * The start date.
     */
    startDate?: DateTimeFilterProperty;
    /**
     * The end date.
     */
    endDate?: DateTimeFilterProperty;
    /**
     * The process instance state.
     */
    state?: ProcessInstanceStateFilterProperty;
    /**
     * Whether this process instance has a related incident or not.
     */
    hasIncident?: boolean;
    /**
     * The tenant id.
     */
    tenantId?: StringFilterProperty;
    /**
     * The process instance variables.
     */
    variables?: Array<VariableValueFilterProperty>;
    /**
     * The key of this process instance.
     */
    processInstanceKey?: ProcessInstanceKeyFilterProperty;
    /**
     * The parent process instance key.
     */
    parentProcessInstanceKey?: ProcessInstanceKeyFilterProperty;
    /**
     * The parent element instance key.
     */
    parentElementInstanceKey?: ElementInstanceKeyFilterProperty;
    /**
     * The batch operation id.
     */
    batchOperationId?: StringFilterProperty;
    /**
     * The error message related to the process.
     */
    errorMessage?: StringFilterProperty;
    /**
     * Whether the process has failed jobs with retries left.
     */
    hasRetriesLeft?: boolean;
    /**
     * The state of the element instances associated with the process instance.
     */
    elementInstanceState?: ElementInstanceStateFilterProperty;
    /**
     * The element id associated with the process instance.
     */
    elementId?: StringFilterProperty;
    /**
     * Whether the element instance has an incident or not.
     */
    hasElementInstanceIncident?: boolean;
    /**
     * The incident error hash code, associated with this process.
     */
    incidentErrorHashCode?: IntegerFilterProperty;
    tags?: TagSet;
};

/**
 * Process definition statistics search filter.
 */
export type ProcessDefinitionStatisticsFilter = BaseProcessInstanceFilterFields & {
    /**
     * Defines a list of alternative filter groups combined using OR logic. Each object in the array is evaluated independently, and the filter matches if any one of them is satisfied.
     *
     * Top-level fields and the `$or` clause are combined using AND logic  meaning: (top-level filters) AND (any of the `$or` filters) must match.
     * <br>
     * <em>Example:</em>
     *
     * ```json
     * {
     * "state": "ACTIVE",
     * "tenantId": 123,
     * "$or": [
     * { "processDefinitionId": "process_v1" },
     * { "processDefinitionId": "process_v2", "hasIncident": true }
     * ]
     * }
     * ```
     * This matches process instances that:
     *
     * <ul style="padding-left: 20px; margin-left: 20px;">
     * <li style="list-style-type: disc;">are in <em>ACTIVE</em> state</li>
     * <li style="list-style-type: disc;">have tenant id equal to <em>123</em></li>
     * <li style="list-style-type: disc;">and match either:
     * <ul style="padding-left: 20px; margin-left: 20px;">
     * <li style="list-style-type: circle;"><code>processDefinitionId</code> is <em>process_v1</em>, or</li>
     * <li style="list-style-type: circle;"><code>processDefinitionId</code> is <em>process_v2</em> and <code>hasIncident</code> is <em>true</em></li>
     * </ul>
     * </li>
     * </ul>
     * <br>
     * <p>Note: Using complex <code>$or</code> conditions may impact performance, use with caution in high-volume environments.
     *
     */
    $or?: Array<BaseProcessInstanceFilterFields>;
};

/**
 * Process instance search filter.
 */
export type ProcessInstanceFilterFields = BaseProcessInstanceFilterFields & {
    /**
     * The process definition id.
     */
    processDefinitionId?: StringFilterProperty;
    /**
     * The process definition name.
     */
    processDefinitionName?: StringFilterProperty;
    /**
     * The process definition version.
     */
    processDefinitionVersion?: IntegerFilterProperty;
    /**
     * The process definition version tag.
     */
    processDefinitionVersionTag?: StringFilterProperty;
    /**
     * The process definition key.
     */
    processDefinitionKey?: ProcessDefinitionKeyFilterProperty;
};

/**
 * Process instance search filter.
 */
export type ProcessInstanceFilter = ProcessInstanceFilterFields & {
    /**
     * Defines a list of alternative filter groups combined using OR logic. Each object in the array is evaluated independently, and the filter matches if any one of them is satisfied.
     *
     * Top-level fields and the `$or` clause are combined using AND logic  meaning: (top-level filters) AND (any of the `$or` filters) must match.
     * <br>
     * <em>Example:</em>
     *
     * ```json
     * {
     * "state": "ACTIVE",
     * "tenantId": 123,
     * "$or": [
     * { "processDefinitionId": "process_v1" },
     * { "processDefinitionId": "process_v2", "hasIncident": true }
     * ]
     * }
     * ```
     * This matches process instances that:
     *
     * <ul style="padding-left: 20px; margin-left: 20px;">
     * <li style="list-style-type: disc;">are in <em>ACTIVE</em> state</li>
     * <li style="list-style-type: disc;">have tenant id equal to <em>123</em></li>
     * <li style="list-style-type: disc;">and match either:
     * <ul style="padding-left: 20px; margin-left: 20px;">
     * <li style="list-style-type: circle;"><code>processDefinitionId</code> is <em>process_v1</em>, or</li>
     * <li style="list-style-type: circle;"><code>processDefinitionId</code> is <em>process_v2</em> and <code>hasIncident</code> is <em>true</em></li>
     * </ul>
     * </li>
     * </ul>
     * <br>
     * <p>Note: Using complex <code>$or</code> conditions may impact performance, use with caution in high-volume environments.
     *
     */
    $or?: Array<ProcessInstanceFilterFields>;
};

/**
 * Process instance search response.
 */
export type ProcessInstanceSearchQueryResult = SearchQueryResponse & {
    /**
     * The matching process instances.
     */
    items: Array<ProcessInstanceResult>;
};

/**
 * Process instance search response item.
 */
export type ProcessInstanceResult = {
    processDefinitionId: ProcessDefinitionId;
    /**
     * The process definition name.
     */
    processDefinitionName: string;
    processDefinitionVersion: number;
    /**
     * The process definition version tag.
     */
    processDefinitionVersionTag?: string;
    startDate: string;
    endDate?: string;
    state: ProcessInstanceStateEnum;
    /**
     * Whether this process instance has a related incident or not.
     */
    hasIncident: boolean;
    tenantId: TenantId;
    /**
     * The key of this process instance.
     */
    processInstanceKey: ProcessInstanceKey;
    /**
     * The process definition key.
     */
    processDefinitionKey: ProcessDefinitionKey;
    /**
     * The parent process instance key.
     */
    parentProcessInstanceKey?: ProcessInstanceKey;
    /**
     * The parent element instance key.
     */
    parentElementInstanceKey?: ElementInstanceKey;
    rootProcessInstanceKey?: RootProcessInstanceKey;
    tags?: TagSet;
};

export type CancelProcessInstanceRequest = {
    operationReference?: OperationReference;
} | null;

export type DeleteProcessInstanceRequest = {
    operationReference?: OperationReference;
} | null;

export type ProcessInstanceCallHierarchyEntry = {
    /**
     * The key of the process instance.
     */
    processInstanceKey: ProcessInstanceKey;
    /**
     * The key of the process definition.
     */
    processDefinitionKey: ProcessDefinitionKey;
    /**
     * The name of the process definition (fall backs to the process definition id if not available).
     */
    processDefinitionName: string;
};

/**
 * Process instance sequence flows query response.
 */
export type ProcessInstanceSequenceFlowsQueryResult = {
    /**
     * The sequence flows.
     */
    items?: Array<ProcessInstanceSequenceFlowResult>;
};

/**
 * Process instance sequence flow result.
 */
export type ProcessInstanceSequenceFlowResult = {
    /**
     * The sequence flow id.
     */
    sequenceFlowId?: string;
    /**
     * The key of this process instance.
     */
    processInstanceKey?: ProcessInstanceKey;
    rootProcessInstanceKey?: RootProcessInstanceKey;
    /**
     * The process definition key.
     */
    processDefinitionKey?: ProcessDefinitionKey;
    /**
     * The process definition id.
     */
    processDefinitionId?: ProcessDefinitionId;
    /**
     * The element id for this sequence flow, as provided in the BPMN process.
     */
    elementId?: ElementId;
    tenantId?: TenantId;
};

/**
 * Process instance element statistics query response.
 */
export type ProcessInstanceElementStatisticsQueryResult = {
    /**
     * The element statistics.
     */
    items?: Array<ProcessElementStatisticsResult>;
};

/**
 * The migration instructions describe how to migrate a process instance from one process definition to another.
 *
 */
export type ProcessInstanceMigrationInstruction = {
    /**
     * The key of process definition to migrate the process instance to.
     */
    targetProcessDefinitionKey: ProcessDefinitionKey;
    /**
     * Element mappings from the source process instance to the target process instance.
     */
    mappingInstructions: Array<MigrateProcessInstanceMappingInstruction>;
    operationReference?: OperationReference;
};

/**
 * The mapping instructions describe how to map elements from the source process definition to the target process definition.
 *
 */
export type MigrateProcessInstanceMappingInstruction = {
    /**
     * The element id to migrate from.
     */
    sourceElementId: ElementId;
    /**
     * The element id to migrate into.
     */
    targetElementId: ElementId;
};

export type ProcessInstanceModificationInstruction = {
    operationReference?: OperationReference;
    /**
     * Instructions describing which elements to activate in which scopes and which variables to create or update.
     */
    activateInstructions?: Array<ProcessInstanceModificationActivateInstruction>;
    /**
     * Instructions describing which elements to move from one scope to another.
     */
    moveInstructions?: Array<ProcessInstanceModificationMoveInstruction>;
    /**
     * Instructions describing which elements to terminate.
     */
    terminateInstructions?: Array<ProcessInstanceModificationTerminateInstruction>;
};

/**
 * Instruction describing an element to activate.
 */
export type ProcessInstanceModificationActivateInstruction = {
    /**
     * The id of the element to activate.
     */
    elementId: ElementId;
    /**
     * Instructions describing which variables to create or update.
     */
    variableInstructions?: Array<ModifyProcessInstanceVariableInstruction>;
    /**
     * The key of the ancestor scope the element instance should be created in.
     * Set to -1 to create the new element instance within an existing element instance of the
     * flow scope. If multiple instances of the target element's flow scope exist, choose one
     * specifically with this property by providing its key.
     *
     */
    ancestorElementInstanceKey?: string | ElementInstanceKey;
};

/**
 * Instruction describing which variables to create or update.
 */
export type ModifyProcessInstanceVariableInstruction = {
    /**
     * JSON document that will instantiate the variables at the scope defined by the scopeId.
     * It must be a JSON object, as variables will be mapped in a key-value fashion.
     *
     */
    variables: {
        [key: string]: unknown;
    };
    /**
     * The id of the element in which scope the variables should be created.
     * Leave empty to create the variables in the global scope of the process instance.
     *
     */
    scopeId?: string;
};

/**
 * Instruction describing a move operation. This instruction will terminate active element
 * instances based on the sourceElementInstruction and activate a new element instance for each terminated
 * one at targetElementId. Note that, for multi-instance activities, only the multi-instance
 * body instances will activate new element instances at the target id.
 *
 */
export type ProcessInstanceModificationMoveInstruction = {
    sourceElementInstruction: SourceElementInstruction;
    /**
     * The target element id.
     */
    targetElementId: ElementId;
    ancestorScopeInstruction?: AncestorScopeInstruction;
    /**
     * Instructions describing which variables to create or update.
     */
    variableInstructions?: Array<ModifyProcessInstanceVariableInstruction>;
};

/**
 * Defines the source element identifier for the move instruction. It can either be a sourceElementId, or sourceElementInstanceKey.
 *
 */
export type SourceElementInstruction = ({
    sourceType: 'byId';
} & SourceElementIdInstruction) | ({
    sourceType: 'byKey';
} & SourceElementInstanceKeyInstruction);

/**
 * Defines an instruction with a sourceElementId. The move instruction with this sourceType will terminate all active element
 * instances with the sourceElementId and activate a new element instance for each terminated
 * one at targetElementId.
 *
 */
export type SourceElementIdInstruction = {
    /**
     * The type of source element instruction.
     */
    sourceType: string;
    /**
     * The id of the source element for the move instruction.
     *
     */
    sourceElementId: ElementId;
};

/**
 * Defines an instruction with a sourceElementInstanceKey. The move instruction with this sourceType will terminate one active element
 * instance with the sourceElementInstanceKey and activate a new element instance at targetElementId.
 *
 */
export type SourceElementInstanceKeyInstruction = {
    /**
     * The type of source element instruction.
     */
    sourceType: string;
    /**
     * The source element instance key for the move instruction.
     *
     */
    sourceElementInstanceKey: ElementInstanceKey;
};

/**
 * Defines the ancestor scope for the created element instances. The default behavior resembles
 * a "direct" scope instruction with an `ancestorElementInstanceKey` of `"-1"`.
 *
 */
export type AncestorScopeInstruction = ({
    ancestorScopeType: 'direct';
} & DirectAncestorKeyInstruction) | ({
    ancestorScopeType: 'inferred';
} & InferredAncestorKeyInstruction) | ({
    ancestorScopeType: 'sourceParent';
} & UseSourceParentKeyInstruction);

/**
 * Provides a concrete key to use as ancestor scope for the created element instance.
 */
export type DirectAncestorKeyInstruction = {
    /**
     * The type of ancestor scope instruction.
     */
    ancestorScopeType: string;
    /**
     * The key of the ancestor scope the element instance should be created in.
     * Set to -1 to create the new element instance within an existing element instance of the
     * flow scope. If multiple instances of the target element's flow scope exist, choose one
     * specifically with this property by providing its key.
     *
     */
    ancestorElementInstanceKey: string | ElementInstanceKey;
};

/**
 * Instructs the engine to derive the ancestor scope key from the source element's hierarchy. The engine traverses the source element's ancestry to find an instance that matches one of the target element's flow scopes, ensuring the target is activated in the correct scope.
 *
 */
export type InferredAncestorKeyInstruction = {
    /**
     * The type of ancestor scope instruction.
     */
    ancestorScopeType: string;
};

/**
 * Instructs the engine to use the source's direct parent key as the ancestor scope key for the target element. This is a simpler alternative to `inferred` that skips hierarchy traversal and directly uses the source's parent key. This is useful when the source and target elements are siblings within the same flow scope.
 *
 */
export type UseSourceParentKeyInstruction = {
    /**
     * The type of ancestor scope instruction.
     */
    ancestorScopeType: string;
};

/**
 * Instruction describing which elements to terminate.
 */
export type ProcessInstanceModificationTerminateInstruction = ProcessInstanceModificationTerminateByIdInstruction | ProcessInstanceModificationTerminateByKeyInstruction;

/**
 * Instruction describing which elements to terminate. The element instances are determined
 * at runtime by the given id.
 *
 */
export type ProcessInstanceModificationTerminateByIdInstruction = {
    /**
     * The id of the elements to terminate. The element instances are determined at runtime.
     */
    elementId: ElementId;
};

/**
 * Instruction providing the key of the element instance to terminate.
 */
export type ProcessInstanceModificationTerminateByKeyInstruction = {
    /**
     * The key of the element instance to terminate.
     */
    elementInstanceKey: ElementInstanceKey;
};

/**
 * Process instance states
 */
export type ProcessInstanceStateEnum = 'ACTIVE' | 'COMPLETED' | 'TERMINATED';

/**
 * Advanced filter
 *
 * Advanced ProcessInstanceStateEnum filter.
 */
export type AdvancedProcessInstanceStateFilter = {
    /**
     * Checks for equality with the provided value.
     */
    $eq?: ProcessInstanceStateEnum;
    /**
     * Checks for inequality with the provided value.
     */
    $neq?: ProcessInstanceStateEnum;
    /**
     * Checks if the current property exists.
     */
    $exists?: boolean;
    /**
     * Checks if the property matches any of the provided values.
     */
    $in?: Array<ProcessInstanceStateEnum>;
    $like?: LikeFilter;
};

/**
 * ProcessInstanceStateEnum property with full advanced search capabilities.
 */
export type ProcessInstanceStateFilterProperty = ProcessInstanceStateExactMatch | AdvancedProcessInstanceStateFilter;

export type RoleCreateRequest = {
    /**
     * The ID of the new role.
     */
    roleId: string;
    /**
     * The display name of the new role.
     */
    name: string;
    /**
     * The description of the new role.
     */
    description?: string;
};

export type RoleCreateResult = {
    /**
     * The ID of the created role.
     */
    roleId?: string;
    /**
     * The display name of the created role.
     */
    name?: string;
    /**
     * The description of the created role.
     */
    description?: string;
};

export type RoleUpdateRequest = {
    /**
     * The display name of the new role.
     */
    name: string;
    /**
     * The description of the new role.
     */
    description?: string;
};

export type RoleUpdateResult = {
    /**
     * The display name of the updated role.
     */
    name?: string;
    /**
     * The description of the updated role.
     */
    description?: string;
    /**
     * The ID of the updated role.
     */
    roleId?: string;
};

/**
 * Role search response item.
 */
export type RoleResult = {
    /**
     * The role name.
     */
    name?: string;
    /**
     * The role id.
     */
    roleId?: string;
    /**
     * The description of the role.
     */
    description?: string;
};

export type RoleSearchQuerySortRequest = {
    /**
     * The field to sort by.
     */
    field: 'name' | 'roleId';
    order?: SortOrderEnum;
};

/**
 * Role search request.
 */
export type RoleSearchQueryRequest = SearchQueryRequest & {
    /**
     * Sort field criteria.
     */
    sort?: Array<RoleSearchQuerySortRequest>;
    /**
     * The role search filters.
     */
    filter?: RoleFilter;
};

/**
 * Role filter request
 */
export type RoleFilter = {
    /**
     * The role ID search filters.
     */
    roleId?: string;
    /**
     * The role name search filters.
     */
    name?: string;
};

/**
 * Role search response.
 */
export type RoleSearchQueryResult = SearchQueryResponse & {
    /**
     * The matching roles.
     */
    items?: Array<RoleResult>;
};

export type RoleUserResult = {
    username?: Username;
};

export type RoleUserSearchResult = SearchQueryResponse & {
    /**
     * The matching users.
     */
    items?: Array<RoleUserResult>;
};

export type RoleUserSearchQueryRequest = SearchQueryRequest & {
    /**
     * Sort field criteria.
     */
    sort?: Array<RoleUserSearchQuerySortRequest>;
};

export type RoleUserSearchQuerySortRequest = {
    /**
     * The field to sort by.
     */
    field: 'username';
    order?: SortOrderEnum;
};

export type RoleClientResult = {
    /**
     * The ID of the client.
     */
    clientId?: string;
};

export type RoleClientSearchResult = SearchQueryResponse & {
    /**
     * The matching clients.
     */
    items?: Array<RoleClientResult>;
};

export type RoleClientSearchQueryRequest = SearchQueryRequest & {
    /**
     * Sort field criteria.
     */
    sort?: Array<RoleClientSearchQuerySortRequest>;
};

export type RoleClientSearchQuerySortRequest = {
    /**
     * The field to sort by.
     */
    field: 'clientId';
    order?: SortOrderEnum;
};

export type RoleGroupResult = {
    /**
     * The id of the group.
     */
    groupId?: string;
};

export type RoleGroupSearchResult = SearchQueryResponse & {
    /**
     * The matching groups.
     */
    items?: Array<RoleGroupResult>;
};

export type RoleGroupSearchQueryRequest = SearchQueryRequest & {
    /**
     * Sort field criteria.
     */
    sort?: Array<RoleGroupSearchQuerySortRequest>;
};

export type RoleGroupSearchQuerySortRequest = {
    /**
     * The field to sort by.
     */
    field: 'groupId';
    order?: SortOrderEnum;
};

export type SearchQueryRequest = {
    /**
     * Pagination criteria.
     */
    page?: SearchQueryPageRequest;
};

/**
 * Pagination criteria. Can use offset-based pagination (from/limit) OR cursor-based pagination (after/before + limit), but not both.
 */
export type SearchQueryPageRequest = LimitPagination | OffsetPagination | CursorForwardPagination | CursorBackwardPagination;

/**
 * Limit-based pagination
 */
export type LimitPagination = {
    /**
     * The maximum number of items to return in one request.
     */
    limit?: number;
};

/**
 * Offset-based pagination
 */
export type OffsetPagination = {
    /**
     * The index of items to start searching from.
     */
    from?: number;
    /**
     * The maximum number of items to return in one request.
     */
    limit?: number;
};

/**
 * Cursor-based forward pagination
 */
export type CursorForwardPagination = {
    /**
     * Use the `endCursor` value from the previous response to fetch the next page of results.
     */
    after: EndCursor;
    /**
     * The maximum number of items to return in one request.
     */
    limit?: number;
};

/**
 * Cursor-based backward pagination
 */
export type CursorBackwardPagination = {
    /**
     * Use the `startCursor` value from the previous response to fetch the previous page of results.
     */
    before: StartCursor;
    /**
     * The maximum number of items to return in one request.
     */
    limit?: number;
};

export type SearchQueryResponse = {
    page: SearchQueryPageResponse;
};

/**
 * The order in which to sort the related field.
 */
export type SortOrderEnum = 'ASC' | 'DESC';

/**
 * Pagination information about the search results.
 */
export type SearchQueryPageResponse = {
    /**
     * Total items matching the criteria.
     */
    totalItems: number;
    /**
     * Indicates whether there are more items matching the criteria beyond the returned items.
     * This is useful for determining if additional requests are needed to retrieve all results.
     *
     */
    hasMoreTotalItems?: boolean;
    /**
     * The cursor value for getting the previous page of results. Use this in the `before` field of an ensuing request.
     */
    startCursor?: StartCursor;
    /**
     * The cursor value for getting the next page of results. Use this in the `after` field of an ensuing request.
     */
    endCursor?: EndCursor;
};

export type SignalBroadcastRequest = {
    /**
     * The name of the signal to broadcast.
     */
    signalName: string;
    /**
     * The signal variables as a JSON object.
     */
    variables?: {
        [key: string]: unknown;
    };
    /**
     * The ID of the tenant that owns the signal.
     */
    tenantId?: TenantId;
};

export type SignalBroadcastResult = {
    /**
     * The tenant ID of the signal that was broadcast.
     */
    tenantId: TenantId;
    /**
     * The key of the broadcasted signal.
     */
    signalKey: SignalKey;
};

/**
 * System-generated key for an signal.
 */
export type SignalKey = CamundaKey<'SignalKey'>;

export type UsageMetricsResponse = UsageMetricsResponseItem & {
    /**
     * The amount of active tenants.
     */
    activeTenants?: number;
    /**
     * The usage metrics by tenants. Only available if request `withTenants` query parameter was `true`.
     */
    tenants?: {
        [key: string]: UsageMetricsResponseItem;
    };
};

export type UsageMetricsResponseItem = {
    /**
     * The amount of created root process instances.
     */
    processInstances?: number;
    /**
     * The amount of executed decision instances.
     */
    decisionInstances?: number;
    /**
     * The amount of unique active task users.
     */
    assignees?: number;
};

export type TenantCreateRequest = {
    /**
     * The unique ID for the tenant. Must be 255 characters or less. Can contain letters, numbers, [`_`, `-`, `+`, `.`, `@`].
     */
    tenantId: string;
    /**
     * The name of the tenant.
     */
    name: string;
    /**
     * The description of the tenant.
     */
    description?: string;
};

export type TenantCreateResult = {
    tenantId?: TenantId;
    /**
     * The name of the tenant.
     */
    name?: string;
    /**
     * The description of the tenant.
     */
    description?: string;
};

export type TenantUpdateRequest = {
    /**
     * The new name of the tenant.
     */
    name: string;
    /**
     * The new description of the tenant.
     */
    description?: string;
};

export type TenantUpdateResult = {
    tenantId?: TenantId;
    /**
     * The name of the tenant.
     */
    name?: string;
    /**
     * The description of the tenant.
     */
    description?: string;
};

/**
 * Tenant search response item.
 */
export type TenantResult = {
    /**
     * The tenant name.
     */
    name?: string;
    tenantId?: TenantId;
    /**
     * The tenant description.
     */
    description?: string;
};

export type TenantSearchQuerySortRequest = {
    /**
     * The field to sort by.
     */
    field: 'key' | 'name' | 'tenantId';
    order?: SortOrderEnum;
};

/**
 * Tenant search request
 */
export type TenantSearchQueryRequest = SearchQueryRequest & {
    /**
     * Sort field criteria.
     */
    sort?: Array<TenantSearchQuerySortRequest>;
    /**
     * The tenant search filters.
     */
    filter?: TenantFilter;
};

/**
 * Tenant filter request
 */
export type TenantFilter = {
    tenantId?: TenantId;
    /**
     * The name of the tenant.
     */
    name?: string;
};

/**
 * Tenant search response.
 */
export type TenantSearchQueryResult = SearchQueryResponse & {
    /**
     * The matching tenants.
     */
    items?: Array<TenantResult>;
};

export type TenantUserResult = {
    username?: Username;
};

export type TenantUserSearchResult = SearchQueryResponse & {
    /**
     * The matching users.
     */
    items?: Array<TenantUserResult>;
};

export type TenantUserSearchQueryRequest = SearchQueryRequest & {
    /**
     * Sort field criteria.
     */
    sort?: Array<TenantUserSearchQuerySortRequest>;
};

export type TenantUserSearchQuerySortRequest = {
    /**
     * The field to sort by.
     */
    field: 'username';
    order?: SortOrderEnum;
};

export type TenantClientResult = {
    /**
     * The ID of the client.
     */
    clientId?: string;
};

export type TenantClientSearchResult = SearchQueryResponse & {
    /**
     * The matching clients.
     */
    items?: Array<TenantClientResult>;
};

export type TenantClientSearchQueryRequest = SearchQueryRequest & {
    /**
     * Sort field criteria.
     */
    sort?: Array<TenantClientSearchQuerySortRequest>;
};

export type TenantClientSearchQuerySortRequest = {
    /**
     * The field to sort by.
     */
    field: 'clientId';
    order?: SortOrderEnum;
};

export type TenantGroupResult = {
    /**
     * The groupId of the group.
     */
    groupId?: string;
};

export type TenantGroupSearchResult = SearchQueryResponse & {
    /**
     * The matching groups.
     */
    items?: Array<TenantGroupResult>;
};

export type TenantGroupSearchQueryRequest = SearchQueryRequest & {
    /**
     * Sort field criteria.
     */
    sort?: Array<TenantGroupSearchQuerySortRequest>;
};

export type TenantGroupSearchQuerySortRequest = {
    /**
     * The field to sort by.
     */
    field: 'groupId';
    order?: SortOrderEnum;
};

export type UserTaskSearchQuerySortRequest = {
    /**
     * The field to sort by.
     */
    field: 'creationDate' | 'completionDate' | 'followUpDate' | 'dueDate' | 'priority' | 'name';
    order?: SortOrderEnum;
};

/**
 * User task search query request.
 */
export type UserTaskSearchQuery = SearchQueryRequest & {
    /**
     * Sort field criteria.
     */
    sort?: Array<UserTaskSearchQuerySortRequest>;
    /**
     * The user task search filters.
     */
    filter?: UserTaskFilter;
};

/**
 * User task filter request.
 */
export type UserTaskFilter = {
    /**
     * The user task state.
     */
    state?: UserTaskStateFilterProperty;
    /**
     * The assignee of the user task.
     */
    assignee?: StringFilterProperty;
    /**
     * The priority of the user task.
     */
    priority?: IntegerFilterProperty;
    /**
     * The element ID of the user task.
     */
    elementId?: ElementId;
    /**
     * The task name. This only works for data created with 8.8 and onwards. Instances from prior versions don't contain this data and cannot be found.
     *
     */
    name?: StringFilterProperty;
    /**
     * The candidate group for this user task.
     */
    candidateGroup?: StringFilterProperty;
    /**
     * The candidate user for this user task.
     */
    candidateUser?: StringFilterProperty;
    /**
     * Tenant ID of this user task.
     */
    tenantId?: StringFilterProperty;
    /**
     * The ID of the process definition.
     */
    processDefinitionId?: ProcessDefinitionId;
    /**
     * The user task creation date.
     */
    creationDate?: DateTimeFilterProperty;
    /**
     * The user task completion date.
     */
    completionDate?: DateTimeFilterProperty;
    /**
     * The user task follow-up date.
     */
    followUpDate?: DateTimeFilterProperty;
    /**
     * The user task due date.
     */
    dueDate?: DateTimeFilterProperty;
    processInstanceVariables?: Array<VariableValueFilterProperty>;
    localVariables?: Array<VariableValueFilterProperty>;
    /**
     * The key for this user task.
     */
    userTaskKey?: UserTaskKey;
    /**
     * The key of the process definition.
     */
    processDefinitionKey?: ProcessDefinitionKey;
    /**
     * The key of the process instance.
     */
    processInstanceKey?: ProcessInstanceKey;
    /**
     * The key of the element instance.
     */
    elementInstanceKey?: ElementInstanceKey;
    tags?: TagSet;
};

/**
 * User task search query response.
 */
export type UserTaskSearchQueryResult = SearchQueryResponse & {
    /**
     * The matching user tasks.
     */
    items?: Array<UserTaskResult>;
};

export type UserTaskResult = {
    /**
     * The name for this user task.
     */
    name?: string;
    state?: UserTaskStateEnum;
    /**
     * The assignee of the user task.
     */
    assignee?: string;
    /**
     * The element ID of the user task.
     */
    elementId?: ElementId;
    /**
     * The candidate groups for this user task.
     */
    candidateGroups?: Array<string>;
    /**
     * The candidate users for this user task.
     */
    candidateUsers?: Array<string>;
    /**
     * The ID of the process definition.
     */
    processDefinitionId?: ProcessDefinitionId;
    /**
     * The creation date of a user task.
     */
    creationDate?: string;
    /**
     * The completion date of a user task.
     */
    completionDate?: string;
    /**
     * The follow date of a user task.
     */
    followUpDate?: string;
    /**
     * The due date of a user task.
     */
    dueDate?: string;
    tenantId?: TenantId;
    /**
     * The external form reference.
     */
    externalFormReference?: string;
    /**
     * The version of the process definition.
     */
    processDefinitionVersion?: number;
    /**
     * Custom headers for the user task.
     */
    customHeaders?: {
        [key: string]: string;
    };
    /**
     * The priority of a user task. The higher the value the higher the priority.
     */
    priority?: number;
    /**
     * The key of the user task.
     */
    userTaskKey?: UserTaskKey;
    /**
     * The key of the element instance.
     */
    elementInstanceKey?: ElementInstanceKey;
    /**
     * The name of the process definition.
     */
    processName?: string;
    /**
     * The key of the process definition.
     */
    processDefinitionKey?: ProcessDefinitionKey;
    /**
     * The key of the process instance.
     */
    processInstanceKey?: ProcessInstanceKey;
    rootProcessInstanceKey?: RootProcessInstanceKey;
    /**
     * The key of the form.
     */
    formKey?: FormKey;
    tags?: TagSet;
};

export type UserTaskCompletionRequest = {
    /**
     * The variables to complete the user task with.
     */
    variables?: {
        [key: string]: unknown;
    } | null;
    /**
     * A custom action value that will be accessible from user task events resulting from this endpoint invocation. If not provided, it will default to "complete".
     *
     */
    action?: string | null;
};

export type UserTaskAssignmentRequest = {
    /**
     * The assignee for the user task. The assignee must not be empty or `null`.
     */
    assignee?: string;
    /**
     * By default, the task is reassigned if it was already assigned. Set this to `false` to return an error in such cases. The task must then first be unassigned to be assigned again. Use this when you have users picking from group task queues to prevent race conditions.
     *
     */
    allowOverride?: boolean | null;
    /**
     * A custom action value that will be accessible from user task events resulting from this endpoint invocation. If not provided, it will default to "assign".
     *
     */
    action?: string | null;
};

export type UserTaskUpdateRequest = {
    changeset?: Changeset;
    /**
     * A custom action value that will be accessible from user task events resulting from this endpoint invocation. If not provided, it will default to "update".
     *
     */
    action?: string | null;
};

/**
 * JSON object with changed task attribute values.
 *
 * The following attributes can be adjusted with this endpoint, additional attributes
 * will be ignored:
 *
 * * `candidateGroups` - reset by providing an empty list
 * * `candidateUsers` - reset by providing an empty list
 * * `dueDate` - reset by providing an empty String
 * * `followUpDate` - reset by providing an empty String
 * * `priority` - minimum 0, maximum 100, default 50
 *
 * Providing any of those attributes with a `null` value or omitting it preserves
 * the persisted attribute's value.
 *
 * The assignee cannot be adjusted with this endpoint, use the Assign task endpoint.
 * This ensures correct event emission for assignee changes.
 *
 */
export type Changeset = {
    /**
     * The due date of the task. Reset by providing an empty String.
     */
    dueDate?: string | null;
    /**
     * The follow-up date of the task. Reset by providing an empty String.
     */
    followUpDate?: string | null;
    /**
     * The list of candidate users of the task. Reset by providing an empty list.
     */
    candidateUsers?: Array<string> | null;
    /**
     * The list of candidate groups of the task. Reset by providing an empty list.
     */
    candidateGroups?: Array<string> | null;
    /**
     * The priority of the task.
     */
    priority?: number | null;
    [key: string]: unknown | string | null | string | null | Array<string> | null | Array<string> | null | number | null | undefined;
} | null;

export type UserTaskVariableSearchQuerySortRequest = {
    /**
     * The field to sort by.
     */
    field: 'value' | 'name' | 'tenantId' | 'variableKey' | 'scopeKey' | 'processInstanceKey';
    order?: SortOrderEnum;
};

/**
 * User task search query request.
 */
export type UserTaskVariableSearchQueryRequest = SearchQueryRequest & {
    /**
     * Sort field criteria.
     */
    sort?: Array<UserTaskVariableSearchQuerySortRequest>;
    /**
     * The user task variable search filters.
     */
    filter?: UserTaskVariableFilter;
};

/**
 * User task search query request.
 */
export type UserTaskAuditLogSearchQueryRequest = SearchQueryRequest & {
    /**
     * Sort field criteria.
     */
    sort?: Array<AuditLogSearchQuerySortRequest>;
    filter?: UserTaskAuditLogFilter;
};

/**
 * The state of the user task.
 */
export type UserTaskStateEnum = 'CREATING' | 'CREATED' | 'ASSIGNING' | 'UPDATING' | 'COMPLETING' | 'COMPLETED' | 'CANCELING' | 'CANCELED' | 'FAILED';

/**
 * The user task variable search filters.
 */
export type UserTaskVariableFilter = {
    /**
     * Name of the variable.
     */
    name?: StringFilterProperty;
};

/**
 * UserTaskStateEnum property with full advanced search capabilities.
 */
export type UserTaskStateFilterProperty = UserTaskStateExactMatch | AdvancedUserTaskStateFilter;

/**
 * Advanced filter
 *
 * Advanced UserTaskStateEnum filter.
 */
export type AdvancedUserTaskStateFilter = {
    /**
     * Checks for equality with the provided value.
     */
    $eq?: UserTaskStateEnum;
    /**
     * Checks for inequality with the provided value.
     */
    $neq?: UserTaskStateEnum;
    /**
     * Checks if the current property exists.
     */
    $exists?: boolean;
    /**
     * Checks if the property matches any of the provided values.
     */
    $in?: Array<UserTaskStateEnum>;
    $like?: LikeFilter;
};

/**
 * The user task audit log search filters.
 */
export type UserTaskAuditLogFilter = {
    /**
     * The audit log operation type search filter.
     */
    operationType?: OperationTypeFilterProperty;
    /**
     * The audit log result search filter.
     */
    result?: AuditLogResultFilterProperty;
    /**
     * The audit log timestamp filter.
     */
    timestamp?: DateTimeFilterProperty;
    /**
     * The actor type search filter.
     */
    actorType?: AuditLogActorTypeFilterProperty;
    /**
     * The actor ID search filter.
     */
    actorId?: StringFilterProperty;
};

export type UserRequest = {
    /**
     * The password of the user.
     */
    password: string;
    /**
     * The username of the user.
     */
    username: string;
    /**
     * The name of the user.
     */
    name?: string;
    /**
     * The email of the user.
     */
    email?: string;
};

export type UserCreateResult = {
    username?: Username;
    /**
     * The name of the user.
     */
    name?: string;
    /**
     * The email of the user.
     */
    email?: string;
};

export type UserUpdateRequest = {
    /**
     * The password of the user. If blank, the password is unchanged.
     */
    password?: string;
    /**
     * The name of the user.
     */
    name?: string;
    /**
     * The email of the user.
     */
    email?: string;
};

export type UserUpdateResult = {
    username?: Username;
    /**
     * The name of the user.
     */
    name?: string;
    /**
     * The email of the user.
     */
    email?: string;
};

export type UserResult = {
    username?: Username;
    /**
     * The name of the user.
     */
    name?: string;
    /**
     * The email of the user.
     */
    email?: string;
};

export type UserSearchQuerySortRequest = {
    /**
     * The field to sort by.
     */
    field: 'username' | 'name' | 'email';
    order?: SortOrderEnum;
};

export type UserSearchQueryRequest = SearchQueryRequest & {
    /**
     * Sort field criteria.
     */
    sort?: Array<UserSearchQuerySortRequest>;
    /**
     * The user search filters.
     */
    filter?: UserFilter;
};

/**
 * User search filter.
 */
export type UserFilter = {
    /**
     * The username of the user.
     */
    username?: StringFilterProperty;
    /**
     * The name of the user.
     */
    name?: StringFilterProperty;
    /**
     * The email of the user.
     */
    email?: StringFilterProperty;
};

export type UserSearchResult = SearchQueryResponse & {
    /**
     * The matching users.
     */
    items: Array<UserResult>;
};

export type VariableSearchQuerySortRequest = {
    /**
     * The field to sort by.
     */
    field: 'value' | 'name' | 'tenantId' | 'variableKey' | 'scopeKey' | 'processInstanceKey';
    order?: SortOrderEnum;
};

/**
 * Variable search query request.
 */
export type VariableSearchQuery = SearchQueryRequest & {
    /**
     * Sort field criteria.
     */
    sort?: Array<VariableSearchQuerySortRequest>;
    /**
     * The variable search filters.
     */
    filter?: VariableFilter;
};

/**
 * Variable filter request.
 */
export type VariableFilter = {
    /**
     * Name of the variable.
     */
    name?: StringFilterProperty;
    /**
     * The value of the variable.
     */
    value?: StringFilterProperty;
    /**
     * Tenant ID of this variable.
     */
    tenantId?: TenantId;
    /**
     * Whether the value is truncated or not.
     */
    isTruncated?: boolean;
    /**
     * The key for this variable.
     */
    variableKey?: VariableKeyFilterProperty;
    /**
     * The key of the scope of this variable.
     */
    scopeKey?: ScopeKeyFilterProperty;
    /**
     * The key of the process instance of this variable.
     */
    processInstanceKey?: ProcessInstanceKeyFilterProperty;
};

/**
 * Variable search query response.
 */
export type VariableSearchQueryResult = SearchQueryResponse & {
    /**
     * The matching variables.
     */
    items?: Array<VariableSearchResult>;
};

/**
 * Variable search response item.
 */
export type VariableSearchResult = VariableResultBase & {
    /**
     * Value of this variable. Can be truncated.
     */
    value?: string;
    /**
     * Whether the value is truncated or not.
     */
    isTruncated?: boolean;
};

/**
 * Variable search response item.
 */
export type VariableResult = VariableResultBase & {
    /**
     * Full value of this variable.
     */
    value?: string;
};

/**
 * Variable response item.
 */
export type VariableResultBase = {
    /**
     * Name of this variable.
     */
    name?: string;
    /**
     * Tenant ID of this variable.
     */
    tenantId?: TenantId;
    /**
     * The key for this variable.
     */
    variableKey?: VariableKey;
    /**
     * The key of the scope of this variable.
     */
    scopeKey?: ScopeKey;
    /**
     * The key of the process instance of this variable.
     */
    processInstanceKey?: ProcessInstanceKey;
    rootProcessInstanceKey?: RootProcessInstanceKey;
};

export type VariableValueFilterProperty = {
    /**
     * Name of the variable.
     */
    name: string;
    /**
     * The value of the variable.
     */
    value: StringFilterProperty;
};

export type SetVariableRequest = {
    /**
     * JSON object representing the variables to set in the elements scope.
     */
    variables: {
        [key: string]: unknown;
    };
    /**
     * If set to true, the variables are merged strictly into the local scope (as specified by the `elementInstanceKey`).
     * Otherwise, the variables are propagated to upper scopes and set at the outermost one.
     * Lets consider the following example:
     * There are two scopes '1' and '2'.
     * Scope '1' is the parent scope of '2'. The effective variables of the scopes are:
     * 1 => { "foo" : 2 }
     * 2 => { "bar" : 1 }
     * An update request with elementInstanceKey as '2', variables { "foo" : 5 }, and local set
     * to true leaves scope '1' unchanged and adjusts scope '2' to { "bar" : 1, "foo" 5 }.
     * By default, with local set to false, scope '1' will be { "foo": 5 }
     * and scope '2' will be { "bar" : 1 }.
     *
     */
    local?: boolean;
    operationReference?: OperationReference;
};

/**
 * Exact match
 *
 * Matches the value exactly.
 */
export type AuditLogEntityKeyExactMatch = AuditLogEntityKey;

/**
 * Exact match
 *
 * Matches the value exactly.
 */
export type EntityTypeExactMatch = AuditLogEntityTypeEnum;

/**
 * Exact match
 *
 * Matches the value exactly.
 */
export type OperationTypeExactMatch = AuditLogOperationTypeEnum;

/**
 * Exact match
 *
 * Matches the value exactly.
 */
export type CategoryExactMatch = AuditLogCategoryEnum;

/**
 * Exact match
 *
 * Matches the value exactly.
 */
export type AuditLogResultExactMatch = AuditLogResultEnum;

/**
 * Exact match
 *
 * Matches the value exactly.
 */
export type AuditLogActorTypeExactMatch = AuditLogActorTypeEnum;

/**
 * Exact match
 *
 * Matches the value exactly.
 */
export type BatchOperationTypeExactMatch = BatchOperationTypeEnum;

/**
 * Exact match
 *
 * Matches the value exactly.
 */
export type BatchOperationStateExactMatch = BatchOperationStateEnum;

/**
 * Exact match
 *
 * Matches the value exactly.
 */
export type BatchOperationItemStateExactMatch = BatchOperationItemStateEnum;

/**
 * Exact match
 *
 * Matches the value exactly.
 */
export type ClusterVariableScopeExactMatch = ClusterVariableScopeEnum;

/**
 * Exact match
 *
 * Matches the value exactly.
 */
export type DecisionInstanceStateExactMatch = DecisionInstanceStateEnum;

/**
 * Exact match
 *
 * Matches the value exactly.
 */
export type DeploymentKeyExactMatch = DeploymentKey;

/**
 * Exact match
 *
 * Matches the value exactly.
 */
export type ResourceKeyExactMatch = ResourceKey;

/**
 * Exact match
 *
 * Matches the value exactly.
 */
export type ElementInstanceStateExactMatch = ElementInstanceStateEnum;

/**
 * Exact match
 *
 * Matches the value exactly.
 */
export type IncidentErrorTypeExactMatch = IncidentErrorTypeEnum;

/**
 * Exact match
 *
 * Matches the value exactly.
 */
export type IncidentStateExactMatch = IncidentStateEnum;

/**
 * Exact match
 *
 * Matches the value exactly.
 */
export type JobKindExactMatch = JobKindEnum;

/**
 * Exact match
 *
 * Matches the value exactly.
 */
export type JobListenerEventTypeExactMatch = JobListenerEventTypeEnum;

/**
 * Exact match
 *
 * Matches the value exactly.
 */
export type JobStateExactMatch = JobStateEnum;

/**
 * Exact match
 *
 * Matches the value exactly.
 */
export type ProcessDefinitionKeyExactMatch = ProcessDefinitionKey;

/**
 * Exact match
 *
 * Matches the value exactly.
 */
export type ProcessInstanceKeyExactMatch = ProcessInstanceKey;

/**
 * Exact match
 *
 * Matches the value exactly.
 */
export type ElementInstanceKeyExactMatch = ElementInstanceKey;

/**
 * Exact match
 *
 * Matches the value exactly.
 */
export type JobKeyExactMatch = JobKey;

/**
 * Exact match
 *
 * Matches the value exactly.
 */
export type DecisionDefinitionKeyExactMatch = DecisionDefinitionKey;

/**
 * Exact match
 *
 * Matches the value exactly.
 */
export type ScopeKeyExactMatch = ScopeKey;

/**
 * Exact match
 *
 * Matches the value exactly.
 */
export type VariableKeyExactMatch = VariableKey;

/**
 * Exact match
 *
 * Matches the value exactly.
 */
export type DecisionEvaluationInstanceKeyExactMatch = DecisionEvaluationInstanceKey;

/**
 * Exact match
 *
 * Matches the value exactly.
 */
export type AuditLogKeyExactMatch = AuditLogKey;

/**
 * Exact match
 *
 * Matches the value exactly.
 */
export type FormKeyExactMatch = FormKey;

/**
 * Exact match
 *
 * Matches the value exactly.
 */
export type DecisionEvaluationKeyExactMatch = DecisionEvaluationKey;

/**
 * Exact match
 *
 * Matches the value exactly.
 */
export type DecisionRequirementsKeyExactMatch = DecisionRequirementsKey;

/**
 * Exact match
 *
 * Matches the value exactly.
 */
export type MessageSubscriptionStateExactMatch = MessageSubscriptionStateEnum;

/**
 * Exact match
 *
 * Matches the value exactly.
 */
export type MessageSubscriptionKeyExactMatch = MessageSubscriptionKey;

/**
 * Exact match
 *
 * Matches the value exactly.
 */
export type ProcessInstanceStateExactMatch = ProcessInstanceStateEnum;

/**
 * Exact match
 *
 * Matches the value exactly.
 */
export type UserTaskStateExactMatch = UserTaskStateEnum;

export type SearchAuditLogsData = {
    body?: AuditLogSearchQueryRequest;
    path?: never;
    query?: never;
    url: '/audit-logs/search';
};

export type SearchAuditLogsErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: unknown;
};

export type SearchAuditLogsError = SearchAuditLogsErrors[keyof SearchAuditLogsErrors];

export type SearchAuditLogsResponses = {
    /**
     * The audit logs search result.
     */
    200: AuditLogSearchQueryResult;
};

export type SearchAuditLogsResponse = SearchAuditLogsResponses[keyof SearchAuditLogsResponses];

export type GetAuditLogData = {
    body?: never;
    path: {
        /**
         * The audit log key.
         */
        auditLogKey: AuditLogKey;
    };
    query?: never;
    url: '/audit-logs/{auditLogKey}';
};

export type GetAuditLogErrors = {
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The audit log with the given key was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type GetAuditLogError = GetAuditLogErrors[keyof GetAuditLogErrors];

export type GetAuditLogResponses = {
    /**
     * The audit log entry is successfully returned.
     */
    200: AuditLogResult;
};

export type GetAuditLogResponse = GetAuditLogResponses[keyof GetAuditLogResponses];

export type GetAuthenticationData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/authentication/me';
};

export type GetAuthenticationErrors = {
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type GetAuthenticationError = GetAuthenticationErrors[keyof GetAuthenticationErrors];

export type GetAuthenticationResponses = {
    /**
     * The current user is successfully returned.
     */
    200: CamundaUserResult;
};

export type GetAuthenticationResponse = GetAuthenticationResponses[keyof GetAuthenticationResponses];

export type CreateAuthorizationData = {
    body: AuthorizationRequest;
    path?: never;
    query?: never;
    url: '/authorizations';
};

export type CreateAuthorizationErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The owner was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type CreateAuthorizationError = CreateAuthorizationErrors[keyof CreateAuthorizationErrors];

export type CreateAuthorizationResponses = {
    /**
     * The authorization was created successfully.
     */
    201: AuthorizationCreateResult;
};

export type CreateAuthorizationResponse = CreateAuthorizationResponses[keyof CreateAuthorizationResponses];

export type SearchAuthorizationsData = {
    body?: AuthorizationSearchQuery;
    path?: never;
    query?: never;
    url: '/authorizations/search';
};

export type SearchAuthorizationsErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type SearchAuthorizationsError = SearchAuthorizationsErrors[keyof SearchAuthorizationsErrors];

export type SearchAuthorizationsResponses = {
    /**
     * The authorization search result.
     */
    200: AuthorizationSearchResult;
};

export type SearchAuthorizationsResponse = SearchAuthorizationsResponses[keyof SearchAuthorizationsResponses];

export type DeleteAuthorizationData = {
    body?: never;
    path: {
        /**
         * The key of the authorization to delete.
         */
        authorizationKey: AuthorizationKey;
    };
    query?: never;
    url: '/authorizations/{authorizationKey}';
};

export type DeleteAuthorizationErrors = {
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * The authorization with the authorizationKey was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type DeleteAuthorizationError = DeleteAuthorizationErrors[keyof DeleteAuthorizationErrors];

export type DeleteAuthorizationResponses = {
    /**
     * The authorization was deleted successfully.
     */
    204: void;
};

export type DeleteAuthorizationResponse = DeleteAuthorizationResponses[keyof DeleteAuthorizationResponses];

export type GetAuthorizationData = {
    body?: never;
    path: {
        /**
         * The key of the authorization to get.
         */
        authorizationKey: AuthorizationKey;
    };
    query?: never;
    url: '/authorizations/{authorizationKey}';
};

export type GetAuthorizationErrors = {
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The authorization with the given key was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type GetAuthorizationError = GetAuthorizationErrors[keyof GetAuthorizationErrors];

export type GetAuthorizationResponses = {
    /**
     * The authorization was successfully returned.
     */
    200: AuthorizationResult;
};

export type GetAuthorizationResponse = GetAuthorizationResponses[keyof GetAuthorizationResponses];

export type UpdateAuthorizationData = {
    body: AuthorizationRequest;
    path: {
        /**
         * The key of the authorization to delete.
         */
        authorizationKey: AuthorizationKey;
    };
    query?: never;
    url: '/authorizations/{authorizationKey}';
};

export type UpdateAuthorizationErrors = {
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * The authorization with the authorizationKey was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type UpdateAuthorizationError = UpdateAuthorizationErrors[keyof UpdateAuthorizationErrors];

export type UpdateAuthorizationResponses = {
    /**
     * The authorization was updated successfully.
     */
    204: void;
};

export type UpdateAuthorizationResponse = UpdateAuthorizationResponses[keyof UpdateAuthorizationResponses];

export type SearchBatchOperationItemsData = {
    body?: BatchOperationItemSearchQuery;
    path?: never;
    query?: never;
    url: '/batch-operation-items/search';
};

export type SearchBatchOperationItemsErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type SearchBatchOperationItemsError = SearchBatchOperationItemsErrors[keyof SearchBatchOperationItemsErrors];

export type SearchBatchOperationItemsResponses = {
    /**
     * The batch operation search result.
     */
    200: BatchOperationItemSearchQueryResult;
};

export type SearchBatchOperationItemsResponse = SearchBatchOperationItemsResponses[keyof SearchBatchOperationItemsResponses];

export type SearchBatchOperationsData = {
    body?: BatchOperationSearchQuery;
    path?: never;
    query?: never;
    url: '/batch-operations/search';
};

export type SearchBatchOperationsErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type SearchBatchOperationsError = SearchBatchOperationsErrors[keyof SearchBatchOperationsErrors];

export type SearchBatchOperationsResponses = {
    /**
     * The batch operation search result.
     */
    200: BatchOperationSearchQueryResult;
};

export type SearchBatchOperationsResponse = SearchBatchOperationsResponses[keyof SearchBatchOperationsResponses];

export type GetBatchOperationData = {
    body?: never;
    path: {
        /**
         * The key (or operate legacy ID) of the batch operation.
         */
        batchOperationKey: BatchOperationKey;
    };
    query?: never;
    url: '/batch-operations/{batchOperationKey}';
};

export type GetBatchOperationErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The batch operation is not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type GetBatchOperationError = GetBatchOperationErrors[keyof GetBatchOperationErrors];

export type GetBatchOperationResponses = {
    /**
     * The batch operation was found.
     */
    200: BatchOperationResponse;
};

export type GetBatchOperationResponse = GetBatchOperationResponses[keyof GetBatchOperationResponses];

export type CancelBatchOperationData = {
    body?: unknown;
    path: {
        /**
         * The key (or operate legacy ID) of the batch operation.
         */
        batchOperationKey: BatchOperationKey;
    };
    query?: never;
    url: '/batch-operations/{batchOperationKey}/cancellation';
};

export type CancelBatchOperationErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * Not found. The batch operation was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type CancelBatchOperationError = CancelBatchOperationErrors[keyof CancelBatchOperationErrors];

export type CancelBatchOperationResponses = {
    /**
     * The batch operation cancel request was created.
     */
    204: void;
};

export type CancelBatchOperationResponse = CancelBatchOperationResponses[keyof CancelBatchOperationResponses];

export type ResumeBatchOperationData = {
    body?: unknown;
    path: {
        /**
         * The key (or operate legacy ID) of the batch operation.
         */
        batchOperationKey: BatchOperationKey;
    };
    query?: never;
    url: '/batch-operations/{batchOperationKey}/resumption';
};

export type ResumeBatchOperationErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * Not found. The batch operation was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type ResumeBatchOperationError = ResumeBatchOperationErrors[keyof ResumeBatchOperationErrors];

export type ResumeBatchOperationResponses = {
    /**
     * The batch operation resume request was created.
     */
    204: void;
};

export type ResumeBatchOperationResponse = ResumeBatchOperationResponses[keyof ResumeBatchOperationResponses];

export type SuspendBatchOperationData = {
    body?: unknown;
    path: {
        /**
         * The key (or operate legacy ID) of the batch operation.
         */
        batchOperationKey: BatchOperationKey;
    };
    query?: never;
    url: '/batch-operations/{batchOperationKey}/suspension';
};

export type SuspendBatchOperationErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * Not found. The batch operation was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type SuspendBatchOperationError = SuspendBatchOperationErrors[keyof SuspendBatchOperationErrors];

export type SuspendBatchOperationResponses = {
    /**
     * The batch operation pause request was created.
     */
    204: void;
};

export type SuspendBatchOperationResponse = SuspendBatchOperationResponses[keyof SuspendBatchOperationResponses];

export type PinClockData = {
    body: ClockPinRequest;
    path?: never;
    query?: never;
    url: '/clock';
};

export type PinClockErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type PinClockError = PinClockErrors[keyof PinClockErrors];

export type PinClockResponses = {
    /**
     * The clock was successfully pinned.
     */
    204: void;
};

export type PinClockResponse = PinClockResponses[keyof PinClockResponses];

export type ResetClockData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/clock/reset';
};

export type ResetClockErrors = {
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type ResetClockError = ResetClockErrors[keyof ResetClockErrors];

export type ResetClockResponses = {
    /**
     * The clock was successfully reset to the system time.
     */
    204: void;
};

export type ResetClockResponse = ResetClockResponses[keyof ResetClockResponses];

export type CreateGlobalClusterVariableData = {
    body: CreateClusterVariableRequest;
    path?: never;
    query?: never;
    url: '/cluster-variables/global';
};

export type CreateGlobalClusterVariableErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type CreateGlobalClusterVariableError = CreateGlobalClusterVariableErrors[keyof CreateGlobalClusterVariableErrors];

export type CreateGlobalClusterVariableResponses = {
    /**
     * Cluster variable created
     */
    200: ClusterVariableResult;
};

export type CreateGlobalClusterVariableResponse = CreateGlobalClusterVariableResponses[keyof CreateGlobalClusterVariableResponses];

export type DeleteGlobalClusterVariableData = {
    body?: never;
    path: {
        /**
         * The name of the cluster variable
         */
        name: string;
    };
    query?: never;
    url: '/cluster-variables/global/{name}';
};

export type DeleteGlobalClusterVariableErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * Cluster variable not found
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type DeleteGlobalClusterVariableError = DeleteGlobalClusterVariableErrors[keyof DeleteGlobalClusterVariableErrors];

export type DeleteGlobalClusterVariableResponses = {
    /**
     * Cluster variable deleted successfully
     */
    204: void;
};

export type DeleteGlobalClusterVariableResponse = DeleteGlobalClusterVariableResponses[keyof DeleteGlobalClusterVariableResponses];

export type GetGlobalClusterVariableData = {
    body?: never;
    path: {
        /**
         * The name of the cluster variable
         */
        name: string;
    };
    query?: never;
    url: '/cluster-variables/global/{name}';
};

export type GetGlobalClusterVariableErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * Cluster variable not found
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type GetGlobalClusterVariableError = GetGlobalClusterVariableErrors[keyof GetGlobalClusterVariableErrors];

export type GetGlobalClusterVariableResponses = {
    /**
     * Cluster variable found
     */
    200: ClusterVariableResult;
};

export type GetGlobalClusterVariableResponse = GetGlobalClusterVariableResponses[keyof GetGlobalClusterVariableResponses];

export type UpdateGlobalClusterVariableData = {
    body: UpdateClusterVariableRequest;
    path: {
        /**
         * The name of the cluster variable
         */
        name: string;
    };
    query?: never;
    url: '/cluster-variables/global/{name}';
};

export type UpdateGlobalClusterVariableErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * Cluster variable not found
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type UpdateGlobalClusterVariableError = UpdateGlobalClusterVariableErrors[keyof UpdateGlobalClusterVariableErrors];

export type UpdateGlobalClusterVariableResponses = {
    /**
     * Cluster variable updated successfully
     */
    200: ClusterVariableResult;
};

export type UpdateGlobalClusterVariableResponse = UpdateGlobalClusterVariableResponses[keyof UpdateGlobalClusterVariableResponses];

export type SearchClusterVariablesData = {
    body?: ClusterVariableSearchQueryRequest;
    path?: never;
    query?: {
        /**
         * When true (default), long variable values in the response are truncated. When false, full variable values are returned.
         */
        truncateValues?: boolean;
    };
    url: '/cluster-variables/search';
};

export type SearchClusterVariablesErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type SearchClusterVariablesError = SearchClusterVariablesErrors[keyof SearchClusterVariablesErrors];

export type SearchClusterVariablesResponses = {
    /**
     * The cluster variable search result.
     */
    200: ClusterVariableSearchQueryResult;
};

export type SearchClusterVariablesResponse = SearchClusterVariablesResponses[keyof SearchClusterVariablesResponses];

export type CreateTenantClusterVariableData = {
    body: CreateClusterVariableRequest;
    path: {
        /**
         * The tenant ID
         */
        tenantId: TenantId;
    };
    query?: never;
    url: '/cluster-variables/tenants/{tenantId}';
};

export type CreateTenantClusterVariableErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type CreateTenantClusterVariableError = CreateTenantClusterVariableErrors[keyof CreateTenantClusterVariableErrors];

export type CreateTenantClusterVariableResponses = {
    /**
     * Cluster variable created
     */
    200: ClusterVariableResult;
};

export type CreateTenantClusterVariableResponse = CreateTenantClusterVariableResponses[keyof CreateTenantClusterVariableResponses];

export type DeleteTenantClusterVariableData = {
    body?: never;
    path: {
        /**
         * The tenant ID
         */
        tenantId: TenantId;
        /**
         * The name of the cluster variable
         */
        name: string;
    };
    query?: never;
    url: '/cluster-variables/tenants/{tenantId}/{name}';
};

export type DeleteTenantClusterVariableErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * Cluster variable not found
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type DeleteTenantClusterVariableError = DeleteTenantClusterVariableErrors[keyof DeleteTenantClusterVariableErrors];

export type DeleteTenantClusterVariableResponses = {
    /**
     * Cluster variable deleted successfully
     */
    204: void;
};

export type DeleteTenantClusterVariableResponse = DeleteTenantClusterVariableResponses[keyof DeleteTenantClusterVariableResponses];

export type GetTenantClusterVariableData = {
    body?: never;
    path: {
        /**
         * The tenant ID
         */
        tenantId: TenantId;
        /**
         * The name of the cluster variable
         */
        name: string;
    };
    query?: never;
    url: '/cluster-variables/tenants/{tenantId}/{name}';
};

export type GetTenantClusterVariableErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * Cluster variable not found
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type GetTenantClusterVariableError = GetTenantClusterVariableErrors[keyof GetTenantClusterVariableErrors];

export type GetTenantClusterVariableResponses = {
    /**
     * Cluster variable found
     */
    200: ClusterVariableResult;
};

export type GetTenantClusterVariableResponse = GetTenantClusterVariableResponses[keyof GetTenantClusterVariableResponses];

export type UpdateTenantClusterVariableData = {
    body: UpdateClusterVariableRequest;
    path: {
        /**
         * The tenant ID
         */
        tenantId: TenantId;
        /**
         * The name of the cluster variable
         */
        name: string;
    };
    query?: never;
    url: '/cluster-variables/tenants/{tenantId}/{name}';
};

export type UpdateTenantClusterVariableErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * Cluster variable not found
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type UpdateTenantClusterVariableError = UpdateTenantClusterVariableErrors[keyof UpdateTenantClusterVariableErrors];

export type UpdateTenantClusterVariableResponses = {
    /**
     * Cluster variable updated successfully
     */
    200: ClusterVariableResult;
};

export type UpdateTenantClusterVariableResponse = UpdateTenantClusterVariableResponses[keyof UpdateTenantClusterVariableResponses];

export type EvaluateConditionalsData = {
    body: ConditionalEvaluationInstruction;
    path?: never;
    query?: never;
    url: '/conditionals/evaluation';
};

export type EvaluateConditionalsErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The client is not authorized to start process instances for the specified process definition.
     * If a processDefinitionKey is not provided, this indicates that the client is not authorized
     * to start process instances for at least one of the matched process definitions.
     *
     */
    403: ProblemDetail;
    /**
     * The process definition was not found for the given processDefinitionKey.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type EvaluateConditionalsError = EvaluateConditionalsErrors[keyof EvaluateConditionalsErrors];

export type EvaluateConditionalsResponses = {
    /**
     * Successfully evaluated root-level conditional start events.
     */
    200: EvaluateConditionalResult;
};

export type EvaluateConditionalsResponse = EvaluateConditionalsResponses[keyof EvaluateConditionalsResponses];

export type SearchCorrelatedMessageSubscriptionsData = {
    body?: CorrelatedMessageSubscriptionSearchQuery;
    path?: never;
    query?: never;
    url: '/correlated-message-subscriptions/search';
};

export type SearchCorrelatedMessageSubscriptionsErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type SearchCorrelatedMessageSubscriptionsError = SearchCorrelatedMessageSubscriptionsErrors[keyof SearchCorrelatedMessageSubscriptionsErrors];

export type SearchCorrelatedMessageSubscriptionsResponses = {
    /**
     * The correlated message subscriptions search result.
     */
    200: CorrelatedMessageSubscriptionSearchQueryResult;
};

export type SearchCorrelatedMessageSubscriptionsResponse = SearchCorrelatedMessageSubscriptionsResponses[keyof SearchCorrelatedMessageSubscriptionsResponses];

export type EvaluateDecisionData = {
    body: DecisionEvaluationInstruction;
    path?: never;
    query?: never;
    url: '/decision-definitions/evaluation';
};

export type EvaluateDecisionErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The decision is not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type EvaluateDecisionError = EvaluateDecisionErrors[keyof EvaluateDecisionErrors];

export type EvaluateDecisionResponses = {
    /**
     * The decision was evaluated.
     */
    200: EvaluateDecisionResult;
};

export type EvaluateDecisionResponse = EvaluateDecisionResponses[keyof EvaluateDecisionResponses];

export type SearchDecisionDefinitionsData = {
    body?: DecisionDefinitionSearchQuery;
    path?: never;
    query?: never;
    url: '/decision-definitions/search';
};

export type SearchDecisionDefinitionsErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type SearchDecisionDefinitionsError = SearchDecisionDefinitionsErrors[keyof SearchDecisionDefinitionsErrors];

export type SearchDecisionDefinitionsResponses = {
    /**
     * The decision definition search result.
     */
    200: DecisionDefinitionSearchQueryResult;
};

export type SearchDecisionDefinitionsResponse = SearchDecisionDefinitionsResponses[keyof SearchDecisionDefinitionsResponses];

export type GetDecisionDefinitionData = {
    body?: never;
    path: {
        /**
         * The assigned key of the decision definition, which acts as a unique identifier for this decision.
         */
        decisionDefinitionKey: DecisionDefinitionKey;
    };
    query?: never;
    url: '/decision-definitions/{decisionDefinitionKey}';
};

export type GetDecisionDefinitionErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The decision definition with the given key was not found. More details are provided in the response body.
     *
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type GetDecisionDefinitionError = GetDecisionDefinitionErrors[keyof GetDecisionDefinitionErrors];

export type GetDecisionDefinitionResponses = {
    /**
     * The decision definition is successfully returned.
     */
    200: DecisionDefinitionResult;
};

export type GetDecisionDefinitionResponse = GetDecisionDefinitionResponses[keyof GetDecisionDefinitionResponses];

export type GetDecisionDefinitionXmlData = {
    body?: never;
    path: {
        /**
         * The assigned key of the decision definition, which acts as a unique identifier for this decision.
         */
        decisionDefinitionKey: DecisionDefinitionKey;
    };
    query?: never;
    url: '/decision-definitions/{decisionDefinitionKey}/xml';
};

export type GetDecisionDefinitionXmlErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The decision definition with the given key was not found. More details are provided in the response body.
     *
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type GetDecisionDefinitionXmlError = GetDecisionDefinitionXmlErrors[keyof GetDecisionDefinitionXmlErrors];

export type GetDecisionDefinitionXmlResponses = {
    /**
     * The XML of the decision definition is successfully returned.
     */
    200: string;
};

export type GetDecisionDefinitionXmlResponse = GetDecisionDefinitionXmlResponses[keyof GetDecisionDefinitionXmlResponses];

export type SearchDecisionInstancesData = {
    body?: DecisionInstanceSearchQuery;
    path?: never;
    query?: never;
    url: '/decision-instances/search';
};

export type SearchDecisionInstancesErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type SearchDecisionInstancesError = SearchDecisionInstancesErrors[keyof SearchDecisionInstancesErrors];

export type SearchDecisionInstancesResponses = {
    /**
     * The decision instance search result.
     */
    200: DecisionInstanceSearchQueryResult;
};

export type SearchDecisionInstancesResponse = SearchDecisionInstancesResponses[keyof SearchDecisionInstancesResponses];

export type GetDecisionInstanceData = {
    body?: never;
    path: {
        /**
         * The assigned key of the decision instance, which acts as a unique identifier for this decision instance.
         */
        decisionEvaluationInstanceKey: DecisionInstanceKey;
    };
    query?: never;
    url: '/decision-instances/{decisionEvaluationInstanceKey}';
};

export type GetDecisionInstanceErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The decision instance with the given key was not found. More details are provided in the response body.
     *
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type GetDecisionInstanceError = GetDecisionInstanceErrors[keyof GetDecisionInstanceErrors];

export type GetDecisionInstanceResponses = {
    /**
     * The decision instance is successfully returned.
     */
    200: DecisionInstanceGetQueryResult;
};

export type GetDecisionInstanceResponse = GetDecisionInstanceResponses[keyof GetDecisionInstanceResponses];

export type DeleteDecisionInstanceData = {
    body?: {
        operationReference?: OperationReference;
    } | null;
    path: {
        /**
         * The key of the decision instance to delete.
         */
        decisionInstanceKey: DecisionInstanceKey;
    };
    query?: never;
    url: '/decision-instances/{decisionInstanceKey}/deletion';
};

export type DeleteDecisionInstanceErrors = {
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The decision instance is not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type DeleteDecisionInstanceError = DeleteDecisionInstanceErrors[keyof DeleteDecisionInstanceErrors];

export type DeleteDecisionInstanceResponses = {
    /**
     * The decision instance is marked for deletion.
     */
    204: void;
};

export type DeleteDecisionInstanceResponse = DeleteDecisionInstanceResponses[keyof DeleteDecisionInstanceResponses];

export type DeleteDecisionInstancesBatchOperationData = {
    body: DecisionInstanceDeletionBatchOperationRequest;
    path?: never;
    query?: never;
    url: '/decision-instances/deletion';
};

export type DeleteDecisionInstancesBatchOperationErrors = {
    /**
     * The decision instance batch operation failed. More details are provided in the response body.
     *
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type DeleteDecisionInstancesBatchOperationError = DeleteDecisionInstancesBatchOperationErrors[keyof DeleteDecisionInstancesBatchOperationErrors];

export type DeleteDecisionInstancesBatchOperationResponses = {
    /**
     * The batch operation request was created.
     */
    200: BatchOperationCreatedResult;
};

export type DeleteDecisionInstancesBatchOperationResponse = DeleteDecisionInstancesBatchOperationResponses[keyof DeleteDecisionInstancesBatchOperationResponses];

export type SearchDecisionRequirementsData = {
    body?: DecisionRequirementsSearchQuery;
    path?: never;
    query?: never;
    url: '/decision-requirements/search';
};

export type SearchDecisionRequirementsErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type SearchDecisionRequirementsError = SearchDecisionRequirementsErrors[keyof SearchDecisionRequirementsErrors];

export type SearchDecisionRequirementsResponses = {
    /**
     * The decision requirements search result.
     */
    200: DecisionRequirementsSearchQueryResult;
};

export type SearchDecisionRequirementsResponse = SearchDecisionRequirementsResponses[keyof SearchDecisionRequirementsResponses];

export type GetDecisionRequirementsData = {
    body?: never;
    path: {
        /**
         * The assigned key of the decision requirements, which acts as a unique identifier for this decision requirements.
         */
        decisionRequirementsKey: DecisionRequirementsKey;
    };
    query?: never;
    url: '/decision-requirements/{decisionRequirementsKey}';
};

export type GetDecisionRequirementsErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The decision requirements with the given key was not found. More details are provided in the response body.
     *
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type GetDecisionRequirementsError = GetDecisionRequirementsErrors[keyof GetDecisionRequirementsErrors];

export type GetDecisionRequirementsResponses = {
    /**
     * The decision requirements is successfully returned.
     */
    200: DecisionRequirementsResult;
};

export type GetDecisionRequirementsResponse = GetDecisionRequirementsResponses[keyof GetDecisionRequirementsResponses];

export type GetDecisionRequirementsXmlData = {
    body?: never;
    path: {
        /**
         * The assigned key of the decision requirements, which acts as a unique identifier for this decision.
         */
        decisionRequirementsKey: DecisionRequirementsKey;
    };
    query?: never;
    url: '/decision-requirements/{decisionRequirementsKey}/xml';
};

export type GetDecisionRequirementsXmlErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The decision requirements with the given key was not found. More details are provided in the response body.
     *
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type GetDecisionRequirementsXmlError = GetDecisionRequirementsXmlErrors[keyof GetDecisionRequirementsXmlErrors];

export type GetDecisionRequirementsXmlResponses = {
    /**
     * The XML of the decision requirements is successfully returned.
     */
    200: string;
};

export type GetDecisionRequirementsXmlResponse = GetDecisionRequirementsXmlResponses[keyof GetDecisionRequirementsXmlResponses];

export type CreateDeploymentData = {
    body: {
        /**
         * The binary data to create the deployment resources. It is possible to have more than one form part with different form part names for the binary data to create a deployment.
         *
         */
        resources: Array<Blob | File>;
        tenantId?: TenantId;
    };
    path?: never;
    query?: never;
    url: '/deployments';
};

export type CreateDeploymentErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type CreateDeploymentError = CreateDeploymentErrors[keyof CreateDeploymentErrors];

export type CreateDeploymentResponses = {
    /**
     * The resources are deployed.
     */
    200: DeploymentResult;
};

export type CreateDeploymentResponse = CreateDeploymentResponses[keyof CreateDeploymentResponses];

export type CreateDocumentData = {
    body: {
        file: Blob | File;
        metadata?: DocumentMetadata;
    };
    path?: never;
    query?: {
        /**
         * The ID of the document store to upload the documents to. Currently, only a single document store is supported per cluster. However, this attribute is included to allow for potential future support of multiple document stores.
         */
        storeId?: string;
        /**
         * The ID of the document to upload. If not provided, a new ID will be generated. Specifying an existing ID will result in an error if the document already exists.
         *
         */
        documentId?: DocumentId;
    };
    url: '/documents';
};

export type CreateDocumentErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The server cannot process the request because the media type (Content-Type) of the request payload is not supported
     * by the server for the requested resource and method.
     *
     */
    415: ProblemDetail;
};

export type CreateDocumentError = CreateDocumentErrors[keyof CreateDocumentErrors];

export type CreateDocumentResponses = {
    /**
     * The document was uploaded successfully.
     */
    201: DocumentReference;
};

export type CreateDocumentResponse = CreateDocumentResponses[keyof CreateDocumentResponses];

export type CreateDocumentsData = {
    body: {
        /**
         * The documents to upload.
         */
        files: Array<Blob | File>;
        /**
         * Optional JSON array of metadata object whose index aligns with each file entry. The metadata array must have the same length as the files array.
         *
         */
        metadataList?: Array<DocumentMetadata>;
    };
    path?: never;
    query?: {
        /**
         * The ID of the document store to upload the documents to. Currently, only a single document store is supported per cluster. However, this attribute is included to allow for potential future support of multiple document stores.
         */
        storeId?: string;
    };
    url: '/documents/batch';
};

export type CreateDocumentsErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The server cannot process the request because the media type (Content-Type) of the request payload is not supported
     * by the server for the requested resource and method.
     *
     */
    415: ProblemDetail;
};

export type CreateDocumentsError = CreateDocumentsErrors[keyof CreateDocumentsErrors];

export type CreateDocumentsResponses = {
    /**
     * All documents were uploaded successfully.
     */
    201: DocumentCreationBatchResponse;
    /**
     * Some documents were uploaded successfully, others failed.
     */
    207: DocumentCreationBatchResponse;
};

export type CreateDocumentsResponse = CreateDocumentsResponses[keyof CreateDocumentsResponses];

export type DeleteDocumentData = {
    body?: never;
    path: {
        /**
         * The ID of the document to delete.
         */
        documentId: DocumentId;
    };
    query?: {
        /**
         * The ID of the document store to delete the document from.
         */
        storeId?: string;
    };
    url: '/documents/{documentId}';
};

export type DeleteDocumentErrors = {
    /**
     * The document with the given ID was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type DeleteDocumentError = DeleteDocumentErrors[keyof DeleteDocumentErrors];

export type DeleteDocumentResponses = {
    /**
     * The document was deleted successfully.
     */
    204: void;
};

export type DeleteDocumentResponse = DeleteDocumentResponses[keyof DeleteDocumentResponses];

export type GetDocumentData = {
    body?: never;
    path: {
        /**
         * The ID of the document to download.
         */
        documentId: DocumentId;
    };
    query?: {
        /**
         * The ID of the document store to download the document from.
         */
        storeId?: string;
        /**
         * The hash of the document content that was computed by the document store during upload. The hash is part of the document reference that is returned when uploading a document. If the client fails to provide the correct hash, the request will be rejected.
         *
         */
        contentHash?: string;
    };
    url: '/documents/{documentId}';
};

export type GetDocumentErrors = {
    /**
     * The document with the given ID was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type GetDocumentError = GetDocumentErrors[keyof GetDocumentErrors];

export type GetDocumentResponses = {
    /**
     * The document was downloaded successfully.
     */
    200: Blob | File;
};

export type GetDocumentResponse = GetDocumentResponses[keyof GetDocumentResponses];

export type CreateDocumentLinkData = {
    body?: DocumentLinkRequest;
    path: {
        /**
         * The ID of the document to link.
         */
        documentId: DocumentId;
    };
    query?: {
        /**
         * The ID of the document store where the document is located.
         */
        storeId?: string;
        /**
         * The hash of the document content that was computed by the document store during upload. The hash is part of the document reference that is returned when uploading a document. If the client fails to provide the correct hash, the request will be rejected.
         *
         */
        contentHash?: string;
    };
    url: '/documents/{documentId}/links';
};

export type CreateDocumentLinkErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
};

export type CreateDocumentLinkError = CreateDocumentLinkErrors[keyof CreateDocumentLinkErrors];

export type CreateDocumentLinkResponses = {
    /**
     * The document link was created successfully.
     */
    201: DocumentLink;
};

export type CreateDocumentLinkResponse = CreateDocumentLinkResponses[keyof CreateDocumentLinkResponses];

export type ActivateAdHocSubProcessActivitiesData = {
    body: AdHocSubProcessActivateActivitiesInstruction;
    path: {
        /**
         * The key of the ad-hoc sub-process instance that contains the activities.
         */
        adHocSubProcessInstanceKey: ElementInstanceKey;
    };
    query?: never;
    url: '/element-instances/ad-hoc-activities/{adHocSubProcessInstanceKey}/activation';
};

export type ActivateAdHocSubProcessActivitiesErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The ad-hoc sub-process instance is not found or the provided key does not identify an ad-hoc sub-process.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type ActivateAdHocSubProcessActivitiesError = ActivateAdHocSubProcessActivitiesErrors[keyof ActivateAdHocSubProcessActivitiesErrors];

export type ActivateAdHocSubProcessActivitiesResponses = {
    /**
     * The ad-hoc sub-process instance is modified.
     */
    204: void;
};

export type ActivateAdHocSubProcessActivitiesResponse = ActivateAdHocSubProcessActivitiesResponses[keyof ActivateAdHocSubProcessActivitiesResponses];

export type SearchElementInstancesData = {
    body?: ElementInstanceSearchQuery;
    path?: never;
    query?: never;
    url: '/element-instances/search';
};

export type SearchElementInstancesErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type SearchElementInstancesError = SearchElementInstancesErrors[keyof SearchElementInstancesErrors];

export type SearchElementInstancesResponses = {
    /**
     * The element instance search result.
     */
    200: ElementInstanceSearchQueryResult;
};

export type SearchElementInstancesResponse = SearchElementInstancesResponses[keyof SearchElementInstancesResponses];

export type GetElementInstanceData = {
    body?: never;
    path: {
        /**
         * The assigned key of the element instance, which acts as a unique identifier for this element instance.
         */
        elementInstanceKey: ElementInstanceKey;
    };
    query?: never;
    url: '/element-instances/{elementInstanceKey}';
};

export type GetElementInstanceErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The element instance with the given key was not found.
     * More details are provided in the response body.
     *
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type GetElementInstanceError = GetElementInstanceErrors[keyof GetElementInstanceErrors];

export type GetElementInstanceResponses = {
    /**
     * The element instance is successfully returned.
     */
    200: ElementInstanceResult;
};

export type GetElementInstanceResponse = GetElementInstanceResponses[keyof GetElementInstanceResponses];

export type SearchElementInstanceIncidentsData = {
    body: IncidentSearchQuery;
    path: {
        /**
         * The unique key of the element instance to search incidents for.
         */
        elementInstanceKey: ElementInstanceKey;
    };
    query?: never;
    url: '/element-instances/{elementInstanceKey}/incidents/search';
};

export type SearchElementInstanceIncidentsErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The element instance with the given key was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type SearchElementInstanceIncidentsError = SearchElementInstanceIncidentsErrors[keyof SearchElementInstanceIncidentsErrors];

export type SearchElementInstanceIncidentsResponses = {
    /**
     * The element instance incident search result.
     */
    200: IncidentSearchQueryResult;
};

export type SearchElementInstanceIncidentsResponse = SearchElementInstanceIncidentsResponses[keyof SearchElementInstanceIncidentsResponses];

export type CreateElementInstanceVariablesData = {
    body: SetVariableRequest;
    path: {
        /**
         * The key of the element instance to update the variables for.
         * This can be the process instance key (as obtained during instance creation), or a given
         * element, such as a service task (see the `elementInstanceKey` on the job message).
         *
         */
        elementInstanceKey: ElementInstanceKey;
    };
    query?: never;
    url: '/element-instances/{elementInstanceKey}/variables';
};

export type CreateElementInstanceVariablesErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type CreateElementInstanceVariablesError = CreateElementInstanceVariablesErrors[keyof CreateElementInstanceVariablesErrors];

export type CreateElementInstanceVariablesResponses = {
    /**
     * The variables were updated.
     */
    204: void;
};

export type CreateElementInstanceVariablesResponse = CreateElementInstanceVariablesResponses[keyof CreateElementInstanceVariablesResponses];

export type EvaluateExpressionData = {
    body: ExpressionEvaluationRequest;
    path?: never;
    query?: never;
    url: '/expression/evaluation';
};

export type EvaluateExpressionErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type EvaluateExpressionError = EvaluateExpressionErrors[keyof EvaluateExpressionErrors];

export type EvaluateExpressionResponses = {
    /**
     * Expression evaluated successfully
     */
    200: ExpressionEvaluationResult;
};

export type EvaluateExpressionResponse = EvaluateExpressionResponses[keyof EvaluateExpressionResponses];

export type CreateGlobalTaskListenerData = {
    body: CreateGlobalTaskListenerRequest;
    path?: never;
    query?: never;
    url: '/global-listeners/user-task';
};

export type CreateGlobalTaskListenerErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * A global listener with this id already exists.
     */
    409: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type CreateGlobalTaskListenerError = CreateGlobalTaskListenerErrors[keyof CreateGlobalTaskListenerErrors];

export type CreateGlobalTaskListenerResponses = {
    /**
     * The global user task listener was created successfully.
     */
    201: GlobalTaskListenerResult;
};

export type CreateGlobalTaskListenerResponse = CreateGlobalTaskListenerResponses[keyof CreateGlobalTaskListenerResponses];

export type DeleteGlobalTaskListenerData = {
    body?: never;
    path: {
        /**
         * The id of the global user task listener to delete.
         */
        id: GlobalListenerId;
    };
    query?: never;
    url: '/global-listeners/user-task/{id}';
};

export type DeleteGlobalTaskListenerErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The global user task listener was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type DeleteGlobalTaskListenerError = DeleteGlobalTaskListenerErrors[keyof DeleteGlobalTaskListenerErrors];

export type DeleteGlobalTaskListenerResponses = {
    /**
     * The global listener was deleted successfully.
     */
    204: void;
};

export type DeleteGlobalTaskListenerResponse = DeleteGlobalTaskListenerResponses[keyof DeleteGlobalTaskListenerResponses];

export type UpdateGlobalTaskListenerData = {
    body: UpdateGlobalTaskListenerRequest;
    path: {
        /**
         * The id of the global user task listener to update.
         */
        id: GlobalListenerId;
    };
    query?: never;
    url: '/global-listeners/user-task/{id}';
};

export type UpdateGlobalTaskListenerErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The global user task listener was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type UpdateGlobalTaskListenerError = UpdateGlobalTaskListenerErrors[keyof UpdateGlobalTaskListenerErrors];

export type UpdateGlobalTaskListenerResponses = {
    /**
     * The global listener was updated successfully.
     */
    200: GlobalTaskListenerResult;
};

export type UpdateGlobalTaskListenerResponse = UpdateGlobalTaskListenerResponses[keyof UpdateGlobalTaskListenerResponses];

export type CreateGroupData = {
    body?: GroupCreateRequest;
    path?: never;
    query?: never;
    url: '/groups';
};

export type CreateGroupErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type CreateGroupError = CreateGroupErrors[keyof CreateGroupErrors];

export type CreateGroupResponses = {
    /**
     * The group was created successfully.
     */
    201: GroupCreateResult;
};

export type CreateGroupResponse = CreateGroupResponses[keyof CreateGroupResponses];

export type SearchGroupsData = {
    body?: GroupSearchQueryRequest;
    path?: never;
    query?: never;
    url: '/groups/search';
};

export type SearchGroupsErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: unknown;
};

export type SearchGroupsError = SearchGroupsErrors[keyof SearchGroupsErrors];

export type SearchGroupsResponses = {
    /**
     * The groups search result.
     */
    200: GroupSearchQueryResult;
};

export type SearchGroupsResponse = SearchGroupsResponses[keyof SearchGroupsResponses];

export type DeleteGroupData = {
    body?: never;
    path: {
        /**
         * The group ID.
         */
        groupId: string;
    };
    query?: never;
    url: '/groups/{groupId}';
};

export type DeleteGroupErrors = {
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * The group with the given ID was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type DeleteGroupError = DeleteGroupErrors[keyof DeleteGroupErrors];

export type DeleteGroupResponses = {
    /**
     * The group was deleted successfully.
     */
    204: void;
};

export type DeleteGroupResponse = DeleteGroupResponses[keyof DeleteGroupResponses];

export type GetGroupData = {
    body?: never;
    path: {
        /**
         * The group ID.
         */
        groupId: string;
    };
    query?: never;
    url: '/groups/{groupId}';
};

export type GetGroupErrors = {
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The group with the given ID was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type GetGroupError = GetGroupErrors[keyof GetGroupErrors];

export type GetGroupResponses = {
    /**
     * The group is successfully returned.
     */
    200: GroupResult;
};

export type GetGroupResponse = GetGroupResponses[keyof GetGroupResponses];

export type UpdateGroupData = {
    body: GroupUpdateRequest;
    path: {
        /**
         * The group ID.
         */
        groupId: string;
    };
    query?: never;
    url: '/groups/{groupId}';
};

export type UpdateGroupErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * The group with the given ID was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type UpdateGroupError = UpdateGroupErrors[keyof UpdateGroupErrors];

export type UpdateGroupResponses = {
    /**
     * The group was updated successfully.
     */
    200: GroupUpdateResult;
};

export type UpdateGroupResponse = UpdateGroupResponses[keyof UpdateGroupResponses];

export type SearchClientsForGroupData = {
    body?: SearchQueryRequest & {
        /**
         * Sort field criteria.
         */
        sort?: Array<{
            /**
             * The field to sort by.
             */
            field: 'clientId';
            order?: SortOrderEnum;
        }>;
    };
    path: {
        /**
         * The group ID.
         */
        groupId: string;
    };
    query?: never;
    url: '/groups/{groupId}/clients/search';
};

export type SearchClientsForGroupErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The group with the given ID was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type SearchClientsForGroupError = SearchClientsForGroupErrors[keyof SearchClientsForGroupErrors];

export type SearchClientsForGroupResponses = {
    /**
     * The clients assigned to the group.
     */
    200: SearchQueryResponse & {
        /**
         * The matching client IDs.
         */
        items?: Array<{
            /**
             * The ID of the client.
             */
            clientId?: string;
        }>;
    };
};

export type SearchClientsForGroupResponse = SearchClientsForGroupResponses[keyof SearchClientsForGroupResponses];

export type UnassignClientFromGroupData = {
    body?: never;
    path: {
        /**
         * The group ID.
         */
        groupId: string;
        /**
         * The client ID.
         */
        clientId: string;
    };
    query?: never;
    url: '/groups/{groupId}/clients/{clientId}';
};

export type UnassignClientFromGroupErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The group with the given ID was not found, or the client is not assigned to this group.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type UnassignClientFromGroupError = UnassignClientFromGroupErrors[keyof UnassignClientFromGroupErrors];

export type UnassignClientFromGroupResponses = {
    /**
     * The client was unassigned successfully from the group.
     */
    204: void;
};

export type UnassignClientFromGroupResponse = UnassignClientFromGroupResponses[keyof UnassignClientFromGroupResponses];

export type AssignClientToGroupData = {
    body?: never;
    path: {
        /**
         * The group ID.
         */
        groupId: string;
        /**
         * The client ID.
         */
        clientId: string;
    };
    query?: never;
    url: '/groups/{groupId}/clients/{clientId}';
};

export type AssignClientToGroupErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The group with the given ID was not found.
     */
    404: ProblemDetail;
    /**
     * The client with the given ID is already assigned to the group.
     */
    409: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type AssignClientToGroupError = AssignClientToGroupErrors[keyof AssignClientToGroupErrors];

export type AssignClientToGroupResponses = {
    /**
     * The client was assigned successfully to the group.
     */
    204: void;
};

export type AssignClientToGroupResponse = AssignClientToGroupResponses[keyof AssignClientToGroupResponses];

export type SearchMappingRulesForGroupData = {
    body?: MappingRuleSearchQueryRequest;
    path: {
        /**
         * The group ID.
         */
        groupId: string;
    };
    query?: never;
    url: '/groups/{groupId}/mapping-rules/search';
};

export type SearchMappingRulesForGroupErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The group with the given ID was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type SearchMappingRulesForGroupError = SearchMappingRulesForGroupErrors[keyof SearchMappingRulesForGroupErrors];

export type SearchMappingRulesForGroupResponses = {
    /**
     * The mapping rules assigned to the group.
     */
    200: SearchQueryResponse;
};

export type SearchMappingRulesForGroupResponse = SearchMappingRulesForGroupResponses[keyof SearchMappingRulesForGroupResponses];

export type UnassignMappingRuleFromGroupData = {
    body?: never;
    path: {
        /**
         * The group ID.
         */
        groupId: string;
        /**
         * The mapping rule ID.
         */
        mappingRuleId: string;
    };
    query?: never;
    url: '/groups/{groupId}/mapping-rules/{mappingRuleId}';
};

export type UnassignMappingRuleFromGroupErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The group or mapping rule with the given ID was not found, or the mapping rule is not assigned to this group.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type UnassignMappingRuleFromGroupError = UnassignMappingRuleFromGroupErrors[keyof UnassignMappingRuleFromGroupErrors];

export type UnassignMappingRuleFromGroupResponses = {
    /**
     * The mapping rule was unassigned successfully from the group.
     */
    204: void;
};

export type UnassignMappingRuleFromGroupResponse = UnassignMappingRuleFromGroupResponses[keyof UnassignMappingRuleFromGroupResponses];

export type AssignMappingRuleToGroupData = {
    body?: never;
    path: {
        /**
         * The group ID.
         */
        groupId: string;
        /**
         * The mapping rule ID.
         */
        mappingRuleId: string;
    };
    query?: never;
    url: '/groups/{groupId}/mapping-rules/{mappingRuleId}';
};

export type AssignMappingRuleToGroupErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The group or mapping rule with the given ID was not found.
     */
    404: ProblemDetail;
    /**
     * The mapping rule with the given ID is already assigned to the group.
     */
    409: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type AssignMappingRuleToGroupError = AssignMappingRuleToGroupErrors[keyof AssignMappingRuleToGroupErrors];

export type AssignMappingRuleToGroupResponses = {
    /**
     * The mapping rule was assigned successfully to the group.
     */
    204: void;
};

export type AssignMappingRuleToGroupResponse = AssignMappingRuleToGroupResponses[keyof AssignMappingRuleToGroupResponses];

export type SearchRolesForGroupData = {
    body?: RoleSearchQueryRequest;
    path: {
        /**
         * The group ID.
         */
        groupId: string;
    };
    query?: never;
    url: '/groups/{groupId}/roles/search';
};

export type SearchRolesForGroupErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The group with the given ID was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type SearchRolesForGroupError = SearchRolesForGroupErrors[keyof SearchRolesForGroupErrors];

export type SearchRolesForGroupResponses = {
    /**
     * The roles assigned to the group.
     */
    200: SearchQueryResponse;
};

export type SearchRolesForGroupResponse = SearchRolesForGroupResponses[keyof SearchRolesForGroupResponses];

export type SearchUsersForGroupData = {
    body?: SearchQueryRequest & {
        /**
         * Sort field criteria.
         */
        sort?: Array<{
            /**
             * The field to sort by.
             */
            field: 'username';
            order?: SortOrderEnum;
        }>;
    };
    path: {
        /**
         * The group ID.
         */
        groupId: string;
    };
    query?: never;
    url: '/groups/{groupId}/users/search';
};

export type SearchUsersForGroupErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The group with the given ID was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type SearchUsersForGroupError = SearchUsersForGroupErrors[keyof SearchUsersForGroupErrors];

export type SearchUsersForGroupResponses = {
    /**
     * The users assigned to the group.
     */
    200: SearchQueryResponse & {
        /**
         * The matching members.
         */
        items?: Array<{
            username?: Username;
        }>;
    };
};

export type SearchUsersForGroupResponse = SearchUsersForGroupResponses[keyof SearchUsersForGroupResponses];

export type UnassignUserFromGroupData = {
    body?: never;
    path: {
        /**
         * The group ID.
         */
        groupId: string;
        /**
         * The user username.
         */
        username: Username;
    };
    query?: never;
    url: '/groups/{groupId}/users/{username}';
};

export type UnassignUserFromGroupErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The group or user with the given ID was not found, or the user is not assigned to this group.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type UnassignUserFromGroupError = UnassignUserFromGroupErrors[keyof UnassignUserFromGroupErrors];

export type UnassignUserFromGroupResponses = {
    /**
     * The user was unassigned successfully from the group.
     */
    204: void;
};

export type UnassignUserFromGroupResponse = UnassignUserFromGroupResponses[keyof UnassignUserFromGroupResponses];

export type AssignUserToGroupData = {
    body?: never;
    path: {
        /**
         * The group ID.
         */
        groupId: string;
        /**
         * The user username.
         */
        username: Username;
    };
    query?: never;
    url: '/groups/{groupId}/users/{username}';
};

export type AssignUserToGroupErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The group or user with the given ID or username was not found.
     */
    404: ProblemDetail;
    /**
     * The user with the given ID is already assigned to the group.
     */
    409: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type AssignUserToGroupError = AssignUserToGroupErrors[keyof AssignUserToGroupErrors];

export type AssignUserToGroupResponses = {
    /**
     * The user was assigned successfully to the group.
     */
    204: void;
};

export type AssignUserToGroupResponse = AssignUserToGroupResponses[keyof AssignUserToGroupResponses];

export type SearchIncidentsData = {
    body?: IncidentSearchQuery;
    path?: never;
    query?: never;
    url: '/incidents/search';
};

export type SearchIncidentsErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type SearchIncidentsError = SearchIncidentsErrors[keyof SearchIncidentsErrors];

export type SearchIncidentsResponses = {
    /**
     * The incident search result.
     */
    200: IncidentSearchQueryResult;
};

export type SearchIncidentsResponse = SearchIncidentsResponses[keyof SearchIncidentsResponses];

export type GetIncidentData = {
    body?: never;
    path: {
        /**
         * The assigned key of the incident, which acts as a unique identifier for this incident.
         */
        incidentKey: IncidentKey;
    };
    query?: never;
    url: '/incidents/{incidentKey}';
};

export type GetIncidentErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The incident with the given key was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type GetIncidentError = GetIncidentErrors[keyof GetIncidentErrors];

export type GetIncidentResponses = {
    /**
     * The incident is successfully returned.
     */
    200: IncidentResult;
};

export type GetIncidentResponse = GetIncidentResponses[keyof GetIncidentResponses];

export type ResolveIncidentData = {
    body?: IncidentResolutionRequest;
    path: {
        /**
         * Key of the incident to resolve.
         */
        incidentKey: IncidentKey;
    };
    query?: never;
    url: '/incidents/{incidentKey}/resolution';
};

export type ResolveIncidentErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The incident with the incidentKey is not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type ResolveIncidentError = ResolveIncidentErrors[keyof ResolveIncidentErrors];

export type ResolveIncidentResponses = {
    /**
     * The incident is marked as resolved.
     */
    204: void;
};

export type ResolveIncidentResponse = ResolveIncidentResponses[keyof ResolveIncidentResponses];

export type GetProcessInstanceStatisticsByDefinitionData = {
    body: IncidentProcessInstanceStatisticsByDefinitionQuery;
    path?: never;
    query?: never;
    url: '/incidents/statistics/process-instances-by-definition';
};

export type GetProcessInstanceStatisticsByDefinitionErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type GetProcessInstanceStatisticsByDefinitionError = GetProcessInstanceStatisticsByDefinitionErrors[keyof GetProcessInstanceStatisticsByDefinitionErrors];

export type GetProcessInstanceStatisticsByDefinitionResponses = {
    /**
     * The process instance incident statistics grouped by process definition are successfully
     * returned.
     *
     */
    200: IncidentProcessInstanceStatisticsByDefinitionQueryResult;
};

export type GetProcessInstanceStatisticsByDefinitionResponse = GetProcessInstanceStatisticsByDefinitionResponses[keyof GetProcessInstanceStatisticsByDefinitionResponses];

export type GetProcessInstanceStatisticsByErrorData = {
    body?: IncidentProcessInstanceStatisticsByErrorQuery;
    path?: never;
    query?: never;
    url: '/incidents/statistics/process-instances-by-error';
};

export type GetProcessInstanceStatisticsByErrorErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type GetProcessInstanceStatisticsByErrorError = GetProcessInstanceStatisticsByErrorErrors[keyof GetProcessInstanceStatisticsByErrorErrors];

export type GetProcessInstanceStatisticsByErrorResponses = {
    /**
     * The statistics about process instances with incident, grouped by error hash code are
     * successfully returned.
     *
     */
    200: IncidentProcessInstanceStatisticsByErrorQueryResult;
};

export type GetProcessInstanceStatisticsByErrorResponse = GetProcessInstanceStatisticsByErrorResponses[keyof GetProcessInstanceStatisticsByErrorResponses];

export type ActivateJobsData = {
    body: JobActivationRequest;
    path?: never;
    query?: never;
    url: '/jobs/activation';
};

export type ActivateJobsErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type ActivateJobsError = ActivateJobsErrors[keyof ActivateJobsErrors];

export type ActivateJobsResponses = {
    /**
     * The list of activated jobs.
     */
    200: JobActivationResult;
};

export type ActivateJobsResponse = ActivateJobsResponses[keyof ActivateJobsResponses];

export type SearchJobsData = {
    body?: JobSearchQuery;
    path?: never;
    query?: never;
    url: '/jobs/search';
};

export type SearchJobsErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type SearchJobsError = SearchJobsErrors[keyof SearchJobsErrors];

export type SearchJobsResponses = {
    /**
     * The job search result.
     */
    200: JobSearchQueryResult;
};

export type SearchJobsResponse = SearchJobsResponses[keyof SearchJobsResponses];

export type UpdateJobData = {
    body: JobUpdateRequest;
    path: {
        /**
         * The key of the job to update.
         */
        jobKey: JobKey;
    };
    query?: never;
    url: '/jobs/{jobKey}';
};

export type UpdateJobErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The job with the jobKey is not found.
     */
    404: ProblemDetail;
    /**
     * The job with the given key is in the wrong state currently. More details are provided in the response body.
     *
     */
    409: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type UpdateJobError = UpdateJobErrors[keyof UpdateJobErrors];

export type UpdateJobResponses = {
    /**
     * The job was updated successfully.
     */
    204: void;
};

export type UpdateJobResponse = UpdateJobResponses[keyof UpdateJobResponses];

export type CompleteJobData = {
    body?: JobCompletionRequest;
    path: {
        /**
         * The key of the job to complete.
         */
        jobKey: JobKey;
    };
    query?: never;
    url: '/jobs/{jobKey}/completion';
};

export type CompleteJobErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The job with the given key was not found.
     */
    404: ProblemDetail;
    /**
     * The job with the given key is in the wrong state currently. More details are provided in the response body.
     *
     */
    409: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type CompleteJobError = CompleteJobErrors[keyof CompleteJobErrors];

export type CompleteJobResponses = {
    /**
     * The job was completed successfully.
     */
    204: void;
};

export type CompleteJobResponse = CompleteJobResponses[keyof CompleteJobResponses];

export type ThrowJobErrorData = {
    body: JobErrorRequest;
    path: {
        /**
         * The key of the job.
         */
        jobKey: JobKey;
    };
    query?: never;
    url: '/jobs/{jobKey}/error';
};

export type ThrowJobErrorErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The job with the given key was not found or is not activated.
     *
     */
    404: ProblemDetail;
    /**
     * The job with the given key is in the wrong state currently. More details are provided in the response body.
     *
     */
    409: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type ThrowJobErrorError = ThrowJobErrorErrors[keyof ThrowJobErrorErrors];

export type ThrowJobErrorResponses = {
    /**
     * An error is thrown for the job.
     */
    204: void;
};

export type ThrowJobErrorResponse = ThrowJobErrorResponses[keyof ThrowJobErrorResponses];

export type FailJobData = {
    body?: JobFailRequest;
    path: {
        /**
         * The key of the job to fail.
         */
        jobKey: JobKey;
    };
    query?: never;
    url: '/jobs/{jobKey}/failure';
};

export type FailJobErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The job with the given jobKey is not found. It was completed by another worker, or the process instance itself was canceled.
     *
     */
    404: ProblemDetail;
    /**
     * The job with the given key is in the wrong state (i.e: not ACTIVATED or ACTIVATABLE). The job was failed by another worker with retries = 0, and the process is now in an incident state.
     *
     */
    409: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type FailJobError = FailJobErrors[keyof FailJobErrors];

export type FailJobResponses = {
    /**
     * The job is failed.
     */
    204: void;
};

export type FailJobResponse = FailJobResponses[keyof FailJobResponses];

export type GetGlobalJobStatisticsData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Start of the time window to filter metrics. ISO 8601 date-time format.
         *
         */
        from: string;
        /**
         * End of the time window to filter metrics. ISO 8601 date-time format.
         *
         */
        to: string;
        /**
         * Optional job type to limit the aggregation to a single job type.
         */
        jobType?: string;
    };
    url: '/jobs/statistics/global';
};

export type GetGlobalJobStatisticsErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type GetGlobalJobStatisticsError = GetGlobalJobStatisticsErrors[keyof GetGlobalJobStatisticsErrors];

export type GetGlobalJobStatisticsResponses = {
    /**
     * Global job metrics
     */
    200: GlobalJobStatisticsQueryResult;
};

export type GetGlobalJobStatisticsResponse = GetGlobalJobStatisticsResponses[keyof GetGlobalJobStatisticsResponses];

export type GetLicenseData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/license';
};

export type GetLicenseErrors = {
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type GetLicenseError = GetLicenseErrors[keyof GetLicenseErrors];

export type GetLicenseResponses = {
    /**
     * Obtains the current status of the Camunda license.
     */
    200: LicenseResponse;
};

export type GetLicenseResponse = GetLicenseResponses[keyof GetLicenseResponses];

export type CreateMappingRuleData = {
    body?: MappingRuleCreateRequest;
    path?: never;
    query?: never;
    url: '/mapping-rules';
};

export type CreateMappingRuleErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request to create a mapping rule was denied.
     * More details are provided in the response body.
     *
     */
    403: ProblemDetail;
    /**
     * The request to create a mapping rule was denied.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type CreateMappingRuleError = CreateMappingRuleErrors[keyof CreateMappingRuleErrors];

export type CreateMappingRuleResponses = {
    /**
     * The mapping rule was created successfully.
     */
    201: MappingRuleCreateUpdateResult;
};

export type CreateMappingRuleResponse = CreateMappingRuleResponses[keyof CreateMappingRuleResponses];

export type SearchMappingRuleData = {
    body?: MappingRuleSearchQueryRequest;
    path?: never;
    query?: never;
    url: '/mapping-rules/search';
};

export type SearchMappingRuleErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type SearchMappingRuleError = SearchMappingRuleErrors[keyof SearchMappingRuleErrors];

export type SearchMappingRuleResponses = {
    /**
     * The mapping rule search result.
     */
    200: MappingRuleSearchQueryResult;
};

export type SearchMappingRuleResponse = SearchMappingRuleResponses[keyof SearchMappingRuleResponses];

export type DeleteMappingRuleData = {
    body?: never;
    path: {
        /**
         * The ID of the mapping rule to delete.
         */
        mappingRuleId: string;
    };
    query?: never;
    url: '/mapping-rules/{mappingRuleId}';
};

export type DeleteMappingRuleErrors = {
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * The mapping rule with the mappingRuleId was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type DeleteMappingRuleError = DeleteMappingRuleErrors[keyof DeleteMappingRuleErrors];

export type DeleteMappingRuleResponses = {
    /**
     * The mapping rule was deleted successfully.
     */
    204: void;
};

export type DeleteMappingRuleResponse = DeleteMappingRuleResponses[keyof DeleteMappingRuleResponses];

export type GetMappingRuleData = {
    body?: never;
    path: {
        /**
         * The ID of the mapping rule to get.
         */
        mappingRuleId: string;
    };
    query?: never;
    url: '/mapping-rules/{mappingRuleId}';
};

export type GetMappingRuleErrors = {
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * The mapping rule with the mappingRuleId was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type GetMappingRuleError = GetMappingRuleErrors[keyof GetMappingRuleErrors];

export type GetMappingRuleResponses = {
    /**
     * The mapping rule was returned successfully.
     */
    200: MappingRuleResult;
};

export type GetMappingRuleResponse = GetMappingRuleResponses[keyof GetMappingRuleResponses];

export type UpdateMappingRuleData = {
    body?: MappingRuleUpdateRequest;
    path: {
        /**
         * The ID of the mapping rule to update.
         */
        mappingRuleId: string;
    };
    query?: never;
    url: '/mapping-rules/{mappingRuleId}';
};

export type UpdateMappingRuleErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request to update a mapping rule was denied.
     * More details are provided in the response body.
     *
     */
    403: ProblemDetail;
    /**
     * The request to update a mapping rule was denied.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type UpdateMappingRuleError = UpdateMappingRuleErrors[keyof UpdateMappingRuleErrors];

export type UpdateMappingRuleResponses = {
    /**
     * The mapping rule was updated successfully.
     */
    200: MappingRuleCreateUpdateResult;
};

export type UpdateMappingRuleResponse = UpdateMappingRuleResponses[keyof UpdateMappingRuleResponses];

export type SearchMessageSubscriptionsData = {
    body?: MessageSubscriptionSearchQuery;
    path?: never;
    query?: never;
    url: '/message-subscriptions/search';
};

export type SearchMessageSubscriptionsErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type SearchMessageSubscriptionsError = SearchMessageSubscriptionsErrors[keyof SearchMessageSubscriptionsErrors];

export type SearchMessageSubscriptionsResponses = {
    /**
     * The message subscription search result.
     */
    200: MessageSubscriptionSearchQueryResult;
};

export type SearchMessageSubscriptionsResponse = SearchMessageSubscriptionsResponses[keyof SearchMessageSubscriptionsResponses];

export type CorrelateMessageData = {
    body: MessageCorrelationRequest;
    path?: never;
    query?: never;
    url: '/messages/correlation';
};

export type CorrelateMessageErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * Not found
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type CorrelateMessageError = CorrelateMessageErrors[keyof CorrelateMessageErrors];

export type CorrelateMessageResponses = {
    /**
     * The message is correlated to one or more process instances
     */
    200: MessageCorrelationResult;
};

export type CorrelateMessageResponse = CorrelateMessageResponses[keyof CorrelateMessageResponses];

export type PublishMessageData = {
    body: MessagePublicationRequest;
    path?: never;
    query?: never;
    url: '/messages/publication';
};

export type PublishMessageErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type PublishMessageError = PublishMessageErrors[keyof PublishMessageErrors];

export type PublishMessageResponses = {
    /**
     * The message was published.
     */
    200: MessagePublicationResult;
};

export type PublishMessageResponse = PublishMessageResponses[keyof PublishMessageResponses];

export type SearchProcessDefinitionsData = {
    body?: ProcessDefinitionSearchQuery;
    path?: never;
    query?: never;
    url: '/process-definitions/search';
};

export type SearchProcessDefinitionsErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type SearchProcessDefinitionsError = SearchProcessDefinitionsErrors[keyof SearchProcessDefinitionsErrors];

export type SearchProcessDefinitionsResponses = {
    /**
     * The process definition search result.
     */
    200: ProcessDefinitionSearchQueryResult;
};

export type SearchProcessDefinitionsResponse = SearchProcessDefinitionsResponses[keyof SearchProcessDefinitionsResponses];

export type GetProcessDefinitionMessageSubscriptionStatisticsData = {
    body?: ProcessDefinitionMessageSubscriptionStatisticsQuery;
    path?: never;
    query?: never;
    url: '/process-definitions/statistics/message-subscriptions';
};

export type GetProcessDefinitionMessageSubscriptionStatisticsErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type GetProcessDefinitionMessageSubscriptionStatisticsError = GetProcessDefinitionMessageSubscriptionStatisticsErrors[keyof GetProcessDefinitionMessageSubscriptionStatisticsErrors];

export type GetProcessDefinitionMessageSubscriptionStatisticsResponses = {
    /**
     * The process definition message subscription statistics result.
     */
    200: ProcessDefinitionMessageSubscriptionStatisticsQueryResult;
};

export type GetProcessDefinitionMessageSubscriptionStatisticsResponse = GetProcessDefinitionMessageSubscriptionStatisticsResponses[keyof GetProcessDefinitionMessageSubscriptionStatisticsResponses];

export type GetProcessDefinitionInstanceStatisticsData = {
    body?: ProcessDefinitionInstanceStatisticsQuery;
    path?: never;
    query?: never;
    url: '/process-definitions/statistics/process-instances';
};

export type GetProcessDefinitionInstanceStatisticsErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type GetProcessDefinitionInstanceStatisticsError = GetProcessDefinitionInstanceStatisticsErrors[keyof GetProcessDefinitionInstanceStatisticsErrors];

export type GetProcessDefinitionInstanceStatisticsResponses = {
    /**
     * The process definition instance statistic result.
     */
    200: ProcessDefinitionInstanceStatisticsQueryResult;
};

export type GetProcessDefinitionInstanceStatisticsResponse = GetProcessDefinitionInstanceStatisticsResponses[keyof GetProcessDefinitionInstanceStatisticsResponses];

export type GetProcessDefinitionData = {
    body?: never;
    path: {
        /**
         * The assigned key of the process definition, which acts as a unique identifier for this process definition.
         *
         */
        processDefinitionKey: ProcessDefinitionKey;
    };
    query?: never;
    url: '/process-definitions/{processDefinitionKey}';
};

export type GetProcessDefinitionErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The process definition with the given key was not found. More details are provided in the response body.
     *
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type GetProcessDefinitionError = GetProcessDefinitionErrors[keyof GetProcessDefinitionErrors];

export type GetProcessDefinitionResponses = {
    /**
     * The process definition is successfully returned.
     */
    200: ProcessDefinitionResult;
};

export type GetProcessDefinitionResponse = GetProcessDefinitionResponses[keyof GetProcessDefinitionResponses];

export type GetStartProcessFormData = {
    body?: never;
    path: {
        /**
         * The process key.
         */
        processDefinitionKey: ProcessDefinitionKey;
    };
    query?: never;
    url: '/process-definitions/{processDefinitionKey}/form';
};

export type GetStartProcessFormErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * Not found
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type GetStartProcessFormError = GetStartProcessFormErrors[keyof GetStartProcessFormErrors];

export type GetStartProcessFormResponses = {
    /**
     * The form is successfully returned.
     */
    200: FormResult;
    /**
     * The process was found, but no form is associated with it.
     */
    204: void;
};

export type GetStartProcessFormResponse = GetStartProcessFormResponses[keyof GetStartProcessFormResponses];

export type GetProcessDefinitionStatisticsData = {
    body?: ProcessDefinitionElementStatisticsQuery;
    path: {
        /**
         * The assigned key of the process definition, which acts as a unique identifier for this process definition.
         */
        processDefinitionKey: ProcessDefinitionKey;
    };
    query?: never;
    url: '/process-definitions/{processDefinitionKey}/statistics/element-instances';
};

export type GetProcessDefinitionStatisticsErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type GetProcessDefinitionStatisticsError = GetProcessDefinitionStatisticsErrors[keyof GetProcessDefinitionStatisticsErrors];

export type GetProcessDefinitionStatisticsResponses = {
    /**
     * The process definition statistics result.
     */
    200: ProcessDefinitionElementStatisticsQueryResult;
};

export type GetProcessDefinitionStatisticsResponse = GetProcessDefinitionStatisticsResponses[keyof GetProcessDefinitionStatisticsResponses];

export type GetProcessDefinitionXmlData = {
    body?: never;
    path: {
        /**
         * The assigned key of the process definition, which acts as a unique identifier for this process definition.
         *
         */
        processDefinitionKey: ProcessDefinitionKey;
    };
    query?: never;
    url: '/process-definitions/{processDefinitionKey}/xml';
};

export type GetProcessDefinitionXmlErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The process definition with the given key was not found.
     * More details are provided in the response body.
     *
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type GetProcessDefinitionXmlError = GetProcessDefinitionXmlErrors[keyof GetProcessDefinitionXmlErrors];

export type GetProcessDefinitionXmlResponses = {
    /**
     * The XML of the process definition is successfully returned.
     */
    200: string;
    /**
     * The process definition was found but does not have XML.
     */
    204: string;
};

export type GetProcessDefinitionXmlResponse = GetProcessDefinitionXmlResponses[keyof GetProcessDefinitionXmlResponses];

export type GetProcessDefinitionInstanceVersionStatisticsData = {
    body: ProcessDefinitionInstanceVersionStatisticsQuery;
    path?: never;
    query?: never;
    url: '/process-definitions/statistics/process-instances-by-version';
};

export type GetProcessDefinitionInstanceVersionStatisticsErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type GetProcessDefinitionInstanceVersionStatisticsError = GetProcessDefinitionInstanceVersionStatisticsErrors[keyof GetProcessDefinitionInstanceVersionStatisticsErrors];

export type GetProcessDefinitionInstanceVersionStatisticsResponses = {
    /**
     * The process definition instance version statistic result.
     */
    200: ProcessDefinitionInstanceVersionStatisticsQueryResult;
};

export type GetProcessDefinitionInstanceVersionStatisticsResponse = GetProcessDefinitionInstanceVersionStatisticsResponses[keyof GetProcessDefinitionInstanceVersionStatisticsResponses];

export type CreateProcessInstanceData = {
    body: ProcessInstanceCreationInstruction;
    path?: never;
    query?: never;
    url: '/process-instances';
};

export type CreateProcessInstanceErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
    /**
     * The process instance creation request timed out in the gateway.
     * This can happen if the `awaitCompletion` request parameter is set to `true`
     * and the created process instance did not complete within the defined request timeout.
     * This often happens when the created instance is not fully automated or contains wait states.
     *
     */
    504: ProblemDetail;
};

export type CreateProcessInstanceError = CreateProcessInstanceErrors[keyof CreateProcessInstanceErrors];

export type CreateProcessInstanceResponses = {
    /**
     * The process instance was created.
     */
    200: CreateProcessInstanceResult;
};

export type CreateProcessInstanceResponse = CreateProcessInstanceResponses[keyof CreateProcessInstanceResponses];

export type CancelProcessInstancesBatchOperationData = {
    body: ProcessInstanceCancellationBatchOperationRequest;
    path?: never;
    query?: never;
    url: '/process-instances/cancellation';
};

export type CancelProcessInstancesBatchOperationErrors = {
    /**
     * The process instance batch operation failed. More details are provided in the response body.
     *
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type CancelProcessInstancesBatchOperationError = CancelProcessInstancesBatchOperationErrors[keyof CancelProcessInstancesBatchOperationErrors];

export type CancelProcessInstancesBatchOperationResponses = {
    /**
     * The batch operation request was created.
     */
    200: BatchOperationCreatedResult;
};

export type CancelProcessInstancesBatchOperationResponse = CancelProcessInstancesBatchOperationResponses[keyof CancelProcessInstancesBatchOperationResponses];

export type DeleteProcessInstancesBatchOperationData = {
    body: ProcessInstanceDeletionBatchOperationRequest;
    path?: never;
    query?: never;
    url: '/process-instances/deletion';
};

export type DeleteProcessInstancesBatchOperationErrors = {
    /**
     * The process instance batch operation failed. More details are provided in the response body.
     *
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type DeleteProcessInstancesBatchOperationError = DeleteProcessInstancesBatchOperationErrors[keyof DeleteProcessInstancesBatchOperationErrors];

export type DeleteProcessInstancesBatchOperationResponses = {
    /**
     * The batch operation request was created.
     */
    200: BatchOperationCreatedResult;
};

export type DeleteProcessInstancesBatchOperationResponse = DeleteProcessInstancesBatchOperationResponses[keyof DeleteProcessInstancesBatchOperationResponses];

export type ResolveIncidentsBatchOperationData = {
    body?: ProcessInstanceIncidentResolutionBatchOperationRequest;
    path?: never;
    query?: never;
    url: '/process-instances/incident-resolution';
};

export type ResolveIncidentsBatchOperationErrors = {
    /**
     * The process instance batch operation failed. More details are provided in the response body.
     *
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type ResolveIncidentsBatchOperationError = ResolveIncidentsBatchOperationErrors[keyof ResolveIncidentsBatchOperationErrors];

export type ResolveIncidentsBatchOperationResponses = {
    /**
     * The batch operation request was created.
     */
    200: BatchOperationCreatedResult;
};

export type ResolveIncidentsBatchOperationResponse = ResolveIncidentsBatchOperationResponses[keyof ResolveIncidentsBatchOperationResponses];

export type MigrateProcessInstancesBatchOperationData = {
    body: ProcessInstanceMigrationBatchOperationRequest;
    path?: never;
    query?: never;
    url: '/process-instances/migration';
};

export type MigrateProcessInstancesBatchOperationErrors = {
    /**
     * The process instance batch operation failed. More details are provided in the response body.
     *
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type MigrateProcessInstancesBatchOperationError = MigrateProcessInstancesBatchOperationErrors[keyof MigrateProcessInstancesBatchOperationErrors];

export type MigrateProcessInstancesBatchOperationResponses = {
    /**
     * The batch operation request was created.
     */
    200: BatchOperationCreatedResult;
};

export type MigrateProcessInstancesBatchOperationResponse = MigrateProcessInstancesBatchOperationResponses[keyof MigrateProcessInstancesBatchOperationResponses];

export type ModifyProcessInstancesBatchOperationData = {
    body: ProcessInstanceModificationBatchOperationRequest;
    path?: never;
    query?: never;
    url: '/process-instances/modification';
};

export type ModifyProcessInstancesBatchOperationErrors = {
    /**
     * The process instance batch operation failed. More details are provided in the response body.
     *
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type ModifyProcessInstancesBatchOperationError = ModifyProcessInstancesBatchOperationErrors[keyof ModifyProcessInstancesBatchOperationErrors];

export type ModifyProcessInstancesBatchOperationResponses = {
    /**
     * The batch operation request was created.
     */
    200: BatchOperationCreatedResult;
};

export type ModifyProcessInstancesBatchOperationResponse = ModifyProcessInstancesBatchOperationResponses[keyof ModifyProcessInstancesBatchOperationResponses];

export type SearchProcessInstancesData = {
    body?: ProcessInstanceSearchQuery;
    path?: never;
    query?: never;
    url: '/process-instances/search';
};

export type SearchProcessInstancesErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type SearchProcessInstancesError = SearchProcessInstancesErrors[keyof SearchProcessInstancesErrors];

export type SearchProcessInstancesResponses = {
    /**
     * The process instance search result.
     */
    200: ProcessInstanceSearchQueryResult;
};

export type SearchProcessInstancesResponse = SearchProcessInstancesResponses[keyof SearchProcessInstancesResponses];

export type GetProcessInstanceData = {
    body?: never;
    path: {
        /**
         * The process instance key.
         */
        processInstanceKey: ProcessInstanceKey;
    };
    query?: never;
    url: '/process-instances/{processInstanceKey}';
};

export type GetProcessInstanceErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The process instance with the given key was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type GetProcessInstanceError = GetProcessInstanceErrors[keyof GetProcessInstanceErrors];

export type GetProcessInstanceResponses = {
    /**
     * The process instance is successfully returned.
     */
    200: ProcessInstanceResult;
};

export type GetProcessInstanceResponse = GetProcessInstanceResponses[keyof GetProcessInstanceResponses];

export type GetProcessInstanceCallHierarchyData = {
    body?: never;
    path: {
        /**
         * The key of the process instance to fetch the hierarchy for.
         */
        processInstanceKey: ProcessInstanceKey;
    };
    query?: never;
    url: '/process-instances/{processInstanceKey}/call-hierarchy';
};

export type GetProcessInstanceCallHierarchyErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The process instance is not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type GetProcessInstanceCallHierarchyError = GetProcessInstanceCallHierarchyErrors[keyof GetProcessInstanceCallHierarchyErrors];

export type GetProcessInstanceCallHierarchyResponses = {
    /**
     * The call hierarchy is successfully returned.
     */
    200: Array<ProcessInstanceCallHierarchyEntry>;
};

export type GetProcessInstanceCallHierarchyResponse = GetProcessInstanceCallHierarchyResponses[keyof GetProcessInstanceCallHierarchyResponses];

export type CancelProcessInstanceData = {
    body?: {
        operationReference?: OperationReference;
    } | null;
    path: {
        /**
         * The key of the process instance to cancel.
         */
        processInstanceKey: ProcessInstanceKey;
    };
    query?: never;
    url: '/process-instances/{processInstanceKey}/cancellation';
};

export type CancelProcessInstanceErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The process instance is not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type CancelProcessInstanceError = CancelProcessInstanceErrors[keyof CancelProcessInstanceErrors];

export type CancelProcessInstanceResponses = {
    /**
     * The process instance is canceled.
     */
    204: void;
};

export type CancelProcessInstanceResponse = CancelProcessInstanceResponses[keyof CancelProcessInstanceResponses];

export type DeleteProcessInstanceData = {
    body?: {
        operationReference?: OperationReference;
    } | null;
    path: {
        /**
         * The key of the process instance to delete.
         */
        processInstanceKey: ProcessInstanceKey;
    };
    query?: never;
    url: '/process-instances/{processInstanceKey}/deletion';
};

export type DeleteProcessInstanceErrors = {
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The process instance is not found.
     */
    404: ProblemDetail;
    /**
     * The process instance is not in a completed or terminated state and cannot be deleted.
     */
    409: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type DeleteProcessInstanceError = DeleteProcessInstanceErrors[keyof DeleteProcessInstanceErrors];

export type DeleteProcessInstanceResponses = {
    /**
     * The process instance is marked for deletion.
     */
    204: void;
};

export type DeleteProcessInstanceResponse = DeleteProcessInstanceResponses[keyof DeleteProcessInstanceResponses];

export type ResolveProcessInstanceIncidentsData = {
    body?: never;
    path: {
        /**
         * The key of the process instance to resolve incidents for.
         */
        processInstanceKey: ProcessInstanceKey;
    };
    query?: never;
    url: '/process-instances/{processInstanceKey}/incident-resolution';
};

export type ResolveProcessInstanceIncidentsErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * The process instance is not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type ResolveProcessInstanceIncidentsError = ResolveProcessInstanceIncidentsErrors[keyof ResolveProcessInstanceIncidentsErrors];

export type ResolveProcessInstanceIncidentsResponses = {
    /**
     * The batch operation request for incident resolution was created.
     */
    200: BatchOperationCreatedResult;
};

export type ResolveProcessInstanceIncidentsResponse = ResolveProcessInstanceIncidentsResponses[keyof ResolveProcessInstanceIncidentsResponses];

export type SearchProcessInstanceIncidentsData = {
    body?: IncidentSearchQuery;
    path: {
        /**
         * The assigned key of the process instance, which acts as a unique identifier for this process instance.
         */
        processInstanceKey: ProcessInstanceKey;
    };
    query?: never;
    url: '/process-instances/{processInstanceKey}/incidents/search';
};

export type SearchProcessInstanceIncidentsErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The process instance with the given key was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type SearchProcessInstanceIncidentsError = SearchProcessInstanceIncidentsErrors[keyof SearchProcessInstanceIncidentsErrors];

export type SearchProcessInstanceIncidentsResponses = {
    /**
     * The process instance search result.
     */
    200: IncidentSearchQueryResult;
};

export type SearchProcessInstanceIncidentsResponse = SearchProcessInstanceIncidentsResponses[keyof SearchProcessInstanceIncidentsResponses];

export type MigrateProcessInstanceData = {
    body: ProcessInstanceMigrationInstruction;
    path: {
        /**
         * The key of the process instance that should be migrated.
         */
        processInstanceKey: ProcessInstanceKey;
    };
    query?: never;
    url: '/process-instances/{processInstanceKey}/migration';
};

export type MigrateProcessInstanceErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The process instance is not found.
     */
    404: ProblemDetail;
    /**
     * The process instance migration failed. More details are provided in the response body.
     *
     */
    409: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type MigrateProcessInstanceError = MigrateProcessInstanceErrors[keyof MigrateProcessInstanceErrors];

export type MigrateProcessInstanceResponses = {
    /**
     * The process instance is migrated.
     */
    204: void;
};

export type MigrateProcessInstanceResponse = MigrateProcessInstanceResponses[keyof MigrateProcessInstanceResponses];

export type ModifyProcessInstanceData = {
    body: ProcessInstanceModificationInstruction;
    path: {
        /**
         * The key of the process instance that should be modified.
         */
        processInstanceKey: ProcessInstanceKey;
    };
    query?: never;
    url: '/process-instances/{processInstanceKey}/modification';
};

export type ModifyProcessInstanceErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The process instance is not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type ModifyProcessInstanceError = ModifyProcessInstanceErrors[keyof ModifyProcessInstanceErrors];

export type ModifyProcessInstanceResponses = {
    /**
     * The process instance is modified.
     */
    204: void;
};

export type ModifyProcessInstanceResponse = ModifyProcessInstanceResponses[keyof ModifyProcessInstanceResponses];

export type GetProcessInstanceSequenceFlowsData = {
    body?: never;
    path: {
        /**
         * The assigned key of the process instance, which acts as a unique identifier for this process instance.
         */
        processInstanceKey: ProcessInstanceKey;
    };
    query?: never;
    url: '/process-instances/{processInstanceKey}/sequence-flows';
};

export type GetProcessInstanceSequenceFlowsErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type GetProcessInstanceSequenceFlowsError = GetProcessInstanceSequenceFlowsErrors[keyof GetProcessInstanceSequenceFlowsErrors];

export type GetProcessInstanceSequenceFlowsResponses = {
    /**
     * The process instance sequence flows result.
     */
    200: ProcessInstanceSequenceFlowsQueryResult;
};

export type GetProcessInstanceSequenceFlowsResponse = GetProcessInstanceSequenceFlowsResponses[keyof GetProcessInstanceSequenceFlowsResponses];

export type GetProcessInstanceStatisticsData = {
    body?: never;
    path: {
        /**
         * The assigned key of the process instance, which acts as a unique identifier for this process instance.
         */
        processInstanceKey: ProcessInstanceKey;
    };
    query?: never;
    url: '/process-instances/{processInstanceKey}/statistics/element-instances';
};

export type GetProcessInstanceStatisticsErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type GetProcessInstanceStatisticsError = GetProcessInstanceStatisticsErrors[keyof GetProcessInstanceStatisticsErrors];

export type GetProcessInstanceStatisticsResponses = {
    /**
     * The process instance statistics result.
     */
    200: ProcessInstanceElementStatisticsQueryResult;
};

export type GetProcessInstanceStatisticsResponse = GetProcessInstanceStatisticsResponses[keyof GetProcessInstanceStatisticsResponses];

export type GetResourceData = {
    body?: never;
    path: {
        /**
         * The unique key identifying the resource.
         */
        resourceKey: ResourceKey;
    };
    query?: never;
    url: '/resources/{resourceKey}';
};

export type GetResourceErrors = {
    /**
     * A resource with the given key was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type GetResourceError = GetResourceErrors[keyof GetResourceErrors];

export type GetResourceResponses = {
    /**
     * The resource is successfully returned.
     */
    200: ResourceResult;
};

export type GetResourceResponse = GetResourceResponses[keyof GetResourceResponses];

export type GetResourceContentData = {
    body?: never;
    path: {
        /**
         * The unique key identifying the resource.
         */
        resourceKey: ResourceKey;
    };
    query?: never;
    url: '/resources/{resourceKey}/content';
};

export type GetResourceContentErrors = {
    /**
     * A resource with the given key was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type GetResourceContentError = GetResourceContentErrors[keyof GetResourceContentErrors];

export type GetResourceContentResponses = {
    /**
     * The resource content is successfully returned.
     */
    200: Blob | File;
};

export type GetResourceContentResponse = GetResourceContentResponses[keyof GetResourceContentResponses];

export type DeleteResourceData = {
    body?: DeleteResourceRequest;
    path: {
        /**
         * The key of the resource to delete.
         * This can be the key of a process definition, the key of a decision requirements
         * definition or the key of a form definition
         *
         */
        resourceKey: ResourceKey;
    };
    query?: never;
    url: '/resources/{resourceKey}/deletion';
};

export type DeleteResourceErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The resource is not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type DeleteResourceError = DeleteResourceErrors[keyof DeleteResourceErrors];

export type DeleteResourceResponses = {
    /**
     * The resource is deleted.
     */
    200: DeleteResourceResponse;
};

export type DeleteResourceResponse2 = DeleteResourceResponses[keyof DeleteResourceResponses];

export type CreateRoleData = {
    body?: RoleCreateRequest;
    path?: never;
    query?: never;
    url: '/roles';
};

export type CreateRoleErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type CreateRoleError = CreateRoleErrors[keyof CreateRoleErrors];

export type CreateRoleResponses = {
    /**
     * The role was created successfully.
     */
    201: RoleCreateResult;
};

export type CreateRoleResponse = CreateRoleResponses[keyof CreateRoleResponses];

export type SearchRolesData = {
    body?: RoleSearchQueryRequest;
    path?: never;
    query?: never;
    url: '/roles/search';
};

export type SearchRolesErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type SearchRolesError = SearchRolesErrors[keyof SearchRolesErrors];

export type SearchRolesResponses = {
    /**
     * The roles search result.
     */
    200: RoleSearchQueryResult;
};

export type SearchRolesResponse = SearchRolesResponses[keyof SearchRolesResponses];

export type DeleteRoleData = {
    body?: never;
    path: {
        /**
         * The role ID.
         */
        roleId: string;
    };
    query?: never;
    url: '/roles/{roleId}';
};

export type DeleteRoleErrors = {
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * The role with the ID was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type DeleteRoleError = DeleteRoleErrors[keyof DeleteRoleErrors];

export type DeleteRoleResponses = {
    /**
     * The role was deleted successfully.
     */
    204: void;
};

export type DeleteRoleResponse = DeleteRoleResponses[keyof DeleteRoleResponses];

export type GetRoleData = {
    body?: never;
    path: {
        /**
         * The role ID.
         */
        roleId: string;
    };
    query?: never;
    url: '/roles/{roleId}';
};

export type GetRoleErrors = {
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The role with the given ID was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type GetRoleError = GetRoleErrors[keyof GetRoleErrors];

export type GetRoleResponses = {
    /**
     * The role is successfully returned.
     */
    200: RoleResult;
};

export type GetRoleResponse = GetRoleResponses[keyof GetRoleResponses];

export type UpdateRoleData = {
    body: RoleUpdateRequest;
    path: {
        /**
         * The role ID.
         */
        roleId: string;
    };
    query?: never;
    url: '/roles/{roleId}';
};

export type UpdateRoleErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * The role with the ID is not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type UpdateRoleError = UpdateRoleErrors[keyof UpdateRoleErrors];

export type UpdateRoleResponses = {
    /**
     * The role was updated successfully.
     */
    200: RoleUpdateResult;
};

export type UpdateRoleResponse = UpdateRoleResponses[keyof UpdateRoleResponses];

export type SearchClientsForRoleData = {
    body?: SearchQueryRequest & {
        /**
         * Sort field criteria.
         */
        sort?: Array<{
            /**
             * The field to sort by.
             */
            field: 'clientId';
            order?: SortOrderEnum;
        }>;
    };
    path: {
        /**
         * The role ID.
         */
        roleId: string;
    };
    query?: never;
    url: '/roles/{roleId}/clients/search';
};

export type SearchClientsForRoleErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The role with the given ID was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type SearchClientsForRoleError = SearchClientsForRoleErrors[keyof SearchClientsForRoleErrors];

export type SearchClientsForRoleResponses = {
    /**
     * The clients with the assigned role.
     */
    200: SearchQueryResponse & {
        /**
         * The matching clients.
         */
        items?: Array<{
            /**
             * The ID of the client.
             */
            clientId?: string;
        }>;
    };
};

export type SearchClientsForRoleResponse = SearchClientsForRoleResponses[keyof SearchClientsForRoleResponses];

export type UnassignRoleFromClientData = {
    body?: never;
    path: {
        /**
         * The role ID.
         */
        roleId: string;
        /**
         * The client ID.
         */
        clientId: string;
    };
    query?: never;
    url: '/roles/{roleId}/clients/{clientId}';
};

export type UnassignRoleFromClientErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The role or client with the given ID or username was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type UnassignRoleFromClientError = UnassignRoleFromClientErrors[keyof UnassignRoleFromClientErrors];

export type UnassignRoleFromClientResponses = {
    /**
     * The role was unassigned successfully from the client.
     */
    204: void;
};

export type UnassignRoleFromClientResponse = UnassignRoleFromClientResponses[keyof UnassignRoleFromClientResponses];

export type AssignRoleToClientData = {
    body?: never;
    path: {
        /**
         * The role ID.
         */
        roleId: string;
        /**
         * The client ID.
         */
        clientId: string;
    };
    query?: never;
    url: '/roles/{roleId}/clients/{clientId}';
};

export type AssignRoleToClientErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The role with the given ID was not found.
     */
    404: ProblemDetail;
    /**
     * The role was already assigned to the client with the given ID.
     */
    409: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type AssignRoleToClientError = AssignRoleToClientErrors[keyof AssignRoleToClientErrors];

export type AssignRoleToClientResponses = {
    /**
     * The role was assigned successfully to the client.
     */
    204: void;
};

export type AssignRoleToClientResponse = AssignRoleToClientResponses[keyof AssignRoleToClientResponses];

export type SearchGroupsForRoleData = {
    body?: RoleGroupSearchQueryRequest;
    path: {
        /**
         * The role ID.
         */
        roleId: string;
    };
    query?: never;
    url: '/roles/{roleId}/groups/search';
};

export type SearchGroupsForRoleErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The role with the given ID was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type SearchGroupsForRoleError = SearchGroupsForRoleErrors[keyof SearchGroupsForRoleErrors];

export type SearchGroupsForRoleResponses = {
    /**
     * The groups with assigned role.
     */
    200: RoleGroupSearchResult;
};

export type SearchGroupsForRoleResponse = SearchGroupsForRoleResponses[keyof SearchGroupsForRoleResponses];

export type UnassignRoleFromGroupData = {
    body?: never;
    path: {
        /**
         * The role ID.
         */
        roleId: string;
        /**
         * The group ID.
         */
        groupId: string;
    };
    query?: never;
    url: '/roles/{roleId}/groups/{groupId}';
};

export type UnassignRoleFromGroupErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The role or group with the given ID was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type UnassignRoleFromGroupError = UnassignRoleFromGroupErrors[keyof UnassignRoleFromGroupErrors];

export type UnassignRoleFromGroupResponses = {
    /**
     * The role was unassigned successfully from the group.
     */
    204: void;
};

export type UnassignRoleFromGroupResponse = UnassignRoleFromGroupResponses[keyof UnassignRoleFromGroupResponses];

export type AssignRoleToGroupData = {
    body?: never;
    path: {
        /**
         * The role ID.
         */
        roleId: string;
        /**
         * The group ID.
         */
        groupId: string;
    };
    query?: never;
    url: '/roles/{roleId}/groups/{groupId}';
};

export type AssignRoleToGroupErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The role or group with the given ID was not found.
     */
    404: ProblemDetail;
    /**
     * The role is already assigned to the group with the given ID.
     */
    409: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type AssignRoleToGroupError = AssignRoleToGroupErrors[keyof AssignRoleToGroupErrors];

export type AssignRoleToGroupResponses = {
    /**
     * The role was assigned successfully to the group.
     */
    204: void;
};

export type AssignRoleToGroupResponse = AssignRoleToGroupResponses[keyof AssignRoleToGroupResponses];

export type SearchMappingRulesForRoleData = {
    body?: MappingRuleSearchQueryRequest;
    path: {
        /**
         * The role ID.
         */
        roleId: string;
    };
    query?: never;
    url: '/roles/{roleId}/mapping-rules/search';
};

export type SearchMappingRulesForRoleErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The role with the given ID was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type SearchMappingRulesForRoleError = SearchMappingRulesForRoleErrors[keyof SearchMappingRulesForRoleErrors];

export type SearchMappingRulesForRoleResponses = {
    /**
     * The mapping rules with assigned role.
     */
    200: SearchQueryResponse;
};

export type SearchMappingRulesForRoleResponse = SearchMappingRulesForRoleResponses[keyof SearchMappingRulesForRoleResponses];

export type UnassignRoleFromMappingRuleData = {
    body?: never;
    path: {
        /**
         * The role ID.
         */
        roleId: string;
        /**
         * The mapping rule ID.
         */
        mappingRuleId: string;
    };
    query?: never;
    url: '/roles/{roleId}/mapping-rules/{mappingRuleId}';
};

export type UnassignRoleFromMappingRuleErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The role or mapping rule with the given ID was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type UnassignRoleFromMappingRuleError = UnassignRoleFromMappingRuleErrors[keyof UnassignRoleFromMappingRuleErrors];

export type UnassignRoleFromMappingRuleResponses = {
    /**
     * The role was unassigned successfully from the mapping rule.
     */
    204: void;
};

export type UnassignRoleFromMappingRuleResponse = UnassignRoleFromMappingRuleResponses[keyof UnassignRoleFromMappingRuleResponses];

export type AssignRoleToMappingRuleData = {
    body?: never;
    path: {
        /**
         * The role ID.
         */
        roleId: string;
        /**
         * The mapping rule ID.
         */
        mappingRuleId: string;
    };
    query?: never;
    url: '/roles/{roleId}/mapping-rules/{mappingRuleId}';
};

export type AssignRoleToMappingRuleErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The role or mapping rule with the given ID was not found.
     */
    404: ProblemDetail;
    /**
     * The role is already assigned to the mapping rule with the given ID.
     */
    409: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type AssignRoleToMappingRuleError = AssignRoleToMappingRuleErrors[keyof AssignRoleToMappingRuleErrors];

export type AssignRoleToMappingRuleResponses = {
    /**
     * The role was assigned successfully to the mapping rule.
     */
    204: void;
};

export type AssignRoleToMappingRuleResponse = AssignRoleToMappingRuleResponses[keyof AssignRoleToMappingRuleResponses];

export type SearchUsersForRoleData = {
    body?: SearchQueryRequest & {
        /**
         * Sort field criteria.
         */
        sort?: Array<{
            /**
             * The field to sort by.
             */
            field: 'username';
            order?: SortOrderEnum;
        }>;
    };
    path: {
        /**
         * The role ID.
         */
        roleId: string;
    };
    query?: never;
    url: '/roles/{roleId}/users/search';
};

export type SearchUsersForRoleErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The role with the given ID was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type SearchUsersForRoleError = SearchUsersForRoleErrors[keyof SearchUsersForRoleErrors];

export type SearchUsersForRoleResponses = {
    /**
     * The users with the assigned role.
     */
    200: SearchQueryResponse & {
        /**
         * The matching users.
         */
        items?: Array<{
            username?: Username;
        }>;
    };
};

export type SearchUsersForRoleResponse = SearchUsersForRoleResponses[keyof SearchUsersForRoleResponses];

export type UnassignRoleFromUserData = {
    body?: never;
    path: {
        /**
         * The role ID.
         */
        roleId: string;
        /**
         * The user username.
         */
        username: Username;
    };
    query?: never;
    url: '/roles/{roleId}/users/{username}';
};

export type UnassignRoleFromUserErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The role or user with the given ID or username was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type UnassignRoleFromUserError = UnassignRoleFromUserErrors[keyof UnassignRoleFromUserErrors];

export type UnassignRoleFromUserResponses = {
    /**
     * The role was unassigned successfully from the user.
     */
    204: void;
};

export type UnassignRoleFromUserResponse = UnassignRoleFromUserResponses[keyof UnassignRoleFromUserResponses];

export type AssignRoleToUserData = {
    body?: never;
    path: {
        /**
         * The role ID.
         */
        roleId: string;
        /**
         * The user username.
         */
        username: Username;
    };
    query?: never;
    url: '/roles/{roleId}/users/{username}';
};

export type AssignRoleToUserErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The role or user with the given ID or username was not found.
     */
    404: ProblemDetail;
    /**
     * The role is already assigned to the user with the given ID.
     */
    409: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type AssignRoleToUserError = AssignRoleToUserErrors[keyof AssignRoleToUserErrors];

export type AssignRoleToUserResponses = {
    /**
     * The role was assigned successfully to the user.
     */
    204: void;
};

export type AssignRoleToUserResponse = AssignRoleToUserResponses[keyof AssignRoleToUserResponses];

export type CreateAdminUserData = {
    body: UserRequest;
    path?: never;
    query?: never;
    url: '/setup/user';
};

export type CreateAdminUserErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type CreateAdminUserError = CreateAdminUserErrors[keyof CreateAdminUserErrors];

export type CreateAdminUserResponses = {
    /**
     * The admin user was created successfully.
     */
    201: UserCreateResult;
};

export type CreateAdminUserResponse = CreateAdminUserResponses[keyof CreateAdminUserResponses];

export type BroadcastSignalData = {
    body: SignalBroadcastRequest;
    path?: never;
    query?: never;
    url: '/signals/broadcast';
};

export type BroadcastSignalErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The signal is not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type BroadcastSignalError = BroadcastSignalErrors[keyof BroadcastSignalErrors];

export type BroadcastSignalResponses = {
    /**
     * The signal was broadcast.
     */
    200: SignalBroadcastResult;
};

export type BroadcastSignalResponse = BroadcastSignalResponses[keyof BroadcastSignalResponses];

export type GetStatusData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/status';
};

export type GetStatusErrors = {
    /**
     * The cluster is DOWN and does not have any partition with a healthy leader.
     */
    503: unknown;
};

export type GetStatusResponses = {
    /**
     * The cluster is UP and has at least one partition with a healthy leader.
     */
    204: void;
};

export type GetStatusResponse = GetStatusResponses[keyof GetStatusResponses];

export type GetUsageMetricsData = {
    body?: never;
    path?: never;
    query: {
        /**
         * The start date for usage metrics, including this date. Value in ISO 8601 format.
         */
        startTime: string;
        /**
         * The end date for usage metrics, including this date. Value in ISO 8601 format.
         */
        endTime: string;
        /**
         * Restrict results to a specific tenant ID. If not provided, results for all tenants are returned.
         */
        tenantId?: TenantId;
        /**
         * Whether to return tenant metrics in addition to the total metrics or not. Default false.
         */
        withTenants?: boolean;
    };
    url: '/system/usage-metrics';
};

export type GetUsageMetricsErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type GetUsageMetricsError = GetUsageMetricsErrors[keyof GetUsageMetricsErrors];

export type GetUsageMetricsResponses = {
    /**
     * The usage metrics search result.
     */
    200: UsageMetricsResponse;
};

export type GetUsageMetricsResponse = GetUsageMetricsResponses[keyof GetUsageMetricsResponses];

export type CreateTenantData = {
    body: TenantCreateRequest;
    path?: never;
    query?: never;
    url: '/tenants';
};

export type CreateTenantErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * Not found. The resource was not found.
     */
    404: ProblemDetail;
    /**
     * Tenant with this id already exists.
     */
    409: unknown;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type CreateTenantError = CreateTenantErrors[keyof CreateTenantErrors];

export type CreateTenantResponses = {
    /**
     * The tenant was created successfully.
     */
    201: TenantCreateResult;
};

export type CreateTenantResponse = CreateTenantResponses[keyof CreateTenantResponses];

export type SearchTenantsData = {
    body?: TenantSearchQueryRequest;
    path?: never;
    query?: never;
    url: '/tenants/search';
};

export type SearchTenantsErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * Not found
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type SearchTenantsError = SearchTenantsErrors[keyof SearchTenantsErrors];

export type SearchTenantsResponses = {
    /**
     * The tenants search result
     */
    200: TenantSearchQueryResult;
};

export type SearchTenantsResponse = SearchTenantsResponses[keyof SearchTenantsResponses];

export type DeleteTenantData = {
    body?: never;
    path: {
        /**
         * The unique identifier of the tenant.
         */
        tenantId: TenantId;
    };
    query?: never;
    url: '/tenants/{tenantId}';
};

export type DeleteTenantErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * Not found. The tenant was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type DeleteTenantError = DeleteTenantErrors[keyof DeleteTenantErrors];

export type DeleteTenantResponses = {
    /**
     * The tenant was deleted successfully.
     */
    204: void;
};

export type DeleteTenantResponse = DeleteTenantResponses[keyof DeleteTenantResponses];

export type GetTenantData = {
    body?: never;
    path: {
        /**
         * The unique identifier of the tenant.
         */
        tenantId: TenantId;
    };
    query?: never;
    url: '/tenants/{tenantId}';
};

export type GetTenantErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * Tenant not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type GetTenantError = GetTenantErrors[keyof GetTenantErrors];

export type GetTenantResponses = {
    /**
     * The tenant was retrieved successfully.
     */
    200: TenantResult;
};

export type GetTenantResponse = GetTenantResponses[keyof GetTenantResponses];

export type UpdateTenantData = {
    body: TenantUpdateRequest;
    path: {
        /**
         * The unique identifier of the tenant.
         */
        tenantId: TenantId;
    };
    query?: never;
    url: '/tenants/{tenantId}';
};

export type UpdateTenantErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * Not found. The tenant was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type UpdateTenantError = UpdateTenantErrors[keyof UpdateTenantErrors];

export type UpdateTenantResponses = {
    /**
     * The tenant was updated successfully.
     */
    200: TenantUpdateResult;
};

export type UpdateTenantResponse = UpdateTenantResponses[keyof UpdateTenantResponses];

export type SearchClientsForTenantData = {
    body?: SearchQueryRequest & {
        /**
         * Sort field criteria.
         */
        sort?: Array<{
            /**
             * The field to sort by.
             */
            field: 'clientId';
            order?: SortOrderEnum;
        }>;
    };
    path: {
        /**
         * The unique identifier of the tenant.
         */
        tenantId: TenantId;
    };
    query?: never;
    url: '/tenants/{tenantId}/clients/search';
};

export type SearchClientsForTenantResponses = {
    /**
     * The search result of users for the tenant.
     */
    200: SearchQueryResponse & {
        /**
         * The matching clients.
         */
        items?: Array<{
            /**
             * The ID of the client.
             */
            clientId?: string;
        }>;
    };
};

export type SearchClientsForTenantResponse = SearchClientsForTenantResponses[keyof SearchClientsForTenantResponses];

export type UnassignClientFromTenantData = {
    body?: never;
    path: {
        /**
         * The unique identifier of the tenant.
         */
        tenantId: TenantId;
        /**
         * The unique identifier of the application.
         */
        clientId: string;
    };
    query?: never;
    url: '/tenants/{tenantId}/clients/{clientId}';
};

export type UnassignClientFromTenantErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The tenant does not exist or the client was not assigned to it.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type UnassignClientFromTenantError = UnassignClientFromTenantErrors[keyof UnassignClientFromTenantErrors];

export type UnassignClientFromTenantResponses = {
    /**
     * The client was successfully unassigned from the tenant.
     */
    204: void;
};

export type UnassignClientFromTenantResponse = UnassignClientFromTenantResponses[keyof UnassignClientFromTenantResponses];

export type AssignClientToTenantData = {
    body?: never;
    path: {
        /**
         * The unique identifier of the tenant.
         */
        tenantId: TenantId;
        /**
         * The unique identifier of the application.
         */
        clientId: string;
    };
    query?: never;
    url: '/tenants/{tenantId}/clients/{clientId}';
};

export type AssignClientToTenantErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The tenant was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type AssignClientToTenantError = AssignClientToTenantErrors[keyof AssignClientToTenantErrors];

export type AssignClientToTenantResponses = {
    /**
     * The client was successfully assigned to the tenant.
     */
    204: void;
};

export type AssignClientToTenantResponse = AssignClientToTenantResponses[keyof AssignClientToTenantResponses];

export type SearchGroupIdsForTenantData = {
    body?: TenantGroupSearchQueryRequest;
    path: {
        /**
         * The unique identifier of the tenant.
         */
        tenantId: TenantId;
    };
    query?: never;
    url: '/tenants/{tenantId}/groups/search';
};

export type SearchGroupIdsForTenantResponses = {
    /**
     * The search result of groups for the tenant.
     */
    200: TenantGroupSearchResult;
};

export type SearchGroupIdsForTenantResponse = SearchGroupIdsForTenantResponses[keyof SearchGroupIdsForTenantResponses];

export type UnassignGroupFromTenantData = {
    body?: never;
    path: {
        /**
         * The unique identifier of the tenant.
         */
        tenantId: TenantId;
        /**
         * The unique identifier of the group.
         */
        groupId: string;
    };
    query?: never;
    url: '/tenants/{tenantId}/groups/{groupId}';
};

export type UnassignGroupFromTenantErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * Not found. The tenant or group was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type UnassignGroupFromTenantError = UnassignGroupFromTenantErrors[keyof UnassignGroupFromTenantErrors];

export type UnassignGroupFromTenantResponses = {
    /**
     * The group was successfully unassigned from the tenant.
     */
    204: void;
};

export type UnassignGroupFromTenantResponse = UnassignGroupFromTenantResponses[keyof UnassignGroupFromTenantResponses];

export type AssignGroupToTenantData = {
    body?: never;
    path: {
        /**
         * The unique identifier of the tenant.
         */
        tenantId: TenantId;
        /**
         * The unique identifier of the group.
         */
        groupId: string;
    };
    query?: never;
    url: '/tenants/{tenantId}/groups/{groupId}';
};

export type AssignGroupToTenantErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * Not found. The tenant or group was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type AssignGroupToTenantError = AssignGroupToTenantErrors[keyof AssignGroupToTenantErrors];

export type AssignGroupToTenantResponses = {
    /**
     * The group was successfully assigned to the tenant.
     */
    204: void;
};

export type AssignGroupToTenantResponse = AssignGroupToTenantResponses[keyof AssignGroupToTenantResponses];

export type SearchMappingRulesForTenantData = {
    body?: MappingRuleSearchQueryRequest;
    path: {
        /**
         * The unique identifier of the tenant.
         */
        tenantId: TenantId;
    };
    query?: never;
    url: '/tenants/{tenantId}/mapping-rules/search';
};

export type SearchMappingRulesForTenantResponses = {
    /**
     * The search result of MappingRules for the tenant.
     */
    200: SearchQueryResponse;
};

export type SearchMappingRulesForTenantResponse = SearchMappingRulesForTenantResponses[keyof SearchMappingRulesForTenantResponses];

export type UnassignMappingRuleFromTenantData = {
    body?: never;
    path: {
        /**
         * The unique identifier of the tenant.
         */
        tenantId: TenantId;
        /**
         * The unique identifier of the mapping rule.
         */
        mappingRuleId: string;
    };
    query?: never;
    url: '/tenants/{tenantId}/mapping-rules/{mappingRuleId}';
};

export type UnassignMappingRuleFromTenantErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * Not found. The tenant or mapping rule was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type UnassignMappingRuleFromTenantError = UnassignMappingRuleFromTenantErrors[keyof UnassignMappingRuleFromTenantErrors];

export type UnassignMappingRuleFromTenantResponses = {
    /**
     * The mapping rule was successfully unassigned from the tenant.
     */
    204: void;
};

export type UnassignMappingRuleFromTenantResponse = UnassignMappingRuleFromTenantResponses[keyof UnassignMappingRuleFromTenantResponses];

export type AssignMappingRuleToTenantData = {
    body?: never;
    path: {
        /**
         * The unique identifier of the tenant.
         */
        tenantId: TenantId;
        /**
         * The unique identifier of the mapping rule.
         */
        mappingRuleId: string;
    };
    query?: never;
    url: '/tenants/{tenantId}/mapping-rules/{mappingRuleId}';
};

export type AssignMappingRuleToTenantErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * Not found. The tenant or mapping rule was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type AssignMappingRuleToTenantError = AssignMappingRuleToTenantErrors[keyof AssignMappingRuleToTenantErrors];

export type AssignMappingRuleToTenantResponses = {
    /**
     * The mapping rule was successfully assigned to the tenant.
     */
    204: void;
};

export type AssignMappingRuleToTenantResponse = AssignMappingRuleToTenantResponses[keyof AssignMappingRuleToTenantResponses];

export type SearchRolesForTenantData = {
    body?: RoleSearchQueryRequest;
    path: {
        /**
         * The unique identifier of the tenant.
         */
        tenantId: TenantId;
    };
    query?: never;
    url: '/tenants/{tenantId}/roles/search';
};

export type SearchRolesForTenantResponses = {
    /**
     * The search result of roles for the tenant.
     */
    200: SearchQueryResponse;
};

export type SearchRolesForTenantResponse = SearchRolesForTenantResponses[keyof SearchRolesForTenantResponses];

export type UnassignRoleFromTenantData = {
    body?: never;
    path: {
        /**
         * The unique identifier of the tenant.
         */
        tenantId: TenantId;
        /**
         * The unique identifier of the role.
         */
        roleId: string;
    };
    query?: never;
    url: '/tenants/{tenantId}/roles/{roleId}';
};

export type UnassignRoleFromTenantErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * Not found. The tenant or role was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type UnassignRoleFromTenantError = UnassignRoleFromTenantErrors[keyof UnassignRoleFromTenantErrors];

export type UnassignRoleFromTenantResponses = {
    /**
     * The role was successfully unassigned from the tenant.
     */
    204: void;
};

export type UnassignRoleFromTenantResponse = UnassignRoleFromTenantResponses[keyof UnassignRoleFromTenantResponses];

export type AssignRoleToTenantData = {
    body?: never;
    path: {
        /**
         * The unique identifier of the tenant.
         */
        tenantId: TenantId;
        /**
         * The unique identifier of the role.
         */
        roleId: string;
    };
    query?: never;
    url: '/tenants/{tenantId}/roles/{roleId}';
};

export type AssignRoleToTenantErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * Not found. The tenant or role was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type AssignRoleToTenantError = AssignRoleToTenantErrors[keyof AssignRoleToTenantErrors];

export type AssignRoleToTenantResponses = {
    /**
     * The role was successfully assigned to the tenant.
     */
    204: void;
};

export type AssignRoleToTenantResponse = AssignRoleToTenantResponses[keyof AssignRoleToTenantResponses];

export type SearchUsersForTenantData = {
    body?: SearchQueryRequest & {
        /**
         * Sort field criteria.
         */
        sort?: Array<{
            /**
             * The field to sort by.
             */
            field: 'username';
            order?: SortOrderEnum;
        }>;
    };
    path: {
        /**
         * The unique identifier of the tenant.
         */
        tenantId: TenantId;
    };
    query?: never;
    url: '/tenants/{tenantId}/users/search';
};

export type SearchUsersForTenantResponses = {
    /**
     * The search result of users for the tenant.
     */
    200: SearchQueryResponse & {
        /**
         * The matching users.
         */
        items?: Array<{
            username?: Username;
        }>;
    };
};

export type SearchUsersForTenantResponse = SearchUsersForTenantResponses[keyof SearchUsersForTenantResponses];

export type UnassignUserFromTenantData = {
    body?: never;
    path: {
        /**
         * The unique identifier of the tenant.
         */
        tenantId: TenantId;
        /**
         * The unique identifier of the user.
         */
        username: Username;
    };
    query?: never;
    url: '/tenants/{tenantId}/users/{username}';
};

export type UnassignUserFromTenantErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * Not found. The tenant or user was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type UnassignUserFromTenantError = UnassignUserFromTenantErrors[keyof UnassignUserFromTenantErrors];

export type UnassignUserFromTenantResponses = {
    /**
     * The user was successfully unassigned from the tenant.
     */
    204: void;
};

export type UnassignUserFromTenantResponse = UnassignUserFromTenantResponses[keyof UnassignUserFromTenantResponses];

export type AssignUserToTenantData = {
    body?: never;
    path: {
        /**
         * The unique identifier of the tenant.
         */
        tenantId: TenantId;
        /**
         * The unique identifier of the user.
         */
        username: Username;
    };
    query?: never;
    url: '/tenants/{tenantId}/users/{username}';
};

export type AssignUserToTenantErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * Not found. The tenant or user was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type AssignUserToTenantError = AssignUserToTenantErrors[keyof AssignUserToTenantErrors];

export type AssignUserToTenantResponses = {
    /**
     * The user was successfully assigned to the tenant.
     */
    204: void;
};

export type AssignUserToTenantResponse = AssignUserToTenantResponses[keyof AssignUserToTenantResponses];

export type GetTopologyData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/topology';
};

export type GetTopologyErrors = {
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type GetTopologyError = GetTopologyErrors[keyof GetTopologyErrors];

export type GetTopologyResponses = {
    /**
     * Obtains the current topology of the cluster the gateway is part of.
     */
    200: TopologyResponse;
};

export type GetTopologyResponse = GetTopologyResponses[keyof GetTopologyResponses];

export type CreateUserData = {
    body: UserRequest;
    path?: never;
    query?: never;
    url: '/users';
};

export type CreateUserErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * A user with this username already exists.
     */
    409: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type CreateUserError = CreateUserErrors[keyof CreateUserErrors];

export type CreateUserResponses = {
    /**
     * The user was created successfully.
     */
    201: UserCreateResult;
};

export type CreateUserResponse = CreateUserResponses[keyof CreateUserResponses];

export type SearchUsersData = {
    body?: UserSearchQueryRequest;
    path?: never;
    query?: never;
    url: '/users/search';
};

export type SearchUsersErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type SearchUsersError = SearchUsersErrors[keyof SearchUsersErrors];

export type SearchUsersResponses = {
    /**
     * The user search result.
     */
    200: SearchQueryResponse & {
        /**
         * The matching users.
         */
        items: Array<{
            username?: Username;
            /**
             * The name of the user.
             */
            name?: string;
            /**
             * The email of the user.
             */
            email?: string;
        }>;
    };
};

export type SearchUsersResponse = SearchUsersResponses[keyof SearchUsersResponses];

export type DeleteUserData = {
    body?: never;
    path: {
        /**
         * The username of the user to delete.
         */
        username: Username;
    };
    query?: never;
    url: '/users/{username}';
};

export type DeleteUserErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The user is not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type DeleteUserError = DeleteUserErrors[keyof DeleteUserErrors];

export type DeleteUserResponses = {
    /**
     * The user was deleted successfully.
     */
    204: void;
};

export type DeleteUserResponse = DeleteUserResponses[keyof DeleteUserResponses];

export type GetUserData = {
    body?: never;
    path: {
        /**
         * The username of the user.
         */
        username: Username;
    };
    query?: never;
    url: '/users/{username}';
};

export type GetUserErrors = {
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The user with the given username was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type GetUserError = GetUserErrors[keyof GetUserErrors];

export type GetUserResponses = {
    /**
     * The user is successfully returned.
     */
    200: {
        username?: Username;
        /**
         * The name of the user.
         */
        name?: string;
        /**
         * The email of the user.
         */
        email?: string;
    };
};

export type GetUserResponse = GetUserResponses[keyof GetUserResponses];

export type UpdateUserData = {
    body: UserUpdateRequest;
    path: {
        /**
         * The username of the user to update.
         */
        username: Username;
    };
    query?: never;
    url: '/users/{username}';
};

export type UpdateUserErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The user was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type UpdateUserError = UpdateUserErrors[keyof UpdateUserErrors];

export type UpdateUserResponses = {
    /**
     * The user was updated successfully.
     */
    200: {
        username?: Username;
        /**
         * The name of the user.
         */
        name?: string;
        /**
         * The email of the user.
         */
        email?: string;
    };
};

export type UpdateUserResponse = UpdateUserResponses[keyof UpdateUserResponses];

export type SearchUserTasksData = {
    body?: UserTaskSearchQuery;
    path?: never;
    query?: never;
    url: '/user-tasks/search';
};

export type SearchUserTasksErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type SearchUserTasksError = SearchUserTasksErrors[keyof SearchUserTasksErrors];

export type SearchUserTasksResponses = {
    /**
     * The user task search result.
     */
    200: UserTaskSearchQueryResult;
};

export type SearchUserTasksResponse = SearchUserTasksResponses[keyof SearchUserTasksResponses];

export type GetUserTaskData = {
    body?: never;
    path: {
        /**
         * The user task key.
         */
        userTaskKey: UserTaskKey;
    };
    query?: never;
    url: '/user-tasks/{userTaskKey}';
};

export type GetUserTaskErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The user task with the given key was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type GetUserTaskError = GetUserTaskErrors[keyof GetUserTaskErrors];

export type GetUserTaskResponses = {
    /**
     * The user task is successfully returned.
     */
    200: UserTaskResult;
};

export type GetUserTaskResponse = GetUserTaskResponses[keyof GetUserTaskResponses];

export type UpdateUserTaskData = {
    body?: UserTaskUpdateRequest;
    path: {
        /**
         * The key of the user task to update.
         */
        userTaskKey: UserTaskKey;
    };
    query?: never;
    url: '/user-tasks/{userTaskKey}';
};

export type UpdateUserTaskErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The user task with the given key was not found.
     */
    404: ProblemDetail;
    /**
     * The user task with the given key is in the wrong state currently. More details are provided in the response body.
     *
     */
    409: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type UpdateUserTaskError = UpdateUserTaskErrors[keyof UpdateUserTaskErrors];

export type UpdateUserTaskResponses = {
    /**
     * The user task was updated successfully.
     */
    204: void;
};

export type UpdateUserTaskResponse = UpdateUserTaskResponses[keyof UpdateUserTaskResponses];

export type UnassignUserTaskData = {
    body?: never;
    path: {
        /**
         * The key of the user task.
         */
        userTaskKey: UserTaskKey;
    };
    query?: never;
    url: '/user-tasks/{userTaskKey}/assignee';
};

export type UnassignUserTaskErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The user task with the given key was not found.
     */
    404: ProblemDetail;
    /**
     * The user task with the given key is in the wrong state currently. More details are provided in the response body.
     *
     */
    409: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type UnassignUserTaskError = UnassignUserTaskErrors[keyof UnassignUserTaskErrors];

export type UnassignUserTaskResponses = {
    /**
     * The user task was unassigned successfully.
     */
    204: void;
};

export type UnassignUserTaskResponse = UnassignUserTaskResponses[keyof UnassignUserTaskResponses];

export type AssignUserTaskData = {
    body: UserTaskAssignmentRequest;
    path: {
        /**
         * The key of the user task to assign.
         */
        userTaskKey: UserTaskKey;
    };
    query?: never;
    url: '/user-tasks/{userTaskKey}/assignment';
};

export type AssignUserTaskErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The user task with the given key was not found.
     */
    404: ProblemDetail;
    /**
     * The user task with the given key is in the wrong state currently. More details are provided in the response body.
     *
     */
    409: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type AssignUserTaskError = AssignUserTaskErrors[keyof AssignUserTaskErrors];

export type AssignUserTaskResponses = {
    /**
     * The user task's assignment was adjusted.
     */
    204: void;
};

export type AssignUserTaskResponse = AssignUserTaskResponses[keyof AssignUserTaskResponses];

export type SearchUserTaskAuditLogsData = {
    body?: UserTaskAuditLogSearchQueryRequest;
    path: {
        /**
         * The key of the user task.
         */
        userTaskKey: UserTaskKey;
    };
    query?: never;
    url: '/user-tasks/{userTaskKey}/audit-logs/search';
};

export type SearchUserTaskAuditLogsErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type SearchUserTaskAuditLogsError = SearchUserTaskAuditLogsErrors[keyof SearchUserTaskAuditLogsErrors];

export type SearchUserTaskAuditLogsResponses = {
    /**
     * The user task audit log search result.
     */
    200: AuditLogSearchQueryResult;
};

export type SearchUserTaskAuditLogsResponse = SearchUserTaskAuditLogsResponses[keyof SearchUserTaskAuditLogsResponses];

export type CompleteUserTaskData = {
    body?: UserTaskCompletionRequest;
    path: {
        /**
         * The key of the user task to complete.
         */
        userTaskKey: UserTaskKey;
    };
    query?: never;
    url: '/user-tasks/{userTaskKey}/completion';
};

export type CompleteUserTaskErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The user task with the given key was not found.
     */
    404: ProblemDetail;
    /**
     * The user task with the given key is in the wrong state currently. More details are provided in the response body.
     *
     */
    409: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};

export type CompleteUserTaskError = CompleteUserTaskErrors[keyof CompleteUserTaskErrors];

export type CompleteUserTaskResponses = {
    /**
     * The user task was completed successfully.
     */
    204: void;
};

export type CompleteUserTaskResponse = CompleteUserTaskResponses[keyof CompleteUserTaskResponses];

export type GetUserTaskFormData = {
    body?: never;
    path: {
        /**
         * The user task key.
         */
        userTaskKey: UserTaskKey;
    };
    query?: never;
    url: '/user-tasks/{userTaskKey}/form';
};

export type GetUserTaskFormErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * Not found
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type GetUserTaskFormError = GetUserTaskFormErrors[keyof GetUserTaskFormErrors];

export type GetUserTaskFormResponses = {
    /**
     * The form is successfully returned.
     */
    200: FormResult;
    /**
     * The user task was found, but no form is associated with it.
     */
    204: void;
};

export type GetUserTaskFormResponse = GetUserTaskFormResponses[keyof GetUserTaskFormResponses];

export type SearchUserTaskVariablesData = {
    /**
     * User task search query request.
     */
    body?: SearchQueryRequest & {
        /**
         * Sort field criteria.
         */
        sort?: Array<{
            /**
             * The field to sort by.
             */
            field: 'value' | 'name' | 'tenantId' | 'variableKey' | 'scopeKey' | 'processInstanceKey';
            order?: SortOrderEnum;
        }>;
        /**
         * The user task variable search filters.
         */
        filter?: UserTaskVariableFilter;
    };
    path: {
        /**
         * The key of the user task.
         */
        userTaskKey: UserTaskKey;
    };
    query?: {
        /**
         * When true (default), long variable values in the response are truncated. When false, full variable values are returned.
         */
        truncateValues?: boolean;
    };
    url: '/user-tasks/{userTaskKey}/variables/search';
};

export type SearchUserTaskVariablesErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type SearchUserTaskVariablesError = SearchUserTaskVariablesErrors[keyof SearchUserTaskVariablesErrors];

export type SearchUserTaskVariablesResponses = {
    /**
     * The user task variable search result.
     */
    200: VariableSearchQueryResult;
};

export type SearchUserTaskVariablesResponse = SearchUserTaskVariablesResponses[keyof SearchUserTaskVariablesResponses];

export type SearchVariablesData = {
    /**
     * Variable search query request.
     */
    body?: SearchQueryRequest & {
        /**
         * Sort field criteria.
         */
        sort?: Array<{
            /**
             * The field to sort by.
             */
            field: 'value' | 'name' | 'tenantId' | 'variableKey' | 'scopeKey' | 'processInstanceKey';
            order?: SortOrderEnum;
        }>;
        /**
         * The variable search filters.
         */
        filter?: VariableFilter;
    };
    path?: never;
    query?: {
        /**
         * When true (default), long variable values in the response are truncated. When false, full variable values are returned.
         */
        truncateValues?: boolean;
    };
    url: '/variables/search';
};

export type SearchVariablesErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type SearchVariablesError = SearchVariablesErrors[keyof SearchVariablesErrors];

export type SearchVariablesResponses = {
    /**
     * The variable search result.
     */
    200: VariableSearchQueryResult;
};

export type SearchVariablesResponse = SearchVariablesResponses[keyof SearchVariablesResponses];

export type GetVariableData = {
    body?: never;
    path: {
        /**
         * The variable key.
         */
        variableKey: VariableKey;
    };
    query?: never;
    url: '/variables/{variableKey}';
};

export type GetVariableErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * Not found
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};

export type GetVariableError = GetVariableErrors[keyof GetVariableErrors];

export type GetVariableResponses = {
    /**
     * The variable is successfully returned.
     */
    200: VariableResult;
};

export type GetVariableResponse = GetVariableResponses[keyof GetVariableResponses];


// branding-plugin generated
// schemaVersion=1.0.0
// specHash=sha256:e5c28cd917d38e51aa2290bacffab37f63d08724be28bfd6901e20b5a932569d

export function assertConstraint(value: string, label: string, c: { pattern?: string; minLength?: number; maxLength?: number }) {
  if (c.pattern && !(new RegExp(c.pattern).test(value))) throw new Error(`[31mInvalid pattern for ${label}: '${value}'.[0m Needs to match: ${JSON.stringify(c)}
`);
  if (typeof c.minLength === "number" && value.length < c.minLength) throw new Error(`Value too short for ${label}`);
  if (typeof c.maxLength === "number" && value.length > c.maxLength) throw new Error(`Value too long for ${label}`);
}
// System-generated entity key for an audit log entry.
export namespace AuditLogEntityKey {
  export function assumeExists(value: string): AuditLogEntityKey {
    return value as any;
  }
  export function getValue(key: AuditLogEntityKey): string { return key; }
  export function isValid(value: string): boolean {
    return true;
  }
}
// System-generated key for an audit log entry.
export namespace AuditLogKey {
  export function assumeExists(value: string): AuditLogKey {
    assertConstraint(value, 'AuditLogKey', { pattern: "^-?[0-9]+$", minLength: 1, maxLength: 25 });
    return value as any;
  }
  export function getValue(key: AuditLogKey): string { return key; }
  export function isValid(value: string): boolean {
    try {
      assertConstraint(value, 'AuditLogKey', { pattern: "^-?[0-9]+$", minLength: 1, maxLength: 25 });
      return true;
    } catch { return false; }
  }
}
// System-generated key for an authorization.
export namespace AuthorizationKey {
  export function assumeExists(value: string): AuthorizationKey {
    assertConstraint(value, 'AuthorizationKey', { pattern: "^-?[0-9]+$", minLength: 1, maxLength: 25 });
    return value as any;
  }
  export function getValue(key: AuthorizationKey): string { return key; }
  export function isValid(value: string): boolean {
    try {
      assertConstraint(value, 'AuthorizationKey', { pattern: "^-?[0-9]+$", minLength: 1, maxLength: 25 });
      return true;
    } catch { return false; }
  }
}
// System-generated key for an batch operation.
export namespace BatchOperationKey {
  export function assumeExists(value: string): BatchOperationKey {
    return value as any;
  }
  export function getValue(key: BatchOperationKey): string { return key; }
  export function isValid(value: string): boolean {
    return true;
  }
}
// System-generated key for a conditional evaluation.
export namespace ConditionalEvaluationKey {
  export function assumeExists(value: string): ConditionalEvaluationKey {
    assertConstraint(value, 'ConditionalEvaluationKey', { pattern: "^-?[0-9]+$", minLength: 1, maxLength: 25 });
    return value as any;
  }
  export function getValue(key: ConditionalEvaluationKey): string { return key; }
  export function isValid(value: string): boolean {
    try {
      assertConstraint(value, 'ConditionalEvaluationKey', { pattern: "^-?[0-9]+$", minLength: 1, maxLength: 25 });
      return true;
    } catch { return false; }
  }
}
// Id of a decision definition, from the model. Only ids of decision definitions that are deployed are useful.
export namespace DecisionDefinitionId {
  export function assumeExists(value: string): DecisionDefinitionId {
    assertConstraint(value, 'DecisionDefinitionId', { pattern: "^[A-Za-z0-9_@.+-]+$", minLength: 1, maxLength: 256 });
    return value as any;
  }
  export function getValue(key: DecisionDefinitionId): string { return key; }
  export function isValid(value: string): boolean {
    try {
      assertConstraint(value, 'DecisionDefinitionId', { pattern: "^[A-Za-z0-9_@.+-]+$", minLength: 1, maxLength: 256 });
      return true;
    } catch { return false; }
  }
}
// System-generated key for a decision definition.
export namespace DecisionDefinitionKey {
  export function assumeExists(value: string): DecisionDefinitionKey {
    assertConstraint(value, 'DecisionDefinitionKey', { pattern: "^-?[0-9]+$", minLength: 1, maxLength: 25 });
    return value as any;
  }
  export function getValue(key: DecisionDefinitionKey): string { return key; }
  export function isValid(value: string): boolean {
    try {
      assertConstraint(value, 'DecisionDefinitionKey', { pattern: "^-?[0-9]+$", minLength: 1, maxLength: 25 });
      return true;
    } catch { return false; }
  }
}
// System-generated key for a decision evaluation instance.
export namespace DecisionEvaluationInstanceKey {
  export function assumeExists(value: string): DecisionEvaluationInstanceKey {
    assertConstraint(value, 'DecisionEvaluationInstanceKey', { pattern: "^-?[0-9]+$", minLength: 1, maxLength: 25 });
    return value as any;
  }
  export function getValue(key: DecisionEvaluationInstanceKey): string { return key; }
  export function isValid(value: string): boolean {
    try {
      assertConstraint(value, 'DecisionEvaluationInstanceKey', { pattern: "^-?[0-9]+$", minLength: 1, maxLength: 25 });
      return true;
    } catch { return false; }
  }
}
// System-generated key for a decision evaluation.
export namespace DecisionEvaluationKey {
  export function assumeExists(value: string): DecisionEvaluationKey {
    assertConstraint(value, 'DecisionEvaluationKey', { pattern: "^-?[0-9]+$", minLength: 1, maxLength: 25 });
    return value as any;
  }
  export function getValue(key: DecisionEvaluationKey): string { return key; }
  export function isValid(value: string): boolean {
    try {
      assertConstraint(value, 'DecisionEvaluationKey', { pattern: "^-?[0-9]+$", minLength: 1, maxLength: 25 });
      return true;
    } catch { return false; }
  }
}
// System-generated key for a deployed decision instance.
export namespace DecisionInstanceKey {
  export function assumeExists(value: string): DecisionInstanceKey {
    assertConstraint(value, 'DecisionInstanceKey', { pattern: "^-?[0-9]+$", minLength: 1, maxLength: 25 });
    return value as any;
  }
  export function getValue(key: DecisionInstanceKey): string { return key; }
  export function isValid(value: string): boolean {
    try {
      assertConstraint(value, 'DecisionInstanceKey', { pattern: "^-?[0-9]+$", minLength: 1, maxLength: 25 });
      return true;
    } catch { return false; }
  }
}
// System-generated key for a deployed decision requirements definition.
export namespace DecisionRequirementsKey {
  export function assumeExists(value: string): DecisionRequirementsKey {
    assertConstraint(value, 'DecisionRequirementsKey', { pattern: "^-?[0-9]+$", minLength: 1, maxLength: 25 });
    return value as any;
  }
  export function getValue(key: DecisionRequirementsKey): string { return key; }
  export function isValid(value: string): boolean {
    try {
      assertConstraint(value, 'DecisionRequirementsKey', { pattern: "^-?[0-9]+$", minLength: 1, maxLength: 25 });
      return true;
    } catch { return false; }
  }
}
// Key for a deployment.
export namespace DeploymentKey {
  export function assumeExists(value: string): DeploymentKey {
    assertConstraint(value, 'DeploymentKey', { pattern: "^-?[0-9]+$", minLength: 1, maxLength: 25 });
    return value as any;
  }
  export function getValue(key: DeploymentKey): string { return key; }
  export function isValid(value: string): boolean {
    try {
      assertConstraint(value, 'DeploymentKey', { pattern: "^-?[0-9]+$", minLength: 1, maxLength: 25 });
      return true;
    } catch { return false; }
  }
}
// Document Id that uniquely identifies a document.
export namespace DocumentId {
  export function assumeExists(value: string): DocumentId {
    return value as any;
  }
  export function getValue(key: DocumentId): string { return key; }
  export function isValid(value: string): boolean {
    return true;
  }
}
// The model-defined id of an element.
export namespace ElementId {
  export function assumeExists(value: string): ElementId {
    return value as any;
  }
  export function getValue(key: ElementId): string { return key; }
  export function isValid(value: string): boolean {
    return true;
  }
}
// System-generated key for a element instance.
export namespace ElementInstanceKey {
  export function assumeExists(value: string): ElementInstanceKey {
    assertConstraint(value, 'ElementInstanceKey', { pattern: "^-?[0-9]+$", minLength: 1, maxLength: 25 });
    return value as any;
  }
  export function getValue(key: ElementInstanceKey): string { return key; }
  export function isValid(value: string): boolean {
    try {
      assertConstraint(value, 'ElementInstanceKey', { pattern: "^-?[0-9]+$", minLength: 1, maxLength: 25 });
      return true;
    } catch { return false; }
  }
}
// The end cursor in a search query result set.
export namespace EndCursor {
  export function assumeExists(value: string): EndCursor {
    assertConstraint(value, 'EndCursor', { pattern: "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}(?:==)?|[A-Za-z0-9+/]{3}=)?$", minLength: 2, maxLength: 300 });
    return value as any;
  }
  export function getValue(key: EndCursor): string { return key; }
  export function isValid(value: string): boolean {
    try {
      assertConstraint(value, 'EndCursor', { pattern: "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}(?:==)?|[A-Za-z0-9+/]{3}=)?$", minLength: 2, maxLength: 300 });
      return true;
    } catch { return false; }
  }
}
// The user-defined id for the form
export namespace FormId {
  export function assumeExists(value: string): FormId {
    return value as any;
  }
  export function getValue(key: FormId): string { return key; }
  export function isValid(value: string): boolean {
    return true;
  }
}
// System-generated key for a deployed form.
export namespace FormKey {
  export function assumeExists(value: string): FormKey {
    assertConstraint(value, 'FormKey', { pattern: "^-?[0-9]+$", minLength: 1, maxLength: 25 });
    return value as any;
  }
  export function getValue(key: FormKey): string { return key; }
  export function isValid(value: string): boolean {
    try {
      assertConstraint(value, 'FormKey', { pattern: "^-?[0-9]+$", minLength: 1, maxLength: 25 });
      return true;
    } catch { return false; }
  }
}
// The user-defined id for the global listener
export namespace GlobalListenerId {
  export function assumeExists(value: string): GlobalListenerId {
    return value as any;
  }
  export function getValue(key: GlobalListenerId): string { return key; }
  export function isValid(value: string): boolean {
    return true;
  }
}
// System-generated key for a incident.
export namespace IncidentKey {
  export function assumeExists(value: string): IncidentKey {
    assertConstraint(value, 'IncidentKey', { pattern: "^-?[0-9]+$", minLength: 1, maxLength: 25 });
    return value as any;
  }
  export function getValue(key: IncidentKey): string { return key; }
  export function isValid(value: string): boolean {
    try {
      assertConstraint(value, 'IncidentKey', { pattern: "^-?[0-9]+$", minLength: 1, maxLength: 25 });
      return true;
    } catch { return false; }
  }
}
// System-generated key for a job.
export namespace JobKey {
  export function assumeExists(value: string): JobKey {
    assertConstraint(value, 'JobKey', { pattern: "^-?[0-9]+$", minLength: 1, maxLength: 25 });
    return value as any;
  }
  export function getValue(key: JobKey): string { return key; }
  export function isValid(value: string): boolean {
    try {
      assertConstraint(value, 'JobKey', { pattern: "^-?[0-9]+$", minLength: 1, maxLength: 25 });
      return true;
    } catch { return false; }
  }
}
// System-generated key for an message.
export namespace MessageKey {
  export function assumeExists(value: string): MessageKey {
    assertConstraint(value, 'MessageKey', { pattern: "^-?[0-9]+$", minLength: 1, maxLength: 25 });
    return value as any;
  }
  export function getValue(key: MessageKey): string { return key; }
  export function isValid(value: string): boolean {
    try {
      assertConstraint(value, 'MessageKey', { pattern: "^-?[0-9]+$", minLength: 1, maxLength: 25 });
      return true;
    } catch { return false; }
  }
}
// System-generated key for a message subscription.
export namespace MessageSubscriptionKey {
  export function assumeExists(value: string): MessageSubscriptionKey {
    assertConstraint(value, 'MessageSubscriptionKey', { pattern: "^-?[0-9]+$", minLength: 1, maxLength: 25 });
    return value as any;
  }
  export function getValue(key: MessageSubscriptionKey): string { return key; }
  export function isValid(value: string): boolean {
    try {
      assertConstraint(value, 'MessageSubscriptionKey', { pattern: "^-?[0-9]+$", minLength: 1, maxLength: 25 });
      return true;
    } catch { return false; }
  }
}
// Id of a process definition, from the model. Only ids of process definitions that are deployed are useful.
export namespace ProcessDefinitionId {
  export function assumeExists(value: string): ProcessDefinitionId {
    assertConstraint(value, 'ProcessDefinitionId', { pattern: "^[a-zA-Z_][a-zA-Z0-9_\\-\\.]*$", minLength: 1 });
    return value as any;
  }
  export function getValue(key: ProcessDefinitionId): string { return key; }
  export function isValid(value: string): boolean {
    try {
      assertConstraint(value, 'ProcessDefinitionId', { pattern: "^[a-zA-Z_][a-zA-Z0-9_\\-\\.]*$", minLength: 1 });
      return true;
    } catch { return false; }
  }
}
// System-generated key for a deployed process definition.
export namespace ProcessDefinitionKey {
  export function assumeExists(value: string): ProcessDefinitionKey {
    assertConstraint(value, 'ProcessDefinitionKey', { pattern: "^-?[0-9]+$", minLength: 1, maxLength: 25 });
    return value as any;
  }
  export function getValue(key: ProcessDefinitionKey): string { return key; }
  export function isValid(value: string): boolean {
    try {
      assertConstraint(value, 'ProcessDefinitionKey', { pattern: "^-?[0-9]+$", minLength: 1, maxLength: 25 });
      return true;
    } catch { return false; }
  }
}
// System-generated key for a process instance.
export namespace ProcessInstanceKey {
  export function assumeExists(value: string): ProcessInstanceKey {
    assertConstraint(value, 'ProcessInstanceKey', { pattern: "^-?[0-9]+$", minLength: 1, maxLength: 25 });
    return value as any;
  }
  export function getValue(key: ProcessInstanceKey): string { return key; }
  export function isValid(value: string): boolean {
    try {
      assertConstraint(value, 'ProcessInstanceKey', { pattern: "^-?[0-9]+$", minLength: 1, maxLength: 25 });
      return true;
    } catch { return false; }
  }
}
// The key of the root process instance. The root process instance is the top-level ancestor in the process instance hierarchy. This field is only present for data belonging to process instance hierarchies created in version 8.9 or later. 
export namespace RootProcessInstanceKey {
  export function assumeExists(value: string): RootProcessInstanceKey {
    assertConstraint(value, 'RootProcessInstanceKey', { pattern: "^-?[0-9]+$", minLength: 1, maxLength: 25 });
    return value as any;
  }
  export function getValue(key: RootProcessInstanceKey): string { return key; }
  export function isValid(value: string): boolean {
    try {
      assertConstraint(value, 'RootProcessInstanceKey', { pattern: "^-?[0-9]+$", minLength: 1, maxLength: 25 });
      return true;
    } catch { return false; }
  }
}
// System-generated key for a scope.
export namespace ScopeKey {
  export function assumeExists(value: string): ScopeKey {
    assertConstraint(value, 'ScopeKey', { pattern: "^-?[0-9]+$", minLength: 1, maxLength: 25 });
    return value as any;
  }
  export function getValue(key: ScopeKey): string { return key; }
  export function isValid(value: string): boolean {
    try {
      assertConstraint(value, 'ScopeKey', { pattern: "^-?[0-9]+$", minLength: 1, maxLength: 25 });
      return true;
    } catch { return false; }
  }
}
// System-generated key for an signal.
export namespace SignalKey {
  export function assumeExists(value: string): SignalKey {
    assertConstraint(value, 'SignalKey', { pattern: "^-?[0-9]+$", minLength: 1, maxLength: 25 });
    return value as any;
  }
  export function getValue(key: SignalKey): string { return key; }
  export function isValid(value: string): boolean {
    try {
      assertConstraint(value, 'SignalKey', { pattern: "^-?[0-9]+$", minLength: 1, maxLength: 25 });
      return true;
    } catch { return false; }
  }
}
// The start cursor in a search query result set.
export namespace StartCursor {
  export function assumeExists(value: string): StartCursor {
    assertConstraint(value, 'StartCursor', { pattern: "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}(?:==)?|[A-Za-z0-9+/]{3}=)?$", minLength: 2, maxLength: 300 });
    return value as any;
  }
  export function getValue(key: StartCursor): string { return key; }
  export function isValid(value: string): boolean {
    try {
      assertConstraint(value, 'StartCursor', { pattern: "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}(?:==)?|[A-Za-z0-9+/]{3}=)?$", minLength: 2, maxLength: 300 });
      return true;
    } catch { return false; }
  }
}
// A tag. Needs to start with a letter; then alphanumerics, `_`, `-`, `:`, or `.`; length  100.
export namespace Tag {
  export function fromString(value: string): Tag {
    assertConstraint(value, 'Tag', { pattern: "^[A-Za-z][A-Za-z0-9_\\-:.]{0,99}$", minLength: 1, maxLength: 100 });
    return value as any;
  }
  export function getValue(key: Tag): string { return key; }
  export function isValid(value: string): boolean {
    try {
      assertConstraint(value, 'Tag', { pattern: "^[A-Za-z][A-Za-z0-9_\\-:.]{0,99}$", minLength: 1, maxLength: 100 });
      return true;
    } catch { return false; }
  }
}
// The unique identifier of the tenant.
export namespace TenantId {
  export function assumeExists(value: string): TenantId {
    assertConstraint(value, 'TenantId', { pattern: "^(<default>|[A-Za-z0-9_@.+-]+)$", minLength: 1, maxLength: 256 });
    return value as any;
  }
  export function getValue(key: TenantId): string { return key; }
  export function isValid(value: string): boolean {
    try {
      assertConstraint(value, 'TenantId', { pattern: "^(<default>|[A-Za-z0-9_@.+-]+)$", minLength: 1, maxLength: 256 });
      return true;
    } catch { return false; }
  }
}
// The unique name of a user.
export namespace Username {
  export function assumeExists(value: string): Username {
    assertConstraint(value, 'Username', { pattern: "^(<default>|[A-Za-z0-9_@.+-]+)$", minLength: 1, maxLength: 256 });
    return value as any;
  }
  export function getValue(key: Username): string { return key; }
  export function isValid(value: string): boolean {
    try {
      assertConstraint(value, 'Username', { pattern: "^(<default>|[A-Za-z0-9_@.+-]+)$", minLength: 1, maxLength: 256 });
      return true;
    } catch { return false; }
  }
}
// System-generated key for a user task.
export namespace UserTaskKey {
  export function assumeExists(value: string): UserTaskKey {
    assertConstraint(value, 'UserTaskKey', { pattern: "^-?[0-9]+$", minLength: 1, maxLength: 25 });
    return value as any;
  }
  export function getValue(key: UserTaskKey): string { return key; }
  export function isValid(value: string): boolean {
    try {
      assertConstraint(value, 'UserTaskKey', { pattern: "^-?[0-9]+$", minLength: 1, maxLength: 25 });
      return true;
    } catch { return false; }
  }
}
// System-generated key for a variable.
export namespace VariableKey {
  export function assumeExists(value: string): VariableKey {
    assertConstraint(value, 'VariableKey', { pattern: "^-?[0-9]+$", minLength: 1, maxLength: 25 });
    return value as any;
  }
  export function getValue(key: VariableKey): string { return key; }
  export function isValid(value: string): boolean {
    try {
      assertConstraint(value, 'VariableKey', { pattern: "^-?[0-9]+$", minLength: 1, maxLength: 25 });
      return true;
    } catch { return false; }
  }
}