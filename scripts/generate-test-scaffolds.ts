import fs from 'fs';
import path from 'path';

// Generates missing integration test scaffolds for each exported SDK operation (sdk.gen.ts)
// and refreshes the manifest file. Intended to run during `npm run generate` before tests.

const ROOT = process.cwd();
const SDK_FILE = path.join(ROOT, 'src/gen/sdk.gen.ts');
const TEST_DIR = path.join(ROOT, 'tests-integration', 'methods');
const MANIFEST = path.join(TEST_DIR, 'manifest.json');

interface Manifest {
  generatedAt: string;
  operations: number;
  tests: number;
  missing: string[];
  ignored: string[];
  files: string[];
  note?: string;
}

// Allow optional ignore list colocated in manifest (merged if present)
let ignore: string[] = [];
if (fs.existsSync(MANIFEST)) {
  try { const current = JSON.parse(fs.readFileSync(MANIFEST, 'utf8')); if (Array.isArray(current.ignored)) ignore = current.ignored; } catch {/* ignore */}
}

if (!fs.existsSync(SDK_FILE)) {
  console.error('[generate-test-scaffolds] sdk.gen.ts not found; aborting');
  process.exit(0);
}

const sdkSource = fs.readFileSync(SDK_FILE, 'utf8');
// Match lines like: export const getFoo = ...
const opRegex = /^export const (\w+)\s*=\s*/gm;
const operations: string[] = [];
let m: RegExpExecArray | null;
while ((m = opRegex.exec(sdkSource)) !== null) {
  const name = m[1];
  // filter obvious non-operation exports if any appear later (none currently)
  operations.push(name);
}

if (!fs.existsSync(TEST_DIR)) fs.mkdirSync(TEST_DIR, { recursive: true });

const existingTestFiles = fs.readdirSync(TEST_DIR).filter(f => f.endsWith('.test.ts'));
const existingSet = new Set(existingTestFiles);

const created: string[] = [];
for (const op of operations) {
  if (ignore.includes(op)) continue;
  const fileName = `${op}.test.ts`;
  if (!existingSet.has(fileName)) {
    const content = `// AUTO-GENERATED SCAFFOLD. You can flesh out the test body; file will not be overwritten once it exists.\nimport { describe, it } from 'vitest';\nimport { createCamundaClient } from '../../dist';\n\ndescribe('${op}', () => {\n  it('scaffold', () => {\n    const camunda = createCamundaClient();\n    // TODO: implement ${op} test logic\n  });\n});\n`;
    fs.writeFileSync(path.join(TEST_DIR, fileName), content, 'utf8');
    created.push(fileName);
  }
}

// Recompute final file list after creation
const finalFiles = fs.readdirSync(TEST_DIR).filter(f => f.endsWith('.test.ts')).sort();
const missing = operations.filter(op => ignore.indexOf(op) === -1 && !finalFiles.includes(`${op}.test.ts`));

const manifest: Manifest = {
  generatedAt: new Date().toISOString(),
  operations: operations.length,
  tests: finalFiles.length,
  missing: missing.map(m => `${m}.test.ts`),
  ignored: ignore,
  files: finalFiles,
  note: 'Auto-generated mapping of CamundaClient method test scaffolds. Regenerated by scripts/generate-test-scaffolds.ts'
};

fs.writeFileSync(MANIFEST, JSON.stringify(manifest, null, 2) + '\n', 'utf8');

if (created.length) {
  console.log(`[generate-test-scaffolds] Created ${created.length} new scaffold(s):\n  - ${created.join('\n  - ')}`);
} else {
  console.log('[generate-test-scaffolds] No new scaffolds needed');
}

if (missing.length) {
  console.warn(`[generate-test-scaffolds] WARNING: ${missing.length} operation(s) still missing tests (see manifest).`);
}
